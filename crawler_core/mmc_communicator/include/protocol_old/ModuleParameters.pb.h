// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ModuleParameters.proto

#ifndef PROTOBUF_ModuleParameters_2eproto__INCLUDED
#define PROTOBUF_ModuleParameters_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace protos {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ModuleParameters_2eproto();
void protobuf_AssignDesc_ModuleParameters_2eproto();
void protobuf_ShutdownFile_ModuleParameters_2eproto();

class ParameterMessage;
class PidControllerParameters;
class ControlLoopParameters;
class EthernetParameters;
class ImuParameters;
class LedParameters;

enum ImuParameters_AccelScale {
  ImuParameters_AccelScale_G_2 = 2,
  ImuParameters_AccelScale_G_4 = 4,
  ImuParameters_AccelScale_G_8 = 8,
  ImuParameters_AccelScale_G_16 = 16
};
bool ImuParameters_AccelScale_IsValid(int value);
const ImuParameters_AccelScale ImuParameters_AccelScale_AccelScale_MIN = ImuParameters_AccelScale_G_2;
const ImuParameters_AccelScale ImuParameters_AccelScale_AccelScale_MAX = ImuParameters_AccelScale_G_16;
const int ImuParameters_AccelScale_AccelScale_ARRAYSIZE = ImuParameters_AccelScale_AccelScale_MAX + 1;

enum ImuParameters_AccelCutoff {
  ImuParameters_AccelCutoff_Hz_260 = 1,
  ImuParameters_AccelCutoff_Hz_184 = 2,
  ImuParameters_AccelCutoff_Hz_94 = 3,
  ImuParameters_AccelCutoff_Hz_44 = 4,
  ImuParameters_AccelCutoff_Hz_21 = 5,
  ImuParameters_AccelCutoff_Hz_10 = 6,
  ImuParameters_AccelCutoff_Hz_5 = 7
};
bool ImuParameters_AccelCutoff_IsValid(int value);
const ImuParameters_AccelCutoff ImuParameters_AccelCutoff_AccelCutoff_MIN = ImuParameters_AccelCutoff_Hz_260;
const ImuParameters_AccelCutoff ImuParameters_AccelCutoff_AccelCutoff_MAX = ImuParameters_AccelCutoff_Hz_5;
const int ImuParameters_AccelCutoff_AccelCutoff_ARRAYSIZE = ImuParameters_AccelCutoff_AccelCutoff_MAX + 1;

enum ImuParameters_GyroScale {
  ImuParameters_GyroScale_DEG_PER_S_250 = 1,
  ImuParameters_GyroScale_DEG_PER_S_500 = 2,
  ImuParameters_GyroScale_DEG_PER_S_1000 = 3,
  ImuParameters_GyroScale_DEG_PER_S_2000 = 4
};
bool ImuParameters_GyroScale_IsValid(int value);
const ImuParameters_GyroScale ImuParameters_GyroScale_GyroScale_MIN = ImuParameters_GyroScale_DEG_PER_S_250;
const ImuParameters_GyroScale ImuParameters_GyroScale_GyroScale_MAX = ImuParameters_GyroScale_DEG_PER_S_2000;
const int ImuParameters_GyroScale_GyroScale_ARRAYSIZE = ImuParameters_GyroScale_GyroScale_MAX + 1;

// ===================================================================

class ParameterMessage : public ::google::protobuf::MessageLite {
 public:
  ParameterMessage();
  virtual ~ParameterMessage();

  ParameterMessage(const ParameterMessage& from);

  inline ParameterMessage& operator=(const ParameterMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ParameterMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ParameterMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ParameterMessage* other);

  // implements Message ----------------------------------------------

  ParameterMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ParameterMessage& from);
  void MergeFrom(const ParameterMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protos.ControlLoopParameters control_loop_parameters = 1;
  inline bool has_control_loop_parameters() const;
  inline void clear_control_loop_parameters();
  static const int kControlLoopParametersFieldNumber = 1;
  inline const ::protos::ControlLoopParameters& control_loop_parameters() const;
  inline ::protos::ControlLoopParameters* mutable_control_loop_parameters();
  inline ::protos::ControlLoopParameters* release_control_loop_parameters();
  inline void set_allocated_control_loop_parameters(::protos::ControlLoopParameters* control_loop_parameters);

  // optional .protos.EthernetParameters ethernet_parameters = 2;
  inline bool has_ethernet_parameters() const;
  inline void clear_ethernet_parameters();
  static const int kEthernetParametersFieldNumber = 2;
  inline const ::protos::EthernetParameters& ethernet_parameters() const;
  inline ::protos::EthernetParameters* mutable_ethernet_parameters();
  inline ::protos::EthernetParameters* release_ethernet_parameters();
  inline void set_allocated_ethernet_parameters(::protos::EthernetParameters* ethernet_parameters);

  // optional .protos.ImuParameters imu_parameters = 3;
  inline bool has_imu_parameters() const;
  inline void clear_imu_parameters();
  static const int kImuParametersFieldNumber = 3;
  inline const ::protos::ImuParameters& imu_parameters() const;
  inline ::protos::ImuParameters* mutable_imu_parameters();
  inline ::protos::ImuParameters* release_imu_parameters();
  inline void set_allocated_imu_parameters(::protos::ImuParameters* imu_parameters);

  // optional .protos.LedParameters led_parameters = 4;
  inline bool has_led_parameters() const;
  inline void clear_led_parameters();
  static const int kLedParametersFieldNumber = 4;
  inline const ::protos::LedParameters& led_parameters() const;
  inline ::protos::LedParameters* mutable_led_parameters();
  inline ::protos::LedParameters* release_led_parameters();
  inline void set_allocated_led_parameters(::protos::LedParameters* led_parameters);

  // @@protoc_insertion_point(class_scope:protos.ParameterMessage)
 private:
  inline void set_has_control_loop_parameters();
  inline void clear_has_control_loop_parameters();
  inline void set_has_ethernet_parameters();
  inline void clear_has_ethernet_parameters();
  inline void set_has_imu_parameters();
  inline void clear_has_imu_parameters();
  inline void set_has_led_parameters();
  inline void clear_has_led_parameters();

  ::protos::ControlLoopParameters* control_loop_parameters_;
  ::protos::EthernetParameters* ethernet_parameters_;
  ::protos::ImuParameters* imu_parameters_;
  ::protos::LedParameters* led_parameters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ModuleParameters_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ModuleParameters_2eproto();
  #endif
  friend void protobuf_AssignDesc_ModuleParameters_2eproto();
  friend void protobuf_ShutdownFile_ModuleParameters_2eproto();

  void InitAsDefaultInstance();
  static ParameterMessage* default_instance_;
};
// -------------------------------------------------------------------

class PidControllerParameters : public ::google::protobuf::MessageLite {
 public:
  PidControllerParameters();
  virtual ~PidControllerParameters();

  PidControllerParameters(const PidControllerParameters& from);

  inline PidControllerParameters& operator=(const PidControllerParameters& from) {
    CopyFrom(from);
    return *this;
  }

  static const PidControllerParameters& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PidControllerParameters* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PidControllerParameters* other);

  // implements Message ----------------------------------------------

  PidControllerParameters* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PidControllerParameters& from);
  void MergeFrom(const PidControllerParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float kp = 1;
  inline bool has_kp() const;
  inline void clear_kp();
  static const int kKpFieldNumber = 1;
  inline float kp() const;
  inline void set_kp(float value);

  // optional float ki = 2;
  inline bool has_ki() const;
  inline void clear_ki();
  static const int kKiFieldNumber = 2;
  inline float ki() const;
  inline void set_ki(float value);

  // optional float kd = 3;
  inline bool has_kd() const;
  inline void clear_kd();
  static const int kKdFieldNumber = 3;
  inline float kd() const;
  inline void set_kd(float value);

  // optional float ff = 4;
  inline bool has_ff() const;
  inline void clear_ff();
  static const int kFfFieldNumber = 4;
  inline float ff() const;
  inline void set_ff(float value);

  // optional float dead_zone = 5;
  inline bool has_dead_zone() const;
  inline void clear_dead_zone();
  static const int kDeadZoneFieldNumber = 5;
  inline float dead_zone() const;
  inline void set_dead_zone(float value);

  // optional float i_clamp = 6;
  inline bool has_i_clamp() const;
  inline void clear_i_clamp();
  static const int kIClampFieldNumber = 6;
  inline float i_clamp() const;
  inline void set_i_clamp(float value);

  // optional bool enabled = 7;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 7;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // optional float punch = 8;
  inline bool has_punch() const;
  inline void clear_punch();
  static const int kPunchFieldNumber = 8;
  inline float punch() const;
  inline void set_punch(float value);

  // optional float d_window_Size = 9;
  inline bool has_d_window_size() const;
  inline void clear_d_window_size();
  static const int kDWindowSizeFieldNumber = 9;
  inline float d_window_size() const;
  inline void set_d_window_size(float value);

  // optional float max_target_value = 10;
  inline bool has_max_target_value() const;
  inline void clear_max_target_value();
  static const int kMaxTargetValueFieldNumber = 10;
  inline float max_target_value() const;
  inline void set_max_target_value(float value);

  // optional float max_output_value = 11;
  inline bool has_max_output_value() const;
  inline void clear_max_output_value();
  static const int kMaxOutputValueFieldNumber = 11;
  inline float max_output_value() const;
  inline void set_max_output_value(float value);

  // optional float target_lowpass_gain = 12;
  inline bool has_target_lowpass_gain() const;
  inline void clear_target_lowpass_gain();
  static const int kTargetLowpassGainFieldNumber = 12;
  inline float target_lowpass_gain() const;
  inline void set_target_lowpass_gain(float value);

  // optional float output_lowpass_gain = 13;
  inline bool has_output_lowpass_gain() const;
  inline void clear_output_lowpass_gain();
  static const int kOutputLowpassGainFieldNumber = 13;
  inline float output_lowpass_gain() const;
  inline void set_output_lowpass_gain(float value);

  // optional bool d_on_error = 14;
  inline bool has_d_on_error() const;
  inline void clear_d_on_error();
  static const int kDOnErrorFieldNumber = 14;
  inline bool d_on_error() const;
  inline void set_d_on_error(bool value);

  // @@protoc_insertion_point(class_scope:protos.PidControllerParameters)
 private:
  inline void set_has_kp();
  inline void clear_has_kp();
  inline void set_has_ki();
  inline void clear_has_ki();
  inline void set_has_kd();
  inline void clear_has_kd();
  inline void set_has_ff();
  inline void clear_has_ff();
  inline void set_has_dead_zone();
  inline void clear_has_dead_zone();
  inline void set_has_i_clamp();
  inline void clear_has_i_clamp();
  inline void set_has_enabled();
  inline void clear_has_enabled();
  inline void set_has_punch();
  inline void clear_has_punch();
  inline void set_has_d_window_size();
  inline void clear_has_d_window_size();
  inline void set_has_max_target_value();
  inline void clear_has_max_target_value();
  inline void set_has_max_output_value();
  inline void clear_has_max_output_value();
  inline void set_has_target_lowpass_gain();
  inline void clear_has_target_lowpass_gain();
  inline void set_has_output_lowpass_gain();
  inline void clear_has_output_lowpass_gain();
  inline void set_has_d_on_error();
  inline void clear_has_d_on_error();

  float kp_;
  float ki_;
  float kd_;
  float ff_;
  float dead_zone_;
  float i_clamp_;
  float punch_;
  float d_window_size_;
  float max_target_value_;
  bool enabled_;
  bool d_on_error_;
  float max_output_value_;
  float target_lowpass_gain_;
  float output_lowpass_gain_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ModuleParameters_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ModuleParameters_2eproto();
  #endif
  friend void protobuf_AssignDesc_ModuleParameters_2eproto();
  friend void protobuf_ShutdownFile_ModuleParameters_2eproto();

  void InitAsDefaultInstance();
  static PidControllerParameters* default_instance_;
};
// -------------------------------------------------------------------

class ControlLoopParameters : public ::google::protobuf::MessageLite {
 public:
  ControlLoopParameters();
  virtual ~ControlLoopParameters();

  ControlLoopParameters(const ControlLoopParameters& from);

  inline ControlLoopParameters& operator=(const ControlLoopParameters& from) {
    CopyFrom(from);
    return *this;
  }

  static const ControlLoopParameters& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ControlLoopParameters* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ControlLoopParameters* other);

  // implements Message ----------------------------------------------

  ControlLoopParameters* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ControlLoopParameters& from);
  void MergeFrom(const ControlLoopParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool save = 1;
  inline bool has_save() const;
  inline void clear_save();
  static const int kSaveFieldNumber = 1;
  inline bool save() const;
  inline void set_save(bool value);

  // optional float cascaded_period = 5;
  inline bool has_cascaded_period() const;
  inline void clear_cascaded_period();
  static const int kCascadedPeriodFieldNumber = 5;
  inline float cascaded_period() const;
  inline void set_cascaded_period(float value);

  // optional .protos.PidControllerParameters cascaded_position_pid_parameters = 6;
  inline bool has_cascaded_position_pid_parameters() const;
  inline void clear_cascaded_position_pid_parameters();
  static const int kCascadedPositionPidParametersFieldNumber = 6;
  inline const ::protos::PidControllerParameters& cascaded_position_pid_parameters() const;
  inline ::protos::PidControllerParameters* mutable_cascaded_position_pid_parameters();
  inline ::protos::PidControllerParameters* release_cascaded_position_pid_parameters();
  inline void set_allocated_cascaded_position_pid_parameters(::protos::PidControllerParameters* cascaded_position_pid_parameters);

  // optional .protos.PidControllerParameters cascaded_velocity_p_parameters = 7;
  inline bool has_cascaded_velocity_p_parameters() const;
  inline void clear_cascaded_velocity_p_parameters();
  static const int kCascadedVelocityPParametersFieldNumber = 7;
  inline const ::protos::PidControllerParameters& cascaded_velocity_p_parameters() const;
  inline ::protos::PidControllerParameters* mutable_cascaded_velocity_p_parameters();
  inline ::protos::PidControllerParameters* release_cascaded_velocity_p_parameters();
  inline void set_allocated_cascaded_velocity_p_parameters(::protos::PidControllerParameters* cascaded_velocity_p_parameters);

  // optional .protos.PidControllerParameters cascaded_torque_pid_parameters = 8;
  inline bool has_cascaded_torque_pid_parameters() const;
  inline void clear_cascaded_torque_pid_parameters();
  static const int kCascadedTorquePidParametersFieldNumber = 8;
  inline const ::protos::PidControllerParameters& cascaded_torque_pid_parameters() const;
  inline ::protos::PidControllerParameters* mutable_cascaded_torque_pid_parameters();
  inline ::protos::PidControllerParameters* release_cascaded_torque_pid_parameters();
  inline void set_allocated_cascaded_torque_pid_parameters(::protos::PidControllerParameters* cascaded_torque_pid_parameters);

  // optional bool cascaded_enabled = 9;
  inline bool has_cascaded_enabled() const;
  inline void clear_cascaded_enabled();
  static const int kCascadedEnabledFieldNumber = 9;
  inline bool cascaded_enabled() const;
  inline void set_cascaded_enabled(bool value);

  // optional float motor_current_limit = 100;
  inline bool has_motor_current_limit() const;
  inline void clear_motor_current_limit();
  static const int kMotorCurrentLimitFieldNumber = 100;
  inline float motor_current_limit() const;
  inline void set_motor_current_limit(float value);

  // optional float spring_constant = 101;
  inline bool has_spring_constant() const;
  inline void clear_spring_constant();
  static const int kSpringConstantFieldNumber = 101;
  inline float spring_constant() const;
  inline void set_spring_constant(float value);

  // optional float velocity_window_size = 102;
  inline bool has_velocity_window_size() const;
  inline void clear_velocity_window_size();
  static const int kVelocityWindowSizeFieldNumber = 102;
  inline float velocity_window_size() const;
  inline void set_velocity_window_size(float value);

  // optional float motor_housing_thermal_resistance = 103;
  inline bool has_motor_housing_thermal_resistance() const;
  inline void clear_motor_housing_thermal_resistance();
  static const int kMotorHousingThermalResistanceFieldNumber = 103;
  inline float motor_housing_thermal_resistance() const;
  inline void set_motor_housing_thermal_resistance(float value);

  // repeated float inner_encoder_kalman_gains = 110 [packed = true];
  inline int inner_encoder_kalman_gains_size() const;
  inline void clear_inner_encoder_kalman_gains();
  static const int kInnerEncoderKalmanGainsFieldNumber = 110;
  inline float inner_encoder_kalman_gains(int index) const;
  inline void set_inner_encoder_kalman_gains(int index, float value);
  inline void add_inner_encoder_kalman_gains(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      inner_encoder_kalman_gains() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_inner_encoder_kalman_gains();

  // optional float inner_encoder_accel_damp = 111;
  inline bool has_inner_encoder_accel_damp() const;
  inline void clear_inner_encoder_accel_damp();
  static const int kInnerEncoderAccelDampFieldNumber = 111;
  inline float inner_encoder_accel_damp() const;
  inline void set_inner_encoder_accel_damp(float value);

  // repeated float outer_encoder_kalman_gains = 115 [packed = true];
  inline int outer_encoder_kalman_gains_size() const;
  inline void clear_outer_encoder_kalman_gains();
  static const int kOuterEncoderKalmanGainsFieldNumber = 115;
  inline float outer_encoder_kalman_gains(int index) const;
  inline void set_outer_encoder_kalman_gains(int index, float value);
  inline void add_outer_encoder_kalman_gains(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      outer_encoder_kalman_gains() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_outer_encoder_kalman_gains();

  // optional float outer_encoder_accel_damp = 116;
  inline bool has_outer_encoder_accel_damp() const;
  inline void clear_outer_encoder_accel_damp();
  static const int kOuterEncoderAccelDampFieldNumber = 116;
  inline float outer_encoder_accel_damp() const;
  inline void set_outer_encoder_accel_damp(float value);

  // @@protoc_insertion_point(class_scope:protos.ControlLoopParameters)
 private:
  inline void set_has_save();
  inline void clear_has_save();
  inline void set_has_cascaded_period();
  inline void clear_has_cascaded_period();
  inline void set_has_cascaded_position_pid_parameters();
  inline void clear_has_cascaded_position_pid_parameters();
  inline void set_has_cascaded_velocity_p_parameters();
  inline void clear_has_cascaded_velocity_p_parameters();
  inline void set_has_cascaded_torque_pid_parameters();
  inline void clear_has_cascaded_torque_pid_parameters();
  inline void set_has_cascaded_enabled();
  inline void clear_has_cascaded_enabled();
  inline void set_has_motor_current_limit();
  inline void clear_has_motor_current_limit();
  inline void set_has_spring_constant();
  inline void clear_has_spring_constant();
  inline void set_has_velocity_window_size();
  inline void clear_has_velocity_window_size();
  inline void set_has_motor_housing_thermal_resistance();
  inline void clear_has_motor_housing_thermal_resistance();
  inline void set_has_inner_encoder_accel_damp();
  inline void clear_has_inner_encoder_accel_damp();
  inline void set_has_outer_encoder_accel_damp();
  inline void clear_has_outer_encoder_accel_damp();

  ::protos::PidControllerParameters* cascaded_position_pid_parameters_;
  float cascaded_period_;
  bool save_;
  bool cascaded_enabled_;
  ::protos::PidControllerParameters* cascaded_velocity_p_parameters_;
  ::protos::PidControllerParameters* cascaded_torque_pid_parameters_;
  float motor_current_limit_;
  float spring_constant_;
  float velocity_window_size_;
  float motor_housing_thermal_resistance_;
  ::google::protobuf::RepeatedField< float > inner_encoder_kalman_gains_;
  mutable int _inner_encoder_kalman_gains_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > outer_encoder_kalman_gains_;
  mutable int _outer_encoder_kalman_gains_cached_byte_size_;
  float inner_encoder_accel_damp_;
  float outer_encoder_accel_damp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ModuleParameters_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ModuleParameters_2eproto();
  #endif
  friend void protobuf_AssignDesc_ModuleParameters_2eproto();
  friend void protobuf_ShutdownFile_ModuleParameters_2eproto();

  void InitAsDefaultInstance();
  static ControlLoopParameters* default_instance_;
};
// -------------------------------------------------------------------

class EthernetParameters : public ::google::protobuf::MessageLite {
 public:
  EthernetParameters();
  virtual ~EthernetParameters();

  EthernetParameters(const EthernetParameters& from);

  inline EthernetParameters& operator=(const EthernetParameters& from) {
    CopyFrom(from);
    return *this;
  }

  static const EthernetParameters& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EthernetParameters* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EthernetParameters* other);

  // implements Message ----------------------------------------------

  EthernetParameters* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EthernetParameters& from);
  void MergeFrom(const EthernetParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool save = 1;
  inline bool has_save() const;
  inline void clear_save();
  static const int kSaveFieldNumber = 1;
  inline bool save() const;
  inline void set_save(bool value);

  // optional bytes mac_address = 10;
  inline bool has_mac_address() const;
  inline void clear_mac_address();
  static const int kMacAddressFieldNumber = 10;
  inline const ::std::string& mac_address() const;
  inline void set_mac_address(const ::std::string& value);
  inline void set_mac_address(const char* value);
  inline void set_mac_address(const void* value, size_t size);
  inline ::std::string* mutable_mac_address();
  inline ::std::string* release_mac_address();
  inline void set_allocated_mac_address(::std::string* mac_address);

  // optional bytes address = 20;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 20;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const void* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional bytes netmask = 21;
  inline bool has_netmask() const;
  inline void clear_netmask();
  static const int kNetmaskFieldNumber = 21;
  inline const ::std::string& netmask() const;
  inline void set_netmask(const ::std::string& value);
  inline void set_netmask(const char* value);
  inline void set_netmask(const void* value, size_t size);
  inline ::std::string* mutable_netmask();
  inline ::std::string* release_netmask();
  inline void set_allocated_netmask(::std::string* netmask);

  // optional bytes gateway = 22;
  inline bool has_gateway() const;
  inline void clear_gateway();
  static const int kGatewayFieldNumber = 22;
  inline const ::std::string& gateway() const;
  inline void set_gateway(const ::std::string& value);
  inline void set_gateway(const char* value);
  inline void set_gateway(const void* value, size_t size);
  inline ::std::string* mutable_gateway();
  inline ::std::string* release_gateway();
  inline void set_allocated_gateway(::std::string* gateway);

  // optional bytes proximal_ip = 40;
  inline bool has_proximal_ip() const;
  inline void clear_proximal_ip();
  static const int kProximalIpFieldNumber = 40;
  inline const ::std::string& proximal_ip() const;
  inline void set_proximal_ip(const ::std::string& value);
  inline void set_proximal_ip(const char* value);
  inline void set_proximal_ip(const void* value, size_t size);
  inline ::std::string* mutable_proximal_ip();
  inline ::std::string* release_proximal_ip();
  inline void set_allocated_proximal_ip(::std::string* proximal_ip);

  // optional bytes distal_ip = 41;
  inline bool has_distal_ip() const;
  inline void clear_distal_ip();
  static const int kDistalIpFieldNumber = 41;
  inline const ::std::string& distal_ip() const;
  inline void set_distal_ip(const ::std::string& value);
  inline void set_distal_ip(const char* value);
  inline void set_distal_ip(const void* value, size_t size);
  inline ::std::string* mutable_distal_ip();
  inline ::std::string* release_distal_ip();
  inline void set_allocated_distal_ip(::std::string* distal_ip);

  // @@protoc_insertion_point(class_scope:protos.EthernetParameters)
 private:
  inline void set_has_save();
  inline void clear_has_save();
  inline void set_has_mac_address();
  inline void clear_has_mac_address();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_netmask();
  inline void clear_has_netmask();
  inline void set_has_gateway();
  inline void clear_has_gateway();
  inline void set_has_proximal_ip();
  inline void clear_has_proximal_ip();
  inline void set_has_distal_ip();
  inline void clear_has_distal_ip();

  ::std::string* mac_address_;
  ::std::string* address_;
  ::std::string* netmask_;
  ::std::string* gateway_;
  ::std::string* proximal_ip_;
  ::std::string* distal_ip_;
  bool save_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ModuleParameters_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ModuleParameters_2eproto();
  #endif
  friend void protobuf_AssignDesc_ModuleParameters_2eproto();
  friend void protobuf_ShutdownFile_ModuleParameters_2eproto();

  void InitAsDefaultInstance();
  static EthernetParameters* default_instance_;
};
// -------------------------------------------------------------------

class ImuParameters : public ::google::protobuf::MessageLite {
 public:
  ImuParameters();
  virtual ~ImuParameters();

  ImuParameters(const ImuParameters& from);

  inline ImuParameters& operator=(const ImuParameters& from) {
    CopyFrom(from);
    return *this;
  }

  static const ImuParameters& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ImuParameters* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ImuParameters* other);

  // implements Message ----------------------------------------------

  ImuParameters* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ImuParameters& from);
  void MergeFrom(const ImuParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ImuParameters_AccelScale AccelScale;
  static const AccelScale G_2 = ImuParameters_AccelScale_G_2;
  static const AccelScale G_4 = ImuParameters_AccelScale_G_4;
  static const AccelScale G_8 = ImuParameters_AccelScale_G_8;
  static const AccelScale G_16 = ImuParameters_AccelScale_G_16;
  static inline bool AccelScale_IsValid(int value) {
    return ImuParameters_AccelScale_IsValid(value);
  }
  static const AccelScale AccelScale_MIN =
    ImuParameters_AccelScale_AccelScale_MIN;
  static const AccelScale AccelScale_MAX =
    ImuParameters_AccelScale_AccelScale_MAX;
  static const int AccelScale_ARRAYSIZE =
    ImuParameters_AccelScale_AccelScale_ARRAYSIZE;

  typedef ImuParameters_AccelCutoff AccelCutoff;
  static const AccelCutoff Hz_260 = ImuParameters_AccelCutoff_Hz_260;
  static const AccelCutoff Hz_184 = ImuParameters_AccelCutoff_Hz_184;
  static const AccelCutoff Hz_94 = ImuParameters_AccelCutoff_Hz_94;
  static const AccelCutoff Hz_44 = ImuParameters_AccelCutoff_Hz_44;
  static const AccelCutoff Hz_21 = ImuParameters_AccelCutoff_Hz_21;
  static const AccelCutoff Hz_10 = ImuParameters_AccelCutoff_Hz_10;
  static const AccelCutoff Hz_5 = ImuParameters_AccelCutoff_Hz_5;
  static inline bool AccelCutoff_IsValid(int value) {
    return ImuParameters_AccelCutoff_IsValid(value);
  }
  static const AccelCutoff AccelCutoff_MIN =
    ImuParameters_AccelCutoff_AccelCutoff_MIN;
  static const AccelCutoff AccelCutoff_MAX =
    ImuParameters_AccelCutoff_AccelCutoff_MAX;
  static const int AccelCutoff_ARRAYSIZE =
    ImuParameters_AccelCutoff_AccelCutoff_ARRAYSIZE;

  typedef ImuParameters_GyroScale GyroScale;
  static const GyroScale DEG_PER_S_250 = ImuParameters_GyroScale_DEG_PER_S_250;
  static const GyroScale DEG_PER_S_500 = ImuParameters_GyroScale_DEG_PER_S_500;
  static const GyroScale DEG_PER_S_1000 = ImuParameters_GyroScale_DEG_PER_S_1000;
  static const GyroScale DEG_PER_S_2000 = ImuParameters_GyroScale_DEG_PER_S_2000;
  static inline bool GyroScale_IsValid(int value) {
    return ImuParameters_GyroScale_IsValid(value);
  }
  static const GyroScale GyroScale_MIN =
    ImuParameters_GyroScale_GyroScale_MIN;
  static const GyroScale GyroScale_MAX =
    ImuParameters_GyroScale_GyroScale_MAX;
  static const int GyroScale_ARRAYSIZE =
    ImuParameters_GyroScale_GyroScale_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional bool save = 1;
  inline bool has_save() const;
  inline void clear_save();
  static const int kSaveFieldNumber = 1;
  inline bool save() const;
  inline void set_save(bool value);

  // optional .protos.ImuParameters.AccelScale accel_scale = 10;
  inline bool has_accel_scale() const;
  inline void clear_accel_scale();
  static const int kAccelScaleFieldNumber = 10;
  inline ::protos::ImuParameters_AccelScale accel_scale() const;
  inline void set_accel_scale(::protos::ImuParameters_AccelScale value);

  // optional .protos.ImuParameters.AccelCutoff accel_cutoff = 11;
  inline bool has_accel_cutoff() const;
  inline void clear_accel_cutoff();
  static const int kAccelCutoffFieldNumber = 11;
  inline ::protos::ImuParameters_AccelCutoff accel_cutoff() const;
  inline void set_accel_cutoff(::protos::ImuParameters_AccelCutoff value);

  // optional .protos.ImuParameters.GyroScale gyro_scale = 20;
  inline bool has_gyro_scale() const;
  inline void clear_gyro_scale();
  static const int kGyroScaleFieldNumber = 20;
  inline ::protos::ImuParameters_GyroScale gyro_scale() const;
  inline void set_gyro_scale(::protos::ImuParameters_GyroScale value);

  // @@protoc_insertion_point(class_scope:protos.ImuParameters)
 private:
  inline void set_has_save();
  inline void clear_has_save();
  inline void set_has_accel_scale();
  inline void clear_has_accel_scale();
  inline void set_has_accel_cutoff();
  inline void clear_has_accel_cutoff();
  inline void set_has_gyro_scale();
  inline void clear_has_gyro_scale();

  bool save_;
  int accel_scale_;
  int accel_cutoff_;
  int gyro_scale_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ModuleParameters_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ModuleParameters_2eproto();
  #endif
  friend void protobuf_AssignDesc_ModuleParameters_2eproto();
  friend void protobuf_ShutdownFile_ModuleParameters_2eproto();

  void InitAsDefaultInstance();
  static ImuParameters* default_instance_;
};
// -------------------------------------------------------------------

class LedParameters : public ::google::protobuf::MessageLite {
 public:
  LedParameters();
  virtual ~LedParameters();

  LedParameters(const LedParameters& from);

  inline LedParameters& operator=(const LedParameters& from) {
    CopyFrom(from);
    return *this;
  }

  static const LedParameters& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LedParameters* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LedParameters* other);

  // implements Message ----------------------------------------------

  LedParameters* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LedParameters& from);
  void MergeFrom(const LedParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed32 RGBA = 10;
  inline bool has_rgba() const;
  inline void clear_rgba();
  static const int kRGBAFieldNumber = 10;
  inline ::google::protobuf::uint32 rgba() const;
  inline void set_rgba(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protos.LedParameters)
 private:
  inline void set_has_rgba();
  inline void clear_has_rgba();

  ::google::protobuf::uint32 rgba_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ModuleParameters_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ModuleParameters_2eproto();
  #endif
  friend void protobuf_AssignDesc_ModuleParameters_2eproto();
  friend void protobuf_ShutdownFile_ModuleParameters_2eproto();

  void InitAsDefaultInstance();
  static LedParameters* default_instance_;
};
// ===================================================================


// ===================================================================

// ParameterMessage

// optional .protos.ControlLoopParameters control_loop_parameters = 1;
inline bool ParameterMessage::has_control_loop_parameters() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParameterMessage::set_has_control_loop_parameters() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParameterMessage::clear_has_control_loop_parameters() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParameterMessage::clear_control_loop_parameters() {
  if (control_loop_parameters_ != NULL) control_loop_parameters_->::protos::ControlLoopParameters::Clear();
  clear_has_control_loop_parameters();
}
inline const ::protos::ControlLoopParameters& ParameterMessage::control_loop_parameters() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return control_loop_parameters_ != NULL ? *control_loop_parameters_ : *default_instance().control_loop_parameters_;
#else
  return control_loop_parameters_ != NULL ? *control_loop_parameters_ : *default_instance_->control_loop_parameters_;
#endif
}
inline ::protos::ControlLoopParameters* ParameterMessage::mutable_control_loop_parameters() {
  set_has_control_loop_parameters();
  if (control_loop_parameters_ == NULL) control_loop_parameters_ = new ::protos::ControlLoopParameters;
  return control_loop_parameters_;
}
inline ::protos::ControlLoopParameters* ParameterMessage::release_control_loop_parameters() {
  clear_has_control_loop_parameters();
  ::protos::ControlLoopParameters* temp = control_loop_parameters_;
  control_loop_parameters_ = NULL;
  return temp;
}
inline void ParameterMessage::set_allocated_control_loop_parameters(::protos::ControlLoopParameters* control_loop_parameters) {
  delete control_loop_parameters_;
  control_loop_parameters_ = control_loop_parameters;
  if (control_loop_parameters) {
    set_has_control_loop_parameters();
  } else {
    clear_has_control_loop_parameters();
  }
}

// optional .protos.EthernetParameters ethernet_parameters = 2;
inline bool ParameterMessage::has_ethernet_parameters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParameterMessage::set_has_ethernet_parameters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParameterMessage::clear_has_ethernet_parameters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParameterMessage::clear_ethernet_parameters() {
  if (ethernet_parameters_ != NULL) ethernet_parameters_->::protos::EthernetParameters::Clear();
  clear_has_ethernet_parameters();
}
inline const ::protos::EthernetParameters& ParameterMessage::ethernet_parameters() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ethernet_parameters_ != NULL ? *ethernet_parameters_ : *default_instance().ethernet_parameters_;
#else
  return ethernet_parameters_ != NULL ? *ethernet_parameters_ : *default_instance_->ethernet_parameters_;
#endif
}
inline ::protos::EthernetParameters* ParameterMessage::mutable_ethernet_parameters() {
  set_has_ethernet_parameters();
  if (ethernet_parameters_ == NULL) ethernet_parameters_ = new ::protos::EthernetParameters;
  return ethernet_parameters_;
}
inline ::protos::EthernetParameters* ParameterMessage::release_ethernet_parameters() {
  clear_has_ethernet_parameters();
  ::protos::EthernetParameters* temp = ethernet_parameters_;
  ethernet_parameters_ = NULL;
  return temp;
}
inline void ParameterMessage::set_allocated_ethernet_parameters(::protos::EthernetParameters* ethernet_parameters) {
  delete ethernet_parameters_;
  ethernet_parameters_ = ethernet_parameters;
  if (ethernet_parameters) {
    set_has_ethernet_parameters();
  } else {
    clear_has_ethernet_parameters();
  }
}

// optional .protos.ImuParameters imu_parameters = 3;
inline bool ParameterMessage::has_imu_parameters() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParameterMessage::set_has_imu_parameters() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParameterMessage::clear_has_imu_parameters() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParameterMessage::clear_imu_parameters() {
  if (imu_parameters_ != NULL) imu_parameters_->::protos::ImuParameters::Clear();
  clear_has_imu_parameters();
}
inline const ::protos::ImuParameters& ParameterMessage::imu_parameters() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return imu_parameters_ != NULL ? *imu_parameters_ : *default_instance().imu_parameters_;
#else
  return imu_parameters_ != NULL ? *imu_parameters_ : *default_instance_->imu_parameters_;
#endif
}
inline ::protos::ImuParameters* ParameterMessage::mutable_imu_parameters() {
  set_has_imu_parameters();
  if (imu_parameters_ == NULL) imu_parameters_ = new ::protos::ImuParameters;
  return imu_parameters_;
}
inline ::protos::ImuParameters* ParameterMessage::release_imu_parameters() {
  clear_has_imu_parameters();
  ::protos::ImuParameters* temp = imu_parameters_;
  imu_parameters_ = NULL;
  return temp;
}
inline void ParameterMessage::set_allocated_imu_parameters(::protos::ImuParameters* imu_parameters) {
  delete imu_parameters_;
  imu_parameters_ = imu_parameters;
  if (imu_parameters) {
    set_has_imu_parameters();
  } else {
    clear_has_imu_parameters();
  }
}

// optional .protos.LedParameters led_parameters = 4;
inline bool ParameterMessage::has_led_parameters() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ParameterMessage::set_has_led_parameters() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ParameterMessage::clear_has_led_parameters() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ParameterMessage::clear_led_parameters() {
  if (led_parameters_ != NULL) led_parameters_->::protos::LedParameters::Clear();
  clear_has_led_parameters();
}
inline const ::protos::LedParameters& ParameterMessage::led_parameters() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return led_parameters_ != NULL ? *led_parameters_ : *default_instance().led_parameters_;
#else
  return led_parameters_ != NULL ? *led_parameters_ : *default_instance_->led_parameters_;
#endif
}
inline ::protos::LedParameters* ParameterMessage::mutable_led_parameters() {
  set_has_led_parameters();
  if (led_parameters_ == NULL) led_parameters_ = new ::protos::LedParameters;
  return led_parameters_;
}
inline ::protos::LedParameters* ParameterMessage::release_led_parameters() {
  clear_has_led_parameters();
  ::protos::LedParameters* temp = led_parameters_;
  led_parameters_ = NULL;
  return temp;
}
inline void ParameterMessage::set_allocated_led_parameters(::protos::LedParameters* led_parameters) {
  delete led_parameters_;
  led_parameters_ = led_parameters;
  if (led_parameters) {
    set_has_led_parameters();
  } else {
    clear_has_led_parameters();
  }
}

// -------------------------------------------------------------------

// PidControllerParameters

// optional float kp = 1;
inline bool PidControllerParameters::has_kp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PidControllerParameters::set_has_kp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PidControllerParameters::clear_has_kp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PidControllerParameters::clear_kp() {
  kp_ = 0;
  clear_has_kp();
}
inline float PidControllerParameters::kp() const {
  return kp_;
}
inline void PidControllerParameters::set_kp(float value) {
  set_has_kp();
  kp_ = value;
}

// optional float ki = 2;
inline bool PidControllerParameters::has_ki() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PidControllerParameters::set_has_ki() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PidControllerParameters::clear_has_ki() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PidControllerParameters::clear_ki() {
  ki_ = 0;
  clear_has_ki();
}
inline float PidControllerParameters::ki() const {
  return ki_;
}
inline void PidControllerParameters::set_ki(float value) {
  set_has_ki();
  ki_ = value;
}

// optional float kd = 3;
inline bool PidControllerParameters::has_kd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PidControllerParameters::set_has_kd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PidControllerParameters::clear_has_kd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PidControllerParameters::clear_kd() {
  kd_ = 0;
  clear_has_kd();
}
inline float PidControllerParameters::kd() const {
  return kd_;
}
inline void PidControllerParameters::set_kd(float value) {
  set_has_kd();
  kd_ = value;
}

// optional float ff = 4;
inline bool PidControllerParameters::has_ff() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PidControllerParameters::set_has_ff() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PidControllerParameters::clear_has_ff() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PidControllerParameters::clear_ff() {
  ff_ = 0;
  clear_has_ff();
}
inline float PidControllerParameters::ff() const {
  return ff_;
}
inline void PidControllerParameters::set_ff(float value) {
  set_has_ff();
  ff_ = value;
}

// optional float dead_zone = 5;
inline bool PidControllerParameters::has_dead_zone() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PidControllerParameters::set_has_dead_zone() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PidControllerParameters::clear_has_dead_zone() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PidControllerParameters::clear_dead_zone() {
  dead_zone_ = 0;
  clear_has_dead_zone();
}
inline float PidControllerParameters::dead_zone() const {
  return dead_zone_;
}
inline void PidControllerParameters::set_dead_zone(float value) {
  set_has_dead_zone();
  dead_zone_ = value;
}

// optional float i_clamp = 6;
inline bool PidControllerParameters::has_i_clamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PidControllerParameters::set_has_i_clamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PidControllerParameters::clear_has_i_clamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PidControllerParameters::clear_i_clamp() {
  i_clamp_ = 0;
  clear_has_i_clamp();
}
inline float PidControllerParameters::i_clamp() const {
  return i_clamp_;
}
inline void PidControllerParameters::set_i_clamp(float value) {
  set_has_i_clamp();
  i_clamp_ = value;
}

// optional bool enabled = 7;
inline bool PidControllerParameters::has_enabled() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PidControllerParameters::set_has_enabled() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PidControllerParameters::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PidControllerParameters::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool PidControllerParameters::enabled() const {
  return enabled_;
}
inline void PidControllerParameters::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// optional float punch = 8;
inline bool PidControllerParameters::has_punch() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PidControllerParameters::set_has_punch() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PidControllerParameters::clear_has_punch() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PidControllerParameters::clear_punch() {
  punch_ = 0;
  clear_has_punch();
}
inline float PidControllerParameters::punch() const {
  return punch_;
}
inline void PidControllerParameters::set_punch(float value) {
  set_has_punch();
  punch_ = value;
}

// optional float d_window_Size = 9;
inline bool PidControllerParameters::has_d_window_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PidControllerParameters::set_has_d_window_size() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PidControllerParameters::clear_has_d_window_size() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PidControllerParameters::clear_d_window_size() {
  d_window_size_ = 0;
  clear_has_d_window_size();
}
inline float PidControllerParameters::d_window_size() const {
  return d_window_size_;
}
inline void PidControllerParameters::set_d_window_size(float value) {
  set_has_d_window_size();
  d_window_size_ = value;
}

// optional float max_target_value = 10;
inline bool PidControllerParameters::has_max_target_value() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PidControllerParameters::set_has_max_target_value() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PidControllerParameters::clear_has_max_target_value() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PidControllerParameters::clear_max_target_value() {
  max_target_value_ = 0;
  clear_has_max_target_value();
}
inline float PidControllerParameters::max_target_value() const {
  return max_target_value_;
}
inline void PidControllerParameters::set_max_target_value(float value) {
  set_has_max_target_value();
  max_target_value_ = value;
}

// optional float max_output_value = 11;
inline bool PidControllerParameters::has_max_output_value() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PidControllerParameters::set_has_max_output_value() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PidControllerParameters::clear_has_max_output_value() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PidControllerParameters::clear_max_output_value() {
  max_output_value_ = 0;
  clear_has_max_output_value();
}
inline float PidControllerParameters::max_output_value() const {
  return max_output_value_;
}
inline void PidControllerParameters::set_max_output_value(float value) {
  set_has_max_output_value();
  max_output_value_ = value;
}

// optional float target_lowpass_gain = 12;
inline bool PidControllerParameters::has_target_lowpass_gain() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PidControllerParameters::set_has_target_lowpass_gain() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PidControllerParameters::clear_has_target_lowpass_gain() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PidControllerParameters::clear_target_lowpass_gain() {
  target_lowpass_gain_ = 0;
  clear_has_target_lowpass_gain();
}
inline float PidControllerParameters::target_lowpass_gain() const {
  return target_lowpass_gain_;
}
inline void PidControllerParameters::set_target_lowpass_gain(float value) {
  set_has_target_lowpass_gain();
  target_lowpass_gain_ = value;
}

// optional float output_lowpass_gain = 13;
inline bool PidControllerParameters::has_output_lowpass_gain() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PidControllerParameters::set_has_output_lowpass_gain() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PidControllerParameters::clear_has_output_lowpass_gain() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PidControllerParameters::clear_output_lowpass_gain() {
  output_lowpass_gain_ = 0;
  clear_has_output_lowpass_gain();
}
inline float PidControllerParameters::output_lowpass_gain() const {
  return output_lowpass_gain_;
}
inline void PidControllerParameters::set_output_lowpass_gain(float value) {
  set_has_output_lowpass_gain();
  output_lowpass_gain_ = value;
}

// optional bool d_on_error = 14;
inline bool PidControllerParameters::has_d_on_error() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PidControllerParameters::set_has_d_on_error() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PidControllerParameters::clear_has_d_on_error() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PidControllerParameters::clear_d_on_error() {
  d_on_error_ = false;
  clear_has_d_on_error();
}
inline bool PidControllerParameters::d_on_error() const {
  return d_on_error_;
}
inline void PidControllerParameters::set_d_on_error(bool value) {
  set_has_d_on_error();
  d_on_error_ = value;
}

// -------------------------------------------------------------------

// ControlLoopParameters

// optional bool save = 1;
inline bool ControlLoopParameters::has_save() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControlLoopParameters::set_has_save() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControlLoopParameters::clear_has_save() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControlLoopParameters::clear_save() {
  save_ = false;
  clear_has_save();
}
inline bool ControlLoopParameters::save() const {
  return save_;
}
inline void ControlLoopParameters::set_save(bool value) {
  set_has_save();
  save_ = value;
}

// optional float cascaded_period = 5;
inline bool ControlLoopParameters::has_cascaded_period() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControlLoopParameters::set_has_cascaded_period() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ControlLoopParameters::clear_has_cascaded_period() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ControlLoopParameters::clear_cascaded_period() {
  cascaded_period_ = 0;
  clear_has_cascaded_period();
}
inline float ControlLoopParameters::cascaded_period() const {
  return cascaded_period_;
}
inline void ControlLoopParameters::set_cascaded_period(float value) {
  set_has_cascaded_period();
  cascaded_period_ = value;
}

// optional .protos.PidControllerParameters cascaded_position_pid_parameters = 6;
inline bool ControlLoopParameters::has_cascaded_position_pid_parameters() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ControlLoopParameters::set_has_cascaded_position_pid_parameters() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ControlLoopParameters::clear_has_cascaded_position_pid_parameters() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ControlLoopParameters::clear_cascaded_position_pid_parameters() {
  if (cascaded_position_pid_parameters_ != NULL) cascaded_position_pid_parameters_->::protos::PidControllerParameters::Clear();
  clear_has_cascaded_position_pid_parameters();
}
inline const ::protos::PidControllerParameters& ControlLoopParameters::cascaded_position_pid_parameters() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cascaded_position_pid_parameters_ != NULL ? *cascaded_position_pid_parameters_ : *default_instance().cascaded_position_pid_parameters_;
#else
  return cascaded_position_pid_parameters_ != NULL ? *cascaded_position_pid_parameters_ : *default_instance_->cascaded_position_pid_parameters_;
#endif
}
inline ::protos::PidControllerParameters* ControlLoopParameters::mutable_cascaded_position_pid_parameters() {
  set_has_cascaded_position_pid_parameters();
  if (cascaded_position_pid_parameters_ == NULL) cascaded_position_pid_parameters_ = new ::protos::PidControllerParameters;
  return cascaded_position_pid_parameters_;
}
inline ::protos::PidControllerParameters* ControlLoopParameters::release_cascaded_position_pid_parameters() {
  clear_has_cascaded_position_pid_parameters();
  ::protos::PidControllerParameters* temp = cascaded_position_pid_parameters_;
  cascaded_position_pid_parameters_ = NULL;
  return temp;
}
inline void ControlLoopParameters::set_allocated_cascaded_position_pid_parameters(::protos::PidControllerParameters* cascaded_position_pid_parameters) {
  delete cascaded_position_pid_parameters_;
  cascaded_position_pid_parameters_ = cascaded_position_pid_parameters;
  if (cascaded_position_pid_parameters) {
    set_has_cascaded_position_pid_parameters();
  } else {
    clear_has_cascaded_position_pid_parameters();
  }
}

// optional .protos.PidControllerParameters cascaded_velocity_p_parameters = 7;
inline bool ControlLoopParameters::has_cascaded_velocity_p_parameters() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ControlLoopParameters::set_has_cascaded_velocity_p_parameters() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ControlLoopParameters::clear_has_cascaded_velocity_p_parameters() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ControlLoopParameters::clear_cascaded_velocity_p_parameters() {
  if (cascaded_velocity_p_parameters_ != NULL) cascaded_velocity_p_parameters_->::protos::PidControllerParameters::Clear();
  clear_has_cascaded_velocity_p_parameters();
}
inline const ::protos::PidControllerParameters& ControlLoopParameters::cascaded_velocity_p_parameters() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cascaded_velocity_p_parameters_ != NULL ? *cascaded_velocity_p_parameters_ : *default_instance().cascaded_velocity_p_parameters_;
#else
  return cascaded_velocity_p_parameters_ != NULL ? *cascaded_velocity_p_parameters_ : *default_instance_->cascaded_velocity_p_parameters_;
#endif
}
inline ::protos::PidControllerParameters* ControlLoopParameters::mutable_cascaded_velocity_p_parameters() {
  set_has_cascaded_velocity_p_parameters();
  if (cascaded_velocity_p_parameters_ == NULL) cascaded_velocity_p_parameters_ = new ::protos::PidControllerParameters;
  return cascaded_velocity_p_parameters_;
}
inline ::protos::PidControllerParameters* ControlLoopParameters::release_cascaded_velocity_p_parameters() {
  clear_has_cascaded_velocity_p_parameters();
  ::protos::PidControllerParameters* temp = cascaded_velocity_p_parameters_;
  cascaded_velocity_p_parameters_ = NULL;
  return temp;
}
inline void ControlLoopParameters::set_allocated_cascaded_velocity_p_parameters(::protos::PidControllerParameters* cascaded_velocity_p_parameters) {
  delete cascaded_velocity_p_parameters_;
  cascaded_velocity_p_parameters_ = cascaded_velocity_p_parameters;
  if (cascaded_velocity_p_parameters) {
    set_has_cascaded_velocity_p_parameters();
  } else {
    clear_has_cascaded_velocity_p_parameters();
  }
}

// optional .protos.PidControllerParameters cascaded_torque_pid_parameters = 8;
inline bool ControlLoopParameters::has_cascaded_torque_pid_parameters() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ControlLoopParameters::set_has_cascaded_torque_pid_parameters() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ControlLoopParameters::clear_has_cascaded_torque_pid_parameters() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ControlLoopParameters::clear_cascaded_torque_pid_parameters() {
  if (cascaded_torque_pid_parameters_ != NULL) cascaded_torque_pid_parameters_->::protos::PidControllerParameters::Clear();
  clear_has_cascaded_torque_pid_parameters();
}
inline const ::protos::PidControllerParameters& ControlLoopParameters::cascaded_torque_pid_parameters() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cascaded_torque_pid_parameters_ != NULL ? *cascaded_torque_pid_parameters_ : *default_instance().cascaded_torque_pid_parameters_;
#else
  return cascaded_torque_pid_parameters_ != NULL ? *cascaded_torque_pid_parameters_ : *default_instance_->cascaded_torque_pid_parameters_;
#endif
}
inline ::protos::PidControllerParameters* ControlLoopParameters::mutable_cascaded_torque_pid_parameters() {
  set_has_cascaded_torque_pid_parameters();
  if (cascaded_torque_pid_parameters_ == NULL) cascaded_torque_pid_parameters_ = new ::protos::PidControllerParameters;
  return cascaded_torque_pid_parameters_;
}
inline ::protos::PidControllerParameters* ControlLoopParameters::release_cascaded_torque_pid_parameters() {
  clear_has_cascaded_torque_pid_parameters();
  ::protos::PidControllerParameters* temp = cascaded_torque_pid_parameters_;
  cascaded_torque_pid_parameters_ = NULL;
  return temp;
}
inline void ControlLoopParameters::set_allocated_cascaded_torque_pid_parameters(::protos::PidControllerParameters* cascaded_torque_pid_parameters) {
  delete cascaded_torque_pid_parameters_;
  cascaded_torque_pid_parameters_ = cascaded_torque_pid_parameters;
  if (cascaded_torque_pid_parameters) {
    set_has_cascaded_torque_pid_parameters();
  } else {
    clear_has_cascaded_torque_pid_parameters();
  }
}

// optional bool cascaded_enabled = 9;
inline bool ControlLoopParameters::has_cascaded_enabled() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ControlLoopParameters::set_has_cascaded_enabled() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ControlLoopParameters::clear_has_cascaded_enabled() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ControlLoopParameters::clear_cascaded_enabled() {
  cascaded_enabled_ = false;
  clear_has_cascaded_enabled();
}
inline bool ControlLoopParameters::cascaded_enabled() const {
  return cascaded_enabled_;
}
inline void ControlLoopParameters::set_cascaded_enabled(bool value) {
  set_has_cascaded_enabled();
  cascaded_enabled_ = value;
}

// optional float motor_current_limit = 100;
inline bool ControlLoopParameters::has_motor_current_limit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ControlLoopParameters::set_has_motor_current_limit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ControlLoopParameters::clear_has_motor_current_limit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ControlLoopParameters::clear_motor_current_limit() {
  motor_current_limit_ = 0;
  clear_has_motor_current_limit();
}
inline float ControlLoopParameters::motor_current_limit() const {
  return motor_current_limit_;
}
inline void ControlLoopParameters::set_motor_current_limit(float value) {
  set_has_motor_current_limit();
  motor_current_limit_ = value;
}

// optional float spring_constant = 101;
inline bool ControlLoopParameters::has_spring_constant() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ControlLoopParameters::set_has_spring_constant() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ControlLoopParameters::clear_has_spring_constant() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ControlLoopParameters::clear_spring_constant() {
  spring_constant_ = 0;
  clear_has_spring_constant();
}
inline float ControlLoopParameters::spring_constant() const {
  return spring_constant_;
}
inline void ControlLoopParameters::set_spring_constant(float value) {
  set_has_spring_constant();
  spring_constant_ = value;
}

// optional float velocity_window_size = 102;
inline bool ControlLoopParameters::has_velocity_window_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ControlLoopParameters::set_has_velocity_window_size() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ControlLoopParameters::clear_has_velocity_window_size() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ControlLoopParameters::clear_velocity_window_size() {
  velocity_window_size_ = 0;
  clear_has_velocity_window_size();
}
inline float ControlLoopParameters::velocity_window_size() const {
  return velocity_window_size_;
}
inline void ControlLoopParameters::set_velocity_window_size(float value) {
  set_has_velocity_window_size();
  velocity_window_size_ = value;
}

// optional float motor_housing_thermal_resistance = 103;
inline bool ControlLoopParameters::has_motor_housing_thermal_resistance() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ControlLoopParameters::set_has_motor_housing_thermal_resistance() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ControlLoopParameters::clear_has_motor_housing_thermal_resistance() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ControlLoopParameters::clear_motor_housing_thermal_resistance() {
  motor_housing_thermal_resistance_ = 0;
  clear_has_motor_housing_thermal_resistance();
}
inline float ControlLoopParameters::motor_housing_thermal_resistance() const {
  return motor_housing_thermal_resistance_;
}
inline void ControlLoopParameters::set_motor_housing_thermal_resistance(float value) {
  set_has_motor_housing_thermal_resistance();
  motor_housing_thermal_resistance_ = value;
}

// repeated float inner_encoder_kalman_gains = 110 [packed = true];
inline int ControlLoopParameters::inner_encoder_kalman_gains_size() const {
  return inner_encoder_kalman_gains_.size();
}
inline void ControlLoopParameters::clear_inner_encoder_kalman_gains() {
  inner_encoder_kalman_gains_.Clear();
}
inline float ControlLoopParameters::inner_encoder_kalman_gains(int index) const {
  return inner_encoder_kalman_gains_.Get(index);
}
inline void ControlLoopParameters::set_inner_encoder_kalman_gains(int index, float value) {
  inner_encoder_kalman_gains_.Set(index, value);
}
inline void ControlLoopParameters::add_inner_encoder_kalman_gains(float value) {
  inner_encoder_kalman_gains_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ControlLoopParameters::inner_encoder_kalman_gains() const {
  return inner_encoder_kalman_gains_;
}
inline ::google::protobuf::RepeatedField< float >*
ControlLoopParameters::mutable_inner_encoder_kalman_gains() {
  return &inner_encoder_kalman_gains_;
}

// optional float inner_encoder_accel_damp = 111;
inline bool ControlLoopParameters::has_inner_encoder_accel_damp() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ControlLoopParameters::set_has_inner_encoder_accel_damp() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ControlLoopParameters::clear_has_inner_encoder_accel_damp() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ControlLoopParameters::clear_inner_encoder_accel_damp() {
  inner_encoder_accel_damp_ = 0;
  clear_has_inner_encoder_accel_damp();
}
inline float ControlLoopParameters::inner_encoder_accel_damp() const {
  return inner_encoder_accel_damp_;
}
inline void ControlLoopParameters::set_inner_encoder_accel_damp(float value) {
  set_has_inner_encoder_accel_damp();
  inner_encoder_accel_damp_ = value;
}

// repeated float outer_encoder_kalman_gains = 115 [packed = true];
inline int ControlLoopParameters::outer_encoder_kalman_gains_size() const {
  return outer_encoder_kalman_gains_.size();
}
inline void ControlLoopParameters::clear_outer_encoder_kalman_gains() {
  outer_encoder_kalman_gains_.Clear();
}
inline float ControlLoopParameters::outer_encoder_kalman_gains(int index) const {
  return outer_encoder_kalman_gains_.Get(index);
}
inline void ControlLoopParameters::set_outer_encoder_kalman_gains(int index, float value) {
  outer_encoder_kalman_gains_.Set(index, value);
}
inline void ControlLoopParameters::add_outer_encoder_kalman_gains(float value) {
  outer_encoder_kalman_gains_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ControlLoopParameters::outer_encoder_kalman_gains() const {
  return outer_encoder_kalman_gains_;
}
inline ::google::protobuf::RepeatedField< float >*
ControlLoopParameters::mutable_outer_encoder_kalman_gains() {
  return &outer_encoder_kalman_gains_;
}

// optional float outer_encoder_accel_damp = 116;
inline bool ControlLoopParameters::has_outer_encoder_accel_damp() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ControlLoopParameters::set_has_outer_encoder_accel_damp() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ControlLoopParameters::clear_has_outer_encoder_accel_damp() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ControlLoopParameters::clear_outer_encoder_accel_damp() {
  outer_encoder_accel_damp_ = 0;
  clear_has_outer_encoder_accel_damp();
}
inline float ControlLoopParameters::outer_encoder_accel_damp() const {
  return outer_encoder_accel_damp_;
}
inline void ControlLoopParameters::set_outer_encoder_accel_damp(float value) {
  set_has_outer_encoder_accel_damp();
  outer_encoder_accel_damp_ = value;
}

// -------------------------------------------------------------------

// EthernetParameters

// optional bool save = 1;
inline bool EthernetParameters::has_save() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EthernetParameters::set_has_save() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EthernetParameters::clear_has_save() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EthernetParameters::clear_save() {
  save_ = false;
  clear_has_save();
}
inline bool EthernetParameters::save() const {
  return save_;
}
inline void EthernetParameters::set_save(bool value) {
  set_has_save();
  save_ = value;
}

// optional bytes mac_address = 10;
inline bool EthernetParameters::has_mac_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EthernetParameters::set_has_mac_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EthernetParameters::clear_has_mac_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EthernetParameters::clear_mac_address() {
  if (mac_address_ != &::google::protobuf::internal::kEmptyString) {
    mac_address_->clear();
  }
  clear_has_mac_address();
}
inline const ::std::string& EthernetParameters::mac_address() const {
  return *mac_address_;
}
inline void EthernetParameters::set_mac_address(const ::std::string& value) {
  set_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    mac_address_ = new ::std::string;
  }
  mac_address_->assign(value);
}
inline void EthernetParameters::set_mac_address(const char* value) {
  set_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    mac_address_ = new ::std::string;
  }
  mac_address_->assign(value);
}
inline void EthernetParameters::set_mac_address(const void* value, size_t size) {
  set_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    mac_address_ = new ::std::string;
  }
  mac_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EthernetParameters::mutable_mac_address() {
  set_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    mac_address_ = new ::std::string;
  }
  return mac_address_;
}
inline ::std::string* EthernetParameters::release_mac_address() {
  clear_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mac_address_;
    mac_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EthernetParameters::set_allocated_mac_address(::std::string* mac_address) {
  if (mac_address_ != &::google::protobuf::internal::kEmptyString) {
    delete mac_address_;
  }
  if (mac_address) {
    set_has_mac_address();
    mac_address_ = mac_address;
  } else {
    clear_has_mac_address();
    mac_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes address = 20;
inline bool EthernetParameters::has_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EthernetParameters::set_has_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EthernetParameters::clear_has_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EthernetParameters::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& EthernetParameters::address() const {
  return *address_;
}
inline void EthernetParameters::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void EthernetParameters::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void EthernetParameters::set_address(const void* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EthernetParameters::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* EthernetParameters::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EthernetParameters::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes netmask = 21;
inline bool EthernetParameters::has_netmask() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EthernetParameters::set_has_netmask() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EthernetParameters::clear_has_netmask() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EthernetParameters::clear_netmask() {
  if (netmask_ != &::google::protobuf::internal::kEmptyString) {
    netmask_->clear();
  }
  clear_has_netmask();
}
inline const ::std::string& EthernetParameters::netmask() const {
  return *netmask_;
}
inline void EthernetParameters::set_netmask(const ::std::string& value) {
  set_has_netmask();
  if (netmask_ == &::google::protobuf::internal::kEmptyString) {
    netmask_ = new ::std::string;
  }
  netmask_->assign(value);
}
inline void EthernetParameters::set_netmask(const char* value) {
  set_has_netmask();
  if (netmask_ == &::google::protobuf::internal::kEmptyString) {
    netmask_ = new ::std::string;
  }
  netmask_->assign(value);
}
inline void EthernetParameters::set_netmask(const void* value, size_t size) {
  set_has_netmask();
  if (netmask_ == &::google::protobuf::internal::kEmptyString) {
    netmask_ = new ::std::string;
  }
  netmask_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EthernetParameters::mutable_netmask() {
  set_has_netmask();
  if (netmask_ == &::google::protobuf::internal::kEmptyString) {
    netmask_ = new ::std::string;
  }
  return netmask_;
}
inline ::std::string* EthernetParameters::release_netmask() {
  clear_has_netmask();
  if (netmask_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = netmask_;
    netmask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EthernetParameters::set_allocated_netmask(::std::string* netmask) {
  if (netmask_ != &::google::protobuf::internal::kEmptyString) {
    delete netmask_;
  }
  if (netmask) {
    set_has_netmask();
    netmask_ = netmask;
  } else {
    clear_has_netmask();
    netmask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gateway = 22;
inline bool EthernetParameters::has_gateway() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EthernetParameters::set_has_gateway() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EthernetParameters::clear_has_gateway() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EthernetParameters::clear_gateway() {
  if (gateway_ != &::google::protobuf::internal::kEmptyString) {
    gateway_->clear();
  }
  clear_has_gateway();
}
inline const ::std::string& EthernetParameters::gateway() const {
  return *gateway_;
}
inline void EthernetParameters::set_gateway(const ::std::string& value) {
  set_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    gateway_ = new ::std::string;
  }
  gateway_->assign(value);
}
inline void EthernetParameters::set_gateway(const char* value) {
  set_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    gateway_ = new ::std::string;
  }
  gateway_->assign(value);
}
inline void EthernetParameters::set_gateway(const void* value, size_t size) {
  set_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    gateway_ = new ::std::string;
  }
  gateway_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EthernetParameters::mutable_gateway() {
  set_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    gateway_ = new ::std::string;
  }
  return gateway_;
}
inline ::std::string* EthernetParameters::release_gateway() {
  clear_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gateway_;
    gateway_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EthernetParameters::set_allocated_gateway(::std::string* gateway) {
  if (gateway_ != &::google::protobuf::internal::kEmptyString) {
    delete gateway_;
  }
  if (gateway) {
    set_has_gateway();
    gateway_ = gateway;
  } else {
    clear_has_gateway();
    gateway_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes proximal_ip = 40;
inline bool EthernetParameters::has_proximal_ip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EthernetParameters::set_has_proximal_ip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EthernetParameters::clear_has_proximal_ip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EthernetParameters::clear_proximal_ip() {
  if (proximal_ip_ != &::google::protobuf::internal::kEmptyString) {
    proximal_ip_->clear();
  }
  clear_has_proximal_ip();
}
inline const ::std::string& EthernetParameters::proximal_ip() const {
  return *proximal_ip_;
}
inline void EthernetParameters::set_proximal_ip(const ::std::string& value) {
  set_has_proximal_ip();
  if (proximal_ip_ == &::google::protobuf::internal::kEmptyString) {
    proximal_ip_ = new ::std::string;
  }
  proximal_ip_->assign(value);
}
inline void EthernetParameters::set_proximal_ip(const char* value) {
  set_has_proximal_ip();
  if (proximal_ip_ == &::google::protobuf::internal::kEmptyString) {
    proximal_ip_ = new ::std::string;
  }
  proximal_ip_->assign(value);
}
inline void EthernetParameters::set_proximal_ip(const void* value, size_t size) {
  set_has_proximal_ip();
  if (proximal_ip_ == &::google::protobuf::internal::kEmptyString) {
    proximal_ip_ = new ::std::string;
  }
  proximal_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EthernetParameters::mutable_proximal_ip() {
  set_has_proximal_ip();
  if (proximal_ip_ == &::google::protobuf::internal::kEmptyString) {
    proximal_ip_ = new ::std::string;
  }
  return proximal_ip_;
}
inline ::std::string* EthernetParameters::release_proximal_ip() {
  clear_has_proximal_ip();
  if (proximal_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proximal_ip_;
    proximal_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EthernetParameters::set_allocated_proximal_ip(::std::string* proximal_ip) {
  if (proximal_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete proximal_ip_;
  }
  if (proximal_ip) {
    set_has_proximal_ip();
    proximal_ip_ = proximal_ip;
  } else {
    clear_has_proximal_ip();
    proximal_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes distal_ip = 41;
inline bool EthernetParameters::has_distal_ip() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EthernetParameters::set_has_distal_ip() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EthernetParameters::clear_has_distal_ip() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EthernetParameters::clear_distal_ip() {
  if (distal_ip_ != &::google::protobuf::internal::kEmptyString) {
    distal_ip_->clear();
  }
  clear_has_distal_ip();
}
inline const ::std::string& EthernetParameters::distal_ip() const {
  return *distal_ip_;
}
inline void EthernetParameters::set_distal_ip(const ::std::string& value) {
  set_has_distal_ip();
  if (distal_ip_ == &::google::protobuf::internal::kEmptyString) {
    distal_ip_ = new ::std::string;
  }
  distal_ip_->assign(value);
}
inline void EthernetParameters::set_distal_ip(const char* value) {
  set_has_distal_ip();
  if (distal_ip_ == &::google::protobuf::internal::kEmptyString) {
    distal_ip_ = new ::std::string;
  }
  distal_ip_->assign(value);
}
inline void EthernetParameters::set_distal_ip(const void* value, size_t size) {
  set_has_distal_ip();
  if (distal_ip_ == &::google::protobuf::internal::kEmptyString) {
    distal_ip_ = new ::std::string;
  }
  distal_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EthernetParameters::mutable_distal_ip() {
  set_has_distal_ip();
  if (distal_ip_ == &::google::protobuf::internal::kEmptyString) {
    distal_ip_ = new ::std::string;
  }
  return distal_ip_;
}
inline ::std::string* EthernetParameters::release_distal_ip() {
  clear_has_distal_ip();
  if (distal_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = distal_ip_;
    distal_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EthernetParameters::set_allocated_distal_ip(::std::string* distal_ip) {
  if (distal_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete distal_ip_;
  }
  if (distal_ip) {
    set_has_distal_ip();
    distal_ip_ = distal_ip;
  } else {
    clear_has_distal_ip();
    distal_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ImuParameters

// optional bool save = 1;
inline bool ImuParameters::has_save() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImuParameters::set_has_save() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImuParameters::clear_has_save() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImuParameters::clear_save() {
  save_ = false;
  clear_has_save();
}
inline bool ImuParameters::save() const {
  return save_;
}
inline void ImuParameters::set_save(bool value) {
  set_has_save();
  save_ = value;
}

// optional .protos.ImuParameters.AccelScale accel_scale = 10;
inline bool ImuParameters::has_accel_scale() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImuParameters::set_has_accel_scale() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImuParameters::clear_has_accel_scale() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImuParameters::clear_accel_scale() {
  accel_scale_ = 2;
  clear_has_accel_scale();
}
inline ::protos::ImuParameters_AccelScale ImuParameters::accel_scale() const {
  return static_cast< ::protos::ImuParameters_AccelScale >(accel_scale_);
}
inline void ImuParameters::set_accel_scale(::protos::ImuParameters_AccelScale value) {
  assert(::protos::ImuParameters_AccelScale_IsValid(value));
  set_has_accel_scale();
  accel_scale_ = value;
}

// optional .protos.ImuParameters.AccelCutoff accel_cutoff = 11;
inline bool ImuParameters::has_accel_cutoff() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImuParameters::set_has_accel_cutoff() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImuParameters::clear_has_accel_cutoff() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImuParameters::clear_accel_cutoff() {
  accel_cutoff_ = 1;
  clear_has_accel_cutoff();
}
inline ::protos::ImuParameters_AccelCutoff ImuParameters::accel_cutoff() const {
  return static_cast< ::protos::ImuParameters_AccelCutoff >(accel_cutoff_);
}
inline void ImuParameters::set_accel_cutoff(::protos::ImuParameters_AccelCutoff value) {
  assert(::protos::ImuParameters_AccelCutoff_IsValid(value));
  set_has_accel_cutoff();
  accel_cutoff_ = value;
}

// optional .protos.ImuParameters.GyroScale gyro_scale = 20;
inline bool ImuParameters::has_gyro_scale() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImuParameters::set_has_gyro_scale() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImuParameters::clear_has_gyro_scale() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImuParameters::clear_gyro_scale() {
  gyro_scale_ = 1;
  clear_has_gyro_scale();
}
inline ::protos::ImuParameters_GyroScale ImuParameters::gyro_scale() const {
  return static_cast< ::protos::ImuParameters_GyroScale >(gyro_scale_);
}
inline void ImuParameters::set_gyro_scale(::protos::ImuParameters_GyroScale value) {
  assert(::protos::ImuParameters_GyroScale_IsValid(value));
  set_has_gyro_scale();
  gyro_scale_ = value;
}

// -------------------------------------------------------------------

// LedParameters

// optional fixed32 RGBA = 10;
inline bool LedParameters::has_rgba() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LedParameters::set_has_rgba() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LedParameters::clear_has_rgba() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LedParameters::clear_rgba() {
  rgba_ = 0u;
  clear_has_rgba();
}
inline ::google::protobuf::uint32 LedParameters::rgba() const {
  return rgba_;
}
inline void LedParameters::set_rgba(::google::protobuf::uint32 value) {
  set_has_rgba();
  rgba_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ModuleParameters_2eproto__INCLUDED
