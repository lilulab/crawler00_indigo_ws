// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MetaInfo.proto

#ifndef PROTOBUF_MetaInfo_2eproto__INCLUDED
#define PROTOBUF_MetaInfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "Bootloader.pb.h"
#include "ModuleControl.pb.h"
#include "ModuleParameters.pb.h"
#include "RemoteService.pb.h"
// @@protoc_insertion_point(includes)

namespace protos {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MetaInfo_2eproto();
void protobuf_AssignDesc_MetaInfo_2eproto();
void protobuf_ShutdownFile_MetaInfo_2eproto();

class Ping;
class FirmwareInfo;
class EthernetInfo;
class HeaderMessage;

// ===================================================================

class Ping : public ::google::protobuf::MessageLite {
 public:
  Ping();
  virtual ~Ping();

  Ping(const Ping& from);

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }

  static const Ping& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Ping* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Ping* other);

  // implements Message ----------------------------------------------

  Ping* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes payload = 1;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 1;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:protos.Ping)
 private:
  inline void set_has_payload();
  inline void clear_has_payload();

  ::std::string* payload_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MetaInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MetaInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_MetaInfo_2eproto();
  friend void protobuf_ShutdownFile_MetaInfo_2eproto();

  void InitAsDefaultInstance();
  static Ping* default_instance_;
};
// -------------------------------------------------------------------

class FirmwareInfo : public ::google::protobuf::MessageLite {
 public:
  FirmwareInfo();
  virtual ~FirmwareInfo();

  FirmwareInfo(const FirmwareInfo& from);

  inline FirmwareInfo& operator=(const FirmwareInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const FirmwareInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FirmwareInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FirmwareInfo* other);

  // implements Message ----------------------------------------------

  FirmwareInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FirmwareInfo& from);
  void MergeFrom(const FirmwareInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string build_date = 2;
  inline bool has_build_date() const;
  inline void clear_build_date();
  static const int kBuildDateFieldNumber = 2;
  inline const ::std::string& build_date() const;
  inline void set_build_date(const ::std::string& value);
  inline void set_build_date(const char* value);
  inline void set_build_date(const char* value, size_t size);
  inline ::std::string* mutable_build_date();
  inline ::std::string* release_build_date();
  inline void set_allocated_build_date(::std::string* build_date);

  // optional string tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // optional string username = 4;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 4;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:protos.FirmwareInfo)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_build_date();
  inline void clear_has_build_date();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_type();
  inline void clear_has_type();

  ::std::string* version_;
  ::std::string* build_date_;
  ::std::string* tag_;
  ::std::string* username_;
  ::std::string* type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MetaInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MetaInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_MetaInfo_2eproto();
  friend void protobuf_ShutdownFile_MetaInfo_2eproto();

  void InitAsDefaultInstance();
  static FirmwareInfo* default_instance_;
};
// -------------------------------------------------------------------

class EthernetInfo : public ::google::protobuf::MessageLite {
 public:
  EthernetInfo();
  virtual ~EthernetInfo();

  EthernetInfo(const EthernetInfo& from);

  inline EthernetInfo& operator=(const EthernetInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const EthernetInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EthernetInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EthernetInfo* other);

  // implements Message ----------------------------------------------

  EthernetInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EthernetInfo& from);
  void MergeFrom(const EthernetInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes mac_address = 10;
  inline bool has_mac_address() const;
  inline void clear_mac_address();
  static const int kMacAddressFieldNumber = 10;
  inline const ::std::string& mac_address() const;
  inline void set_mac_address(const ::std::string& value);
  inline void set_mac_address(const char* value);
  inline void set_mac_address(const void* value, size_t size);
  inline ::std::string* mutable_mac_address();
  inline ::std::string* release_mac_address();
  inline void set_allocated_mac_address(::std::string* mac_address);

  // optional bytes address = 20;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 20;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const void* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional bytes netmask = 21;
  inline bool has_netmask() const;
  inline void clear_netmask();
  static const int kNetmaskFieldNumber = 21;
  inline const ::std::string& netmask() const;
  inline void set_netmask(const ::std::string& value);
  inline void set_netmask(const char* value);
  inline void set_netmask(const void* value, size_t size);
  inline ::std::string* mutable_netmask();
  inline ::std::string* release_netmask();
  inline void set_allocated_netmask(::std::string* netmask);

  // optional bytes gateway = 22;
  inline bool has_gateway() const;
  inline void clear_gateway();
  static const int kGatewayFieldNumber = 22;
  inline const ::std::string& gateway() const;
  inline void set_gateway(const ::std::string& value);
  inline void set_gateway(const char* value);
  inline void set_gateway(const void* value, size_t size);
  inline ::std::string* mutable_gateway();
  inline ::std::string* release_gateway();
  inline void set_allocated_gateway(::std::string* gateway);

  // optional bytes proximal_ip = 40;
  inline bool has_proximal_ip() const;
  inline void clear_proximal_ip();
  static const int kProximalIpFieldNumber = 40;
  inline const ::std::string& proximal_ip() const;
  inline void set_proximal_ip(const ::std::string& value);
  inline void set_proximal_ip(const char* value);
  inline void set_proximal_ip(const void* value, size_t size);
  inline ::std::string* mutable_proximal_ip();
  inline ::std::string* release_proximal_ip();
  inline void set_allocated_proximal_ip(::std::string* proximal_ip);

  // optional bytes distal_ip = 41;
  inline bool has_distal_ip() const;
  inline void clear_distal_ip();
  static const int kDistalIpFieldNumber = 41;
  inline const ::std::string& distal_ip() const;
  inline void set_distal_ip(const ::std::string& value);
  inline void set_distal_ip(const char* value);
  inline void set_distal_ip(const void* value, size_t size);
  inline ::std::string* mutable_distal_ip();
  inline ::std::string* release_distal_ip();
  inline void set_allocated_distal_ip(::std::string* distal_ip);

  // optional bytes serial_number = 101;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 101;
  inline const ::std::string& serial_number() const;
  inline void set_serial_number(const ::std::string& value);
  inline void set_serial_number(const char* value);
  inline void set_serial_number(const void* value, size_t size);
  inline ::std::string* mutable_serial_number();
  inline ::std::string* release_serial_number();
  inline void set_allocated_serial_number(::std::string* serial_number);

  // @@protoc_insertion_point(class_scope:protos.EthernetInfo)
 private:
  inline void set_has_mac_address();
  inline void clear_has_mac_address();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_netmask();
  inline void clear_has_netmask();
  inline void set_has_gateway();
  inline void clear_has_gateway();
  inline void set_has_proximal_ip();
  inline void clear_has_proximal_ip();
  inline void set_has_distal_ip();
  inline void clear_has_distal_ip();
  inline void set_has_serial_number();
  inline void clear_has_serial_number();

  ::std::string* mac_address_;
  ::std::string* address_;
  ::std::string* netmask_;
  ::std::string* gateway_;
  ::std::string* proximal_ip_;
  ::std::string* distal_ip_;
  ::std::string* serial_number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MetaInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MetaInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_MetaInfo_2eproto();
  friend void protobuf_ShutdownFile_MetaInfo_2eproto();

  void InitAsDefaultInstance();
  static EthernetInfo* default_instance_;
};
// -------------------------------------------------------------------

class HeaderMessage : public ::google::protobuf::MessageLite {
 public:
  HeaderMessage();
  virtual ~HeaderMessage();

  HeaderMessage(const HeaderMessage& from);

  inline HeaderMessage& operator=(const HeaderMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const HeaderMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HeaderMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HeaderMessage* other);

  // implements Message ----------------------------------------------

  HeaderMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HeaderMessage& from);
  void MergeFrom(const HeaderMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protos.Ping ping = 1005;
  inline bool has_ping() const;
  inline void clear_ping();
  static const int kPingFieldNumber = 1005;
  inline const ::protos::Ping& ping() const;
  inline ::protos::Ping* mutable_ping();
  inline ::protos::Ping* release_ping();
  inline void set_allocated_ping(::protos::Ping* ping);

  // optional .protos.FirmwareInfo firmware_info = 1010;
  inline bool has_firmware_info() const;
  inline void clear_firmware_info();
  static const int kFirmwareInfoFieldNumber = 1010;
  inline const ::protos::FirmwareInfo& firmware_info() const;
  inline ::protos::FirmwareInfo* mutable_firmware_info();
  inline ::protos::FirmwareInfo* release_firmware_info();
  inline void set_allocated_firmware_info(::protos::FirmwareInfo* firmware_info);

  // optional bool request_firmware_info = 1011;
  inline bool has_request_firmware_info() const;
  inline void clear_request_firmware_info();
  static const int kRequestFirmwareInfoFieldNumber = 1011;
  inline bool request_firmware_info() const;
  inline void set_request_firmware_info(bool value);

  // optional .protos.EthernetInfo ethernet_info = 1015;
  inline bool has_ethernet_info() const;
  inline void clear_ethernet_info();
  static const int kEthernetInfoFieldNumber = 1015;
  inline const ::protos::EthernetInfo& ethernet_info() const;
  inline ::protos::EthernetInfo* mutable_ethernet_info();
  inline ::protos::EthernetInfo* release_ethernet_info();
  inline void set_allocated_ethernet_info(::protos::EthernetInfo* ethernet_info);

  // optional bool request_ethernet_info = 1016;
  inline bool has_request_ethernet_info() const;
  inline void clear_request_ethernet_info();
  static const int kRequestEthernetInfoFieldNumber = 1016;
  inline bool request_ethernet_info() const;
  inline void set_request_ethernet_info(bool value);

  // optional .protos.bootloader.BootloaderMessage bootloader = 50;
  inline bool has_bootloader() const;
  inline void clear_bootloader();
  static const int kBootloaderFieldNumber = 50;
  inline const ::protos::bootloader::BootloaderMessage& bootloader() const;
  inline ::protos::bootloader::BootloaderMessage* mutable_bootloader();
  inline ::protos::bootloader::BootloaderMessage* release_bootloader();
  inline void set_allocated_bootloader(::protos::bootloader::BootloaderMessage* bootloader);

  // optional fixed32 tv_sec = 1;
  inline bool has_tv_sec() const;
  inline void clear_tv_sec();
  static const int kTvSecFieldNumber = 1;
  inline ::google::protobuf::uint32 tv_sec() const;
  inline void set_tv_sec(::google::protobuf::uint32 value);

  // optional uint32 tv_usec = 2;
  inline bool has_tv_usec() const;
  inline void clear_tv_usec();
  static const int kTvUsecFieldNumber = 2;
  inline ::google::protobuf::uint32 tv_usec() const;
  inline void set_tv_usec(::google::protobuf::uint32 value);

  // optional .protos.ModuleCommand module_command = 10;
  inline bool has_module_command() const;
  inline void clear_module_command();
  static const int kModuleCommandFieldNumber = 10;
  inline const ::protos::ModuleCommand& module_command() const;
  inline ::protos::ModuleCommand* mutable_module_command();
  inline ::protos::ModuleCommand* release_module_command();
  inline void set_allocated_module_command(::protos::ModuleCommand* module_command);

  // optional .protos.ModuleFeedback module_feedback = 11;
  inline bool has_module_feedback() const;
  inline void clear_module_feedback();
  static const int kModuleFeedbackFieldNumber = 11;
  inline const ::protos::ModuleFeedback& module_feedback() const;
  inline ::protos::ModuleFeedback* mutable_module_feedback();
  inline ::protos::ModuleFeedback* release_module_feedback();
  inline void set_allocated_module_feedback(::protos::ModuleFeedback* module_feedback);

  // optional .protos.ParameterMessage parameter_command = 20;
  inline bool has_parameter_command() const;
  inline void clear_parameter_command();
  static const int kParameterCommandFieldNumber = 20;
  inline const ::protos::ParameterMessage& parameter_command() const;
  inline ::protos::ParameterMessage* mutable_parameter_command();
  inline ::protos::ParameterMessage* release_parameter_command();
  inline void set_allocated_parameter_command(::protos::ParameterMessage* parameter_command);

  // optional .protos.ParameterMessage parameter_feedback = 21;
  inline bool has_parameter_feedback() const;
  inline void clear_parameter_feedback();
  static const int kParameterFeedbackFieldNumber = 21;
  inline const ::protos::ParameterMessage& parameter_feedback() const;
  inline ::protos::ParameterMessage* mutable_parameter_feedback();
  inline ::protos::ParameterMessage* release_parameter_feedback();
  inline void set_allocated_parameter_feedback(::protos::ParameterMessage* parameter_feedback);

  // optional .protos.RemoteService remoteService = 31;
  inline bool has_remoteservice() const;
  inline void clear_remoteservice();
  static const int kRemoteServiceFieldNumber = 31;
  inline const ::protos::RemoteService& remoteservice() const;
  inline ::protos::RemoteService* mutable_remoteservice();
  inline ::protos::RemoteService* release_remoteservice();
  inline void set_allocated_remoteservice(::protos::RemoteService* remoteservice);

  // @@protoc_insertion_point(class_scope:protos.HeaderMessage)
 private:
  inline void set_has_ping();
  inline void clear_has_ping();
  inline void set_has_firmware_info();
  inline void clear_has_firmware_info();
  inline void set_has_request_firmware_info();
  inline void clear_has_request_firmware_info();
  inline void set_has_ethernet_info();
  inline void clear_has_ethernet_info();
  inline void set_has_request_ethernet_info();
  inline void clear_has_request_ethernet_info();
  inline void set_has_bootloader();
  inline void clear_has_bootloader();
  inline void set_has_tv_sec();
  inline void clear_has_tv_sec();
  inline void set_has_tv_usec();
  inline void clear_has_tv_usec();
  inline void set_has_module_command();
  inline void clear_has_module_command();
  inline void set_has_module_feedback();
  inline void clear_has_module_feedback();
  inline void set_has_parameter_command();
  inline void clear_has_parameter_command();
  inline void set_has_parameter_feedback();
  inline void clear_has_parameter_feedback();
  inline void set_has_remoteservice();
  inline void clear_has_remoteservice();

  ::protos::Ping* ping_;
  ::protos::FirmwareInfo* firmware_info_;
  ::protos::EthernetInfo* ethernet_info_;
  bool request_firmware_info_;
  bool request_ethernet_info_;
  ::google::protobuf::uint32 tv_sec_;
  ::protos::bootloader::BootloaderMessage* bootloader_;
  ::protos::ModuleCommand* module_command_;
  ::protos::ModuleFeedback* module_feedback_;
  ::protos::ParameterMessage* parameter_command_;
  ::protos::ParameterMessage* parameter_feedback_;
  ::protos::RemoteService* remoteservice_;
  ::google::protobuf::uint32 tv_usec_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MetaInfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MetaInfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_MetaInfo_2eproto();
  friend void protobuf_ShutdownFile_MetaInfo_2eproto();

  void InitAsDefaultInstance();
  static HeaderMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// Ping

// optional bytes payload = 1;
inline bool Ping::has_payload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ping::set_has_payload() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ping::clear_has_payload() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ping::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& Ping::payload() const {
  return *payload_;
}
inline void Ping::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void Ping::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void Ping::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ping::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* Ping::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Ping::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FirmwareInfo

// optional string version = 1;
inline bool FirmwareInfo::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FirmwareInfo::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FirmwareInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FirmwareInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& FirmwareInfo::version() const {
  return *version_;
}
inline void FirmwareInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void FirmwareInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void FirmwareInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FirmwareInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* FirmwareInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FirmwareInfo::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string build_date = 2;
inline bool FirmwareInfo::has_build_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FirmwareInfo::set_has_build_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FirmwareInfo::clear_has_build_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FirmwareInfo::clear_build_date() {
  if (build_date_ != &::google::protobuf::internal::kEmptyString) {
    build_date_->clear();
  }
  clear_has_build_date();
}
inline const ::std::string& FirmwareInfo::build_date() const {
  return *build_date_;
}
inline void FirmwareInfo::set_build_date(const ::std::string& value) {
  set_has_build_date();
  if (build_date_ == &::google::protobuf::internal::kEmptyString) {
    build_date_ = new ::std::string;
  }
  build_date_->assign(value);
}
inline void FirmwareInfo::set_build_date(const char* value) {
  set_has_build_date();
  if (build_date_ == &::google::protobuf::internal::kEmptyString) {
    build_date_ = new ::std::string;
  }
  build_date_->assign(value);
}
inline void FirmwareInfo::set_build_date(const char* value, size_t size) {
  set_has_build_date();
  if (build_date_ == &::google::protobuf::internal::kEmptyString) {
    build_date_ = new ::std::string;
  }
  build_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FirmwareInfo::mutable_build_date() {
  set_has_build_date();
  if (build_date_ == &::google::protobuf::internal::kEmptyString) {
    build_date_ = new ::std::string;
  }
  return build_date_;
}
inline ::std::string* FirmwareInfo::release_build_date() {
  clear_has_build_date();
  if (build_date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = build_date_;
    build_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FirmwareInfo::set_allocated_build_date(::std::string* build_date) {
  if (build_date_ != &::google::protobuf::internal::kEmptyString) {
    delete build_date_;
  }
  if (build_date) {
    set_has_build_date();
    build_date_ = build_date;
  } else {
    clear_has_build_date();
    build_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tag = 3;
inline bool FirmwareInfo::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FirmwareInfo::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FirmwareInfo::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FirmwareInfo::clear_tag() {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& FirmwareInfo::tag() const {
  return *tag_;
}
inline void FirmwareInfo::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void FirmwareInfo::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void FirmwareInfo::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FirmwareInfo::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  return tag_;
}
inline ::std::string* FirmwareInfo::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FirmwareInfo::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string username = 4;
inline bool FirmwareInfo::has_username() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FirmwareInfo::set_has_username() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FirmwareInfo::clear_has_username() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FirmwareInfo::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& FirmwareInfo::username() const {
  return *username_;
}
inline void FirmwareInfo::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void FirmwareInfo::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void FirmwareInfo::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FirmwareInfo::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* FirmwareInfo::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FirmwareInfo::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string type = 5;
inline bool FirmwareInfo::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FirmwareInfo::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FirmwareInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FirmwareInfo::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& FirmwareInfo::type() const {
  return *type_;
}
inline void FirmwareInfo::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void FirmwareInfo::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void FirmwareInfo::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FirmwareInfo::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* FirmwareInfo::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FirmwareInfo::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EthernetInfo

// optional bytes mac_address = 10;
inline bool EthernetInfo::has_mac_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EthernetInfo::set_has_mac_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EthernetInfo::clear_has_mac_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EthernetInfo::clear_mac_address() {
  if (mac_address_ != &::google::protobuf::internal::kEmptyString) {
    mac_address_->clear();
  }
  clear_has_mac_address();
}
inline const ::std::string& EthernetInfo::mac_address() const {
  return *mac_address_;
}
inline void EthernetInfo::set_mac_address(const ::std::string& value) {
  set_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    mac_address_ = new ::std::string;
  }
  mac_address_->assign(value);
}
inline void EthernetInfo::set_mac_address(const char* value) {
  set_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    mac_address_ = new ::std::string;
  }
  mac_address_->assign(value);
}
inline void EthernetInfo::set_mac_address(const void* value, size_t size) {
  set_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    mac_address_ = new ::std::string;
  }
  mac_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EthernetInfo::mutable_mac_address() {
  set_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    mac_address_ = new ::std::string;
  }
  return mac_address_;
}
inline ::std::string* EthernetInfo::release_mac_address() {
  clear_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mac_address_;
    mac_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EthernetInfo::set_allocated_mac_address(::std::string* mac_address) {
  if (mac_address_ != &::google::protobuf::internal::kEmptyString) {
    delete mac_address_;
  }
  if (mac_address) {
    set_has_mac_address();
    mac_address_ = mac_address;
  } else {
    clear_has_mac_address();
    mac_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes address = 20;
inline bool EthernetInfo::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EthernetInfo::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EthernetInfo::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EthernetInfo::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& EthernetInfo::address() const {
  return *address_;
}
inline void EthernetInfo::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void EthernetInfo::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void EthernetInfo::set_address(const void* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EthernetInfo::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* EthernetInfo::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EthernetInfo::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes netmask = 21;
inline bool EthernetInfo::has_netmask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EthernetInfo::set_has_netmask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EthernetInfo::clear_has_netmask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EthernetInfo::clear_netmask() {
  if (netmask_ != &::google::protobuf::internal::kEmptyString) {
    netmask_->clear();
  }
  clear_has_netmask();
}
inline const ::std::string& EthernetInfo::netmask() const {
  return *netmask_;
}
inline void EthernetInfo::set_netmask(const ::std::string& value) {
  set_has_netmask();
  if (netmask_ == &::google::protobuf::internal::kEmptyString) {
    netmask_ = new ::std::string;
  }
  netmask_->assign(value);
}
inline void EthernetInfo::set_netmask(const char* value) {
  set_has_netmask();
  if (netmask_ == &::google::protobuf::internal::kEmptyString) {
    netmask_ = new ::std::string;
  }
  netmask_->assign(value);
}
inline void EthernetInfo::set_netmask(const void* value, size_t size) {
  set_has_netmask();
  if (netmask_ == &::google::protobuf::internal::kEmptyString) {
    netmask_ = new ::std::string;
  }
  netmask_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EthernetInfo::mutable_netmask() {
  set_has_netmask();
  if (netmask_ == &::google::protobuf::internal::kEmptyString) {
    netmask_ = new ::std::string;
  }
  return netmask_;
}
inline ::std::string* EthernetInfo::release_netmask() {
  clear_has_netmask();
  if (netmask_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = netmask_;
    netmask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EthernetInfo::set_allocated_netmask(::std::string* netmask) {
  if (netmask_ != &::google::protobuf::internal::kEmptyString) {
    delete netmask_;
  }
  if (netmask) {
    set_has_netmask();
    netmask_ = netmask;
  } else {
    clear_has_netmask();
    netmask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gateway = 22;
inline bool EthernetInfo::has_gateway() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EthernetInfo::set_has_gateway() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EthernetInfo::clear_has_gateway() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EthernetInfo::clear_gateway() {
  if (gateway_ != &::google::protobuf::internal::kEmptyString) {
    gateway_->clear();
  }
  clear_has_gateway();
}
inline const ::std::string& EthernetInfo::gateway() const {
  return *gateway_;
}
inline void EthernetInfo::set_gateway(const ::std::string& value) {
  set_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    gateway_ = new ::std::string;
  }
  gateway_->assign(value);
}
inline void EthernetInfo::set_gateway(const char* value) {
  set_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    gateway_ = new ::std::string;
  }
  gateway_->assign(value);
}
inline void EthernetInfo::set_gateway(const void* value, size_t size) {
  set_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    gateway_ = new ::std::string;
  }
  gateway_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EthernetInfo::mutable_gateway() {
  set_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    gateway_ = new ::std::string;
  }
  return gateway_;
}
inline ::std::string* EthernetInfo::release_gateway() {
  clear_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gateway_;
    gateway_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EthernetInfo::set_allocated_gateway(::std::string* gateway) {
  if (gateway_ != &::google::protobuf::internal::kEmptyString) {
    delete gateway_;
  }
  if (gateway) {
    set_has_gateway();
    gateway_ = gateway;
  } else {
    clear_has_gateway();
    gateway_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes proximal_ip = 40;
inline bool EthernetInfo::has_proximal_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EthernetInfo::set_has_proximal_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EthernetInfo::clear_has_proximal_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EthernetInfo::clear_proximal_ip() {
  if (proximal_ip_ != &::google::protobuf::internal::kEmptyString) {
    proximal_ip_->clear();
  }
  clear_has_proximal_ip();
}
inline const ::std::string& EthernetInfo::proximal_ip() const {
  return *proximal_ip_;
}
inline void EthernetInfo::set_proximal_ip(const ::std::string& value) {
  set_has_proximal_ip();
  if (proximal_ip_ == &::google::protobuf::internal::kEmptyString) {
    proximal_ip_ = new ::std::string;
  }
  proximal_ip_->assign(value);
}
inline void EthernetInfo::set_proximal_ip(const char* value) {
  set_has_proximal_ip();
  if (proximal_ip_ == &::google::protobuf::internal::kEmptyString) {
    proximal_ip_ = new ::std::string;
  }
  proximal_ip_->assign(value);
}
inline void EthernetInfo::set_proximal_ip(const void* value, size_t size) {
  set_has_proximal_ip();
  if (proximal_ip_ == &::google::protobuf::internal::kEmptyString) {
    proximal_ip_ = new ::std::string;
  }
  proximal_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EthernetInfo::mutable_proximal_ip() {
  set_has_proximal_ip();
  if (proximal_ip_ == &::google::protobuf::internal::kEmptyString) {
    proximal_ip_ = new ::std::string;
  }
  return proximal_ip_;
}
inline ::std::string* EthernetInfo::release_proximal_ip() {
  clear_has_proximal_ip();
  if (proximal_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proximal_ip_;
    proximal_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EthernetInfo::set_allocated_proximal_ip(::std::string* proximal_ip) {
  if (proximal_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete proximal_ip_;
  }
  if (proximal_ip) {
    set_has_proximal_ip();
    proximal_ip_ = proximal_ip;
  } else {
    clear_has_proximal_ip();
    proximal_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes distal_ip = 41;
inline bool EthernetInfo::has_distal_ip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EthernetInfo::set_has_distal_ip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EthernetInfo::clear_has_distal_ip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EthernetInfo::clear_distal_ip() {
  if (distal_ip_ != &::google::protobuf::internal::kEmptyString) {
    distal_ip_->clear();
  }
  clear_has_distal_ip();
}
inline const ::std::string& EthernetInfo::distal_ip() const {
  return *distal_ip_;
}
inline void EthernetInfo::set_distal_ip(const ::std::string& value) {
  set_has_distal_ip();
  if (distal_ip_ == &::google::protobuf::internal::kEmptyString) {
    distal_ip_ = new ::std::string;
  }
  distal_ip_->assign(value);
}
inline void EthernetInfo::set_distal_ip(const char* value) {
  set_has_distal_ip();
  if (distal_ip_ == &::google::protobuf::internal::kEmptyString) {
    distal_ip_ = new ::std::string;
  }
  distal_ip_->assign(value);
}
inline void EthernetInfo::set_distal_ip(const void* value, size_t size) {
  set_has_distal_ip();
  if (distal_ip_ == &::google::protobuf::internal::kEmptyString) {
    distal_ip_ = new ::std::string;
  }
  distal_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EthernetInfo::mutable_distal_ip() {
  set_has_distal_ip();
  if (distal_ip_ == &::google::protobuf::internal::kEmptyString) {
    distal_ip_ = new ::std::string;
  }
  return distal_ip_;
}
inline ::std::string* EthernetInfo::release_distal_ip() {
  clear_has_distal_ip();
  if (distal_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = distal_ip_;
    distal_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EthernetInfo::set_allocated_distal_ip(::std::string* distal_ip) {
  if (distal_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete distal_ip_;
  }
  if (distal_ip) {
    set_has_distal_ip();
    distal_ip_ = distal_ip;
  } else {
    clear_has_distal_ip();
    distal_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes serial_number = 101;
inline bool EthernetInfo::has_serial_number() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EthernetInfo::set_has_serial_number() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EthernetInfo::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EthernetInfo::clear_serial_number() {
  if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
    serial_number_->clear();
  }
  clear_has_serial_number();
}
inline const ::std::string& EthernetInfo::serial_number() const {
  return *serial_number_;
}
inline void EthernetInfo::set_serial_number(const ::std::string& value) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(value);
}
inline void EthernetInfo::set_serial_number(const char* value) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(value);
}
inline void EthernetInfo::set_serial_number(const void* value, size_t size) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EthernetInfo::mutable_serial_number() {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  return serial_number_;
}
inline ::std::string* EthernetInfo::release_serial_number() {
  clear_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serial_number_;
    serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EthernetInfo::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
    delete serial_number_;
  }
  if (serial_number) {
    set_has_serial_number();
    serial_number_ = serial_number;
  } else {
    clear_has_serial_number();
    serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HeaderMessage

// optional .protos.Ping ping = 1005;
inline bool HeaderMessage::has_ping() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeaderMessage::set_has_ping() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeaderMessage::clear_has_ping() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeaderMessage::clear_ping() {
  if (ping_ != NULL) ping_->::protos::Ping::Clear();
  clear_has_ping();
}
inline const ::protos::Ping& HeaderMessage::ping() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ping_ != NULL ? *ping_ : *default_instance().ping_;
#else
  return ping_ != NULL ? *ping_ : *default_instance_->ping_;
#endif
}
inline ::protos::Ping* HeaderMessage::mutable_ping() {
  set_has_ping();
  if (ping_ == NULL) ping_ = new ::protos::Ping;
  return ping_;
}
inline ::protos::Ping* HeaderMessage::release_ping() {
  clear_has_ping();
  ::protos::Ping* temp = ping_;
  ping_ = NULL;
  return temp;
}
inline void HeaderMessage::set_allocated_ping(::protos::Ping* ping) {
  delete ping_;
  ping_ = ping;
  if (ping) {
    set_has_ping();
  } else {
    clear_has_ping();
  }
}

// optional .protos.FirmwareInfo firmware_info = 1010;
inline bool HeaderMessage::has_firmware_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeaderMessage::set_has_firmware_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeaderMessage::clear_has_firmware_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeaderMessage::clear_firmware_info() {
  if (firmware_info_ != NULL) firmware_info_->::protos::FirmwareInfo::Clear();
  clear_has_firmware_info();
}
inline const ::protos::FirmwareInfo& HeaderMessage::firmware_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return firmware_info_ != NULL ? *firmware_info_ : *default_instance().firmware_info_;
#else
  return firmware_info_ != NULL ? *firmware_info_ : *default_instance_->firmware_info_;
#endif
}
inline ::protos::FirmwareInfo* HeaderMessage::mutable_firmware_info() {
  set_has_firmware_info();
  if (firmware_info_ == NULL) firmware_info_ = new ::protos::FirmwareInfo;
  return firmware_info_;
}
inline ::protos::FirmwareInfo* HeaderMessage::release_firmware_info() {
  clear_has_firmware_info();
  ::protos::FirmwareInfo* temp = firmware_info_;
  firmware_info_ = NULL;
  return temp;
}
inline void HeaderMessage::set_allocated_firmware_info(::protos::FirmwareInfo* firmware_info) {
  delete firmware_info_;
  firmware_info_ = firmware_info;
  if (firmware_info) {
    set_has_firmware_info();
  } else {
    clear_has_firmware_info();
  }
}

// optional bool request_firmware_info = 1011;
inline bool HeaderMessage::has_request_firmware_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeaderMessage::set_has_request_firmware_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HeaderMessage::clear_has_request_firmware_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HeaderMessage::clear_request_firmware_info() {
  request_firmware_info_ = false;
  clear_has_request_firmware_info();
}
inline bool HeaderMessage::request_firmware_info() const {
  return request_firmware_info_;
}
inline void HeaderMessage::set_request_firmware_info(bool value) {
  set_has_request_firmware_info();
  request_firmware_info_ = value;
}

// optional .protos.EthernetInfo ethernet_info = 1015;
inline bool HeaderMessage::has_ethernet_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HeaderMessage::set_has_ethernet_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HeaderMessage::clear_has_ethernet_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HeaderMessage::clear_ethernet_info() {
  if (ethernet_info_ != NULL) ethernet_info_->::protos::EthernetInfo::Clear();
  clear_has_ethernet_info();
}
inline const ::protos::EthernetInfo& HeaderMessage::ethernet_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ethernet_info_ != NULL ? *ethernet_info_ : *default_instance().ethernet_info_;
#else
  return ethernet_info_ != NULL ? *ethernet_info_ : *default_instance_->ethernet_info_;
#endif
}
inline ::protos::EthernetInfo* HeaderMessage::mutable_ethernet_info() {
  set_has_ethernet_info();
  if (ethernet_info_ == NULL) ethernet_info_ = new ::protos::EthernetInfo;
  return ethernet_info_;
}
inline ::protos::EthernetInfo* HeaderMessage::release_ethernet_info() {
  clear_has_ethernet_info();
  ::protos::EthernetInfo* temp = ethernet_info_;
  ethernet_info_ = NULL;
  return temp;
}
inline void HeaderMessage::set_allocated_ethernet_info(::protos::EthernetInfo* ethernet_info) {
  delete ethernet_info_;
  ethernet_info_ = ethernet_info;
  if (ethernet_info) {
    set_has_ethernet_info();
  } else {
    clear_has_ethernet_info();
  }
}

// optional bool request_ethernet_info = 1016;
inline bool HeaderMessage::has_request_ethernet_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HeaderMessage::set_has_request_ethernet_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HeaderMessage::clear_has_request_ethernet_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HeaderMessage::clear_request_ethernet_info() {
  request_ethernet_info_ = false;
  clear_has_request_ethernet_info();
}
inline bool HeaderMessage::request_ethernet_info() const {
  return request_ethernet_info_;
}
inline void HeaderMessage::set_request_ethernet_info(bool value) {
  set_has_request_ethernet_info();
  request_ethernet_info_ = value;
}

// optional .protos.bootloader.BootloaderMessage bootloader = 50;
inline bool HeaderMessage::has_bootloader() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HeaderMessage::set_has_bootloader() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HeaderMessage::clear_has_bootloader() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HeaderMessage::clear_bootloader() {
  if (bootloader_ != NULL) bootloader_->::protos::bootloader::BootloaderMessage::Clear();
  clear_has_bootloader();
}
inline const ::protos::bootloader::BootloaderMessage& HeaderMessage::bootloader() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bootloader_ != NULL ? *bootloader_ : *default_instance().bootloader_;
#else
  return bootloader_ != NULL ? *bootloader_ : *default_instance_->bootloader_;
#endif
}
inline ::protos::bootloader::BootloaderMessage* HeaderMessage::mutable_bootloader() {
  set_has_bootloader();
  if (bootloader_ == NULL) bootloader_ = new ::protos::bootloader::BootloaderMessage;
  return bootloader_;
}
inline ::protos::bootloader::BootloaderMessage* HeaderMessage::release_bootloader() {
  clear_has_bootloader();
  ::protos::bootloader::BootloaderMessage* temp = bootloader_;
  bootloader_ = NULL;
  return temp;
}
inline void HeaderMessage::set_allocated_bootloader(::protos::bootloader::BootloaderMessage* bootloader) {
  delete bootloader_;
  bootloader_ = bootloader;
  if (bootloader) {
    set_has_bootloader();
  } else {
    clear_has_bootloader();
  }
}

// optional fixed32 tv_sec = 1;
inline bool HeaderMessage::has_tv_sec() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HeaderMessage::set_has_tv_sec() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HeaderMessage::clear_has_tv_sec() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HeaderMessage::clear_tv_sec() {
  tv_sec_ = 0u;
  clear_has_tv_sec();
}
inline ::google::protobuf::uint32 HeaderMessage::tv_sec() const {
  return tv_sec_;
}
inline void HeaderMessage::set_tv_sec(::google::protobuf::uint32 value) {
  set_has_tv_sec();
  tv_sec_ = value;
}

// optional uint32 tv_usec = 2;
inline bool HeaderMessage::has_tv_usec() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HeaderMessage::set_has_tv_usec() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HeaderMessage::clear_has_tv_usec() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HeaderMessage::clear_tv_usec() {
  tv_usec_ = 0u;
  clear_has_tv_usec();
}
inline ::google::protobuf::uint32 HeaderMessage::tv_usec() const {
  return tv_usec_;
}
inline void HeaderMessage::set_tv_usec(::google::protobuf::uint32 value) {
  set_has_tv_usec();
  tv_usec_ = value;
}

// optional .protos.ModuleCommand module_command = 10;
inline bool HeaderMessage::has_module_command() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HeaderMessage::set_has_module_command() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HeaderMessage::clear_has_module_command() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HeaderMessage::clear_module_command() {
  if (module_command_ != NULL) module_command_->::protos::ModuleCommand::Clear();
  clear_has_module_command();
}
inline const ::protos::ModuleCommand& HeaderMessage::module_command() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return module_command_ != NULL ? *module_command_ : *default_instance().module_command_;
#else
  return module_command_ != NULL ? *module_command_ : *default_instance_->module_command_;
#endif
}
inline ::protos::ModuleCommand* HeaderMessage::mutable_module_command() {
  set_has_module_command();
  if (module_command_ == NULL) module_command_ = new ::protos::ModuleCommand;
  return module_command_;
}
inline ::protos::ModuleCommand* HeaderMessage::release_module_command() {
  clear_has_module_command();
  ::protos::ModuleCommand* temp = module_command_;
  module_command_ = NULL;
  return temp;
}
inline void HeaderMessage::set_allocated_module_command(::protos::ModuleCommand* module_command) {
  delete module_command_;
  module_command_ = module_command;
  if (module_command) {
    set_has_module_command();
  } else {
    clear_has_module_command();
  }
}

// optional .protos.ModuleFeedback module_feedback = 11;
inline bool HeaderMessage::has_module_feedback() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HeaderMessage::set_has_module_feedback() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HeaderMessage::clear_has_module_feedback() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HeaderMessage::clear_module_feedback() {
  if (module_feedback_ != NULL) module_feedback_->::protos::ModuleFeedback::Clear();
  clear_has_module_feedback();
}
inline const ::protos::ModuleFeedback& HeaderMessage::module_feedback() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return module_feedback_ != NULL ? *module_feedback_ : *default_instance().module_feedback_;
#else
  return module_feedback_ != NULL ? *module_feedback_ : *default_instance_->module_feedback_;
#endif
}
inline ::protos::ModuleFeedback* HeaderMessage::mutable_module_feedback() {
  set_has_module_feedback();
  if (module_feedback_ == NULL) module_feedback_ = new ::protos::ModuleFeedback;
  return module_feedback_;
}
inline ::protos::ModuleFeedback* HeaderMessage::release_module_feedback() {
  clear_has_module_feedback();
  ::protos::ModuleFeedback* temp = module_feedback_;
  module_feedback_ = NULL;
  return temp;
}
inline void HeaderMessage::set_allocated_module_feedback(::protos::ModuleFeedback* module_feedback) {
  delete module_feedback_;
  module_feedback_ = module_feedback;
  if (module_feedback) {
    set_has_module_feedback();
  } else {
    clear_has_module_feedback();
  }
}

// optional .protos.ParameterMessage parameter_command = 20;
inline bool HeaderMessage::has_parameter_command() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HeaderMessage::set_has_parameter_command() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HeaderMessage::clear_has_parameter_command() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HeaderMessage::clear_parameter_command() {
  if (parameter_command_ != NULL) parameter_command_->::protos::ParameterMessage::Clear();
  clear_has_parameter_command();
}
inline const ::protos::ParameterMessage& HeaderMessage::parameter_command() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return parameter_command_ != NULL ? *parameter_command_ : *default_instance().parameter_command_;
#else
  return parameter_command_ != NULL ? *parameter_command_ : *default_instance_->parameter_command_;
#endif
}
inline ::protos::ParameterMessage* HeaderMessage::mutable_parameter_command() {
  set_has_parameter_command();
  if (parameter_command_ == NULL) parameter_command_ = new ::protos::ParameterMessage;
  return parameter_command_;
}
inline ::protos::ParameterMessage* HeaderMessage::release_parameter_command() {
  clear_has_parameter_command();
  ::protos::ParameterMessage* temp = parameter_command_;
  parameter_command_ = NULL;
  return temp;
}
inline void HeaderMessage::set_allocated_parameter_command(::protos::ParameterMessage* parameter_command) {
  delete parameter_command_;
  parameter_command_ = parameter_command;
  if (parameter_command) {
    set_has_parameter_command();
  } else {
    clear_has_parameter_command();
  }
}

// optional .protos.ParameterMessage parameter_feedback = 21;
inline bool HeaderMessage::has_parameter_feedback() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void HeaderMessage::set_has_parameter_feedback() {
  _has_bits_[0] |= 0x00000800u;
}
inline void HeaderMessage::clear_has_parameter_feedback() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void HeaderMessage::clear_parameter_feedback() {
  if (parameter_feedback_ != NULL) parameter_feedback_->::protos::ParameterMessage::Clear();
  clear_has_parameter_feedback();
}
inline const ::protos::ParameterMessage& HeaderMessage::parameter_feedback() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return parameter_feedback_ != NULL ? *parameter_feedback_ : *default_instance().parameter_feedback_;
#else
  return parameter_feedback_ != NULL ? *parameter_feedback_ : *default_instance_->parameter_feedback_;
#endif
}
inline ::protos::ParameterMessage* HeaderMessage::mutable_parameter_feedback() {
  set_has_parameter_feedback();
  if (parameter_feedback_ == NULL) parameter_feedback_ = new ::protos::ParameterMessage;
  return parameter_feedback_;
}
inline ::protos::ParameterMessage* HeaderMessage::release_parameter_feedback() {
  clear_has_parameter_feedback();
  ::protos::ParameterMessage* temp = parameter_feedback_;
  parameter_feedback_ = NULL;
  return temp;
}
inline void HeaderMessage::set_allocated_parameter_feedback(::protos::ParameterMessage* parameter_feedback) {
  delete parameter_feedback_;
  parameter_feedback_ = parameter_feedback;
  if (parameter_feedback) {
    set_has_parameter_feedback();
  } else {
    clear_has_parameter_feedback();
  }
}

// optional .protos.RemoteService remoteService = 31;
inline bool HeaderMessage::has_remoteservice() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void HeaderMessage::set_has_remoteservice() {
  _has_bits_[0] |= 0x00001000u;
}
inline void HeaderMessage::clear_has_remoteservice() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void HeaderMessage::clear_remoteservice() {
  if (remoteservice_ != NULL) remoteservice_->::protos::RemoteService::Clear();
  clear_has_remoteservice();
}
inline const ::protos::RemoteService& HeaderMessage::remoteservice() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return remoteservice_ != NULL ? *remoteservice_ : *default_instance().remoteservice_;
#else
  return remoteservice_ != NULL ? *remoteservice_ : *default_instance_->remoteservice_;
#endif
}
inline ::protos::RemoteService* HeaderMessage::mutable_remoteservice() {
  set_has_remoteservice();
  if (remoteservice_ == NULL) remoteservice_ = new ::protos::RemoteService;
  return remoteservice_;
}
inline ::protos::RemoteService* HeaderMessage::release_remoteservice() {
  clear_has_remoteservice();
  ::protos::RemoteService* temp = remoteservice_;
  remoteservice_ = NULL;
  return temp;
}
inline void HeaderMessage::set_allocated_remoteservice(::protos::RemoteService* remoteservice) {
  delete remoteservice_;
  remoteservice_ = remoteservice;
  if (remoteservice) {
    set_has_remoteservice();
  } else {
    clear_has_remoteservice();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MetaInfo_2eproto__INCLUDED
