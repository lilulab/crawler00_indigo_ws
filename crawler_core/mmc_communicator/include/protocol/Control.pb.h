// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Control.proto

#ifndef PROTOBUF_Control_2eproto__INCLUDED
#define PROTOBUF_Control_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "DataTypes.pb.h"
// @@protoc_insertion_point(includes)

namespace biorobotics {
namespace firmware {
namespace protos {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Control_2eproto();
void protobuf_AssignDesc_Control_2eproto();
void protobuf_ShutdownFile_Control_2eproto();

class Command;
class Feedback;

// ===================================================================

class Command : public ::google::protobuf::MessageLite {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  static const Command& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Command* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  Command* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline float position() const;
  inline void set_position(float value);

  // optional float velocity = 2;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 2;
  inline float velocity() const;
  inline void set_velocity(float value);

  // optional float torque = 3;
  inline bool has_torque() const;
  inline void clear_torque();
  static const int kTorqueFieldNumber = 3;
  inline float torque() const;
  inline void set_torque(float value);

  // optional float pwm = 8;
  inline bool has_pwm() const;
  inline void clear_pwm();
  static const int kPwmFieldNumber = 8;
  inline float pwm() const;
  inline void set_pwm(float value);

  // optional float inner_torque = 9;
  inline bool has_inner_torque() const;
  inline void clear_inner_torque();
  static const int kInnerTorqueFieldNumber = 9;
  inline float inner_torque() const;
  inline void set_inner_torque(float value);

  // optional .biorobotics.firmware.protos.Color led = 10;
  inline bool has_led() const;
  inline void clear_led();
  static const int kLedFieldNumber = 10;
  inline const ::biorobotics::firmware::protos::Color& led() const;
  inline ::biorobotics::firmware::protos::Color* mutable_led();
  inline ::biorobotics::firmware::protos::Color* release_led();
  inline void set_allocated_led(::biorobotics::firmware::protos::Color* led);

  // @@protoc_insertion_point(class_scope:biorobotics.firmware.protos.Command)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_torque();
  inline void clear_has_torque();
  inline void set_has_pwm();
  inline void clear_has_pwm();
  inline void set_has_inner_torque();
  inline void clear_has_inner_torque();
  inline void set_has_led();
  inline void clear_has_led();

  float position_;
  float velocity_;
  float torque_;
  float pwm_;
  ::biorobotics::firmware::protos::Color* led_;
  float inner_torque_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Control_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Control_2eproto();
  #endif
  friend void protobuf_AssignDesc_Control_2eproto();
  friend void protobuf_ShutdownFile_Control_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class Feedback : public ::google::protobuf::MessageLite {
 public:
  Feedback();
  virtual ~Feedback();

  Feedback(const Feedback& from);

  inline Feedback& operator=(const Feedback& from) {
    CopyFrom(from);
    return *this;
  }

  static const Feedback& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Feedback* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Feedback* other);

  // implements Message ----------------------------------------------

  Feedback* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Feedback& from);
  void MergeFrom(const Feedback& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .biorobotics.firmware.protos.Color led = 10;
  inline bool has_led() const;
  inline void clear_led();
  static const int kLedFieldNumber = 10;
  inline const ::biorobotics::firmware::protos::Color& led() const;
  inline ::biorobotics::firmware::protos::Color* mutable_led();
  inline ::biorobotics::firmware::protos::Color* release_led();
  inline void set_allocated_led(::biorobotics::firmware::protos::Color* led);

  // optional float position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline float position() const;
  inline void set_position(float value);

  // optional float velocity = 2;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 2;
  inline float velocity() const;
  inline void set_velocity(float value);

  // optional float torque = 3;
  inline bool has_torque() const;
  inline void clear_torque();
  static const int kTorqueFieldNumber = 3;
  inline float torque() const;
  inline void set_torque(float value);

  // optional float deflection = 4;
  inline bool has_deflection() const;
  inline void clear_deflection();
  static const int kDeflectionFieldNumber = 4;
  inline float deflection() const;
  inline void set_deflection(float value);

  // optional float motor_velocity = 5;
  inline bool has_motor_velocity() const;
  inline void clear_motor_velocity();
  static const int kMotorVelocityFieldNumber = 5;
  inline float motor_velocity() const;
  inline void set_motor_velocity(float value);

  // optional float deflection_velocity = 6;
  inline bool has_deflection_velocity() const;
  inline void clear_deflection_velocity();
  static const int kDeflectionVelocityFieldNumber = 6;
  inline float deflection_velocity() const;
  inline void set_deflection_velocity(float value);

  // optional .biorobotics.firmware.protos.Vector3 accel = 26;
  inline bool has_accel() const;
  inline void clear_accel();
  static const int kAccelFieldNumber = 26;
  inline const ::biorobotics::firmware::protos::Vector3& accel() const;
  inline ::biorobotics::firmware::protos::Vector3* mutable_accel();
  inline ::biorobotics::firmware::protos::Vector3* release_accel();
  inline void set_allocated_accel(::biorobotics::firmware::protos::Vector3* accel);

  // optional .biorobotics.firmware.protos.Vector3 gyro = 27;
  inline bool has_gyro() const;
  inline void clear_gyro();
  static const int kGyroFieldNumber = 27;
  inline const ::biorobotics::firmware::protos::Vector3& gyro() const;
  inline ::biorobotics::firmware::protos::Vector3* mutable_gyro();
  inline ::biorobotics::firmware::protos::Vector3* release_gyro();
  inline void set_allocated_gyro(::biorobotics::firmware::protos::Vector3* gyro);

  // optional .biorobotics.firmware.protos.Vector3 compass = 28;
  inline bool has_compass() const;
  inline void clear_compass();
  static const int kCompassFieldNumber = 28;
  inline const ::biorobotics::firmware::protos::Vector3& compass() const;
  inline ::biorobotics::firmware::protos::Vector3* mutable_compass();
  inline ::biorobotics::firmware::protos::Vector3* release_compass();
  inline void set_allocated_compass(::biorobotics::firmware::protos::Vector3* compass);

  // optional float motor_current = 40;
  inline bool has_motor_current() const;
  inline void clear_motor_current();
  static const int kMotorCurrentFieldNumber = 40;
  inline float motor_current() const;
  inline void set_motor_current(float value);

  // optional float module_current = 41;
  inline bool has_module_current() const;
  inline void clear_module_current();
  static const int kModuleCurrentFieldNumber = 41;
  inline float module_current() const;
  inline void set_module_current(float value);

  // optional float motor_temperature = 60;
  inline bool has_motor_temperature() const;
  inline void clear_motor_temperature();
  static const int kMotorTemperatureFieldNumber = 60;
  inline float motor_temperature() const;
  inline void set_motor_temperature(float value);

  // optional float ambient_temperature = 61;
  inline bool has_ambient_temperature() const;
  inline void clear_ambient_temperature();
  static const int kAmbientTemperatureFieldNumber = 61;
  inline float ambient_temperature() const;
  inline void set_ambient_temperature(float value);

  // optional float processor_temperature = 62;
  inline bool has_processor_temperature() const;
  inline void clear_processor_temperature();
  static const int kProcessorTemperatureFieldNumber = 62;
  inline float processor_temperature() const;
  inline void set_processor_temperature(float value);

  // optional float actuator_temperature = 63;
  inline bool has_actuator_temperature() const;
  inline void clear_actuator_temperature();
  static const int kActuatorTemperatureFieldNumber = 63;
  inline float actuator_temperature() const;
  inline void set_actuator_temperature(float value);

  // optional float winding_temperature = 64;
  inline bool has_winding_temperature() const;
  inline void clear_winding_temperature();
  static const int kWindingTemperatureFieldNumber = 64;
  inline float winding_temperature() const;
  inline void set_winding_temperature(float value);

  // optional float pressure = 80;
  inline bool has_pressure() const;
  inline void clear_pressure();
  static const int kPressureFieldNumber = 80;
  inline float pressure() const;
  inline void set_pressure(float value);

  // optional float voltage = 81;
  inline bool has_voltage() const;
  inline void clear_voltage();
  static const int kVoltageFieldNumber = 81;
  inline float voltage() const;
  inline void set_voltage(float value);

  // @@protoc_insertion_point(class_scope:biorobotics.firmware.protos.Feedback)
 private:
  inline void set_has_led();
  inline void clear_has_led();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_torque();
  inline void clear_has_torque();
  inline void set_has_deflection();
  inline void clear_has_deflection();
  inline void set_has_motor_velocity();
  inline void clear_has_motor_velocity();
  inline void set_has_deflection_velocity();
  inline void clear_has_deflection_velocity();
  inline void set_has_accel();
  inline void clear_has_accel();
  inline void set_has_gyro();
  inline void clear_has_gyro();
  inline void set_has_compass();
  inline void clear_has_compass();
  inline void set_has_motor_current();
  inline void clear_has_motor_current();
  inline void set_has_module_current();
  inline void clear_has_module_current();
  inline void set_has_motor_temperature();
  inline void clear_has_motor_temperature();
  inline void set_has_ambient_temperature();
  inline void clear_has_ambient_temperature();
  inline void set_has_processor_temperature();
  inline void clear_has_processor_temperature();
  inline void set_has_actuator_temperature();
  inline void clear_has_actuator_temperature();
  inline void set_has_winding_temperature();
  inline void clear_has_winding_temperature();
  inline void set_has_pressure();
  inline void clear_has_pressure();
  inline void set_has_voltage();
  inline void clear_has_voltage();

  ::biorobotics::firmware::protos::Color* led_;
  float position_;
  float velocity_;
  float torque_;
  float deflection_;
  float motor_velocity_;
  float deflection_velocity_;
  ::biorobotics::firmware::protos::Vector3* accel_;
  ::biorobotics::firmware::protos::Vector3* gyro_;
  ::biorobotics::firmware::protos::Vector3* compass_;
  float motor_current_;
  float module_current_;
  float motor_temperature_;
  float ambient_temperature_;
  float processor_temperature_;
  float actuator_temperature_;
  float winding_temperature_;
  float pressure_;
  float voltage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Control_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Control_2eproto();
  #endif
  friend void protobuf_AssignDesc_Control_2eproto();
  friend void protobuf_ShutdownFile_Control_2eproto();

  void InitAsDefaultInstance();
  static Feedback* default_instance_;
};
// ===================================================================


// ===================================================================

// Command

// optional float position = 1;
inline bool Command::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline float Command::position() const {
  return position_;
}
inline void Command::set_position(float value) {
  set_has_position();
  position_ = value;
}

// optional float velocity = 2;
inline bool Command::has_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
inline float Command::velocity() const {
  return velocity_;
}
inline void Command::set_velocity(float value) {
  set_has_velocity();
  velocity_ = value;
}

// optional float torque = 3;
inline bool Command::has_torque() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command::set_has_torque() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command::clear_has_torque() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command::clear_torque() {
  torque_ = 0;
  clear_has_torque();
}
inline float Command::torque() const {
  return torque_;
}
inline void Command::set_torque(float value) {
  set_has_torque();
  torque_ = value;
}

// optional float pwm = 8;
inline bool Command::has_pwm() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command::set_has_pwm() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command::clear_has_pwm() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command::clear_pwm() {
  pwm_ = 0;
  clear_has_pwm();
}
inline float Command::pwm() const {
  return pwm_;
}
inline void Command::set_pwm(float value) {
  set_has_pwm();
  pwm_ = value;
}

// optional float inner_torque = 9;
inline bool Command::has_inner_torque() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Command::set_has_inner_torque() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Command::clear_has_inner_torque() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Command::clear_inner_torque() {
  inner_torque_ = 0;
  clear_has_inner_torque();
}
inline float Command::inner_torque() const {
  return inner_torque_;
}
inline void Command::set_inner_torque(float value) {
  set_has_inner_torque();
  inner_torque_ = value;
}

// optional .biorobotics.firmware.protos.Color led = 10;
inline bool Command::has_led() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Command::set_has_led() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Command::clear_has_led() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Command::clear_led() {
  if (led_ != NULL) led_->::biorobotics::firmware::protos::Color::Clear();
  clear_has_led();
}
inline const ::biorobotics::firmware::protos::Color& Command::led() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return led_ != NULL ? *led_ : *default_instance().led_;
#else
  return led_ != NULL ? *led_ : *default_instance_->led_;
#endif
}
inline ::biorobotics::firmware::protos::Color* Command::mutable_led() {
  set_has_led();
  if (led_ == NULL) led_ = new ::biorobotics::firmware::protos::Color;
  return led_;
}
inline ::biorobotics::firmware::protos::Color* Command::release_led() {
  clear_has_led();
  ::biorobotics::firmware::protos::Color* temp = led_;
  led_ = NULL;
  return temp;
}
inline void Command::set_allocated_led(::biorobotics::firmware::protos::Color* led) {
  delete led_;
  led_ = led;
  if (led) {
    set_has_led();
  } else {
    clear_has_led();
  }
}

// -------------------------------------------------------------------

// Feedback

// optional .biorobotics.firmware.protos.Color led = 10;
inline bool Feedback::has_led() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Feedback::set_has_led() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Feedback::clear_has_led() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Feedback::clear_led() {
  if (led_ != NULL) led_->::biorobotics::firmware::protos::Color::Clear();
  clear_has_led();
}
inline const ::biorobotics::firmware::protos::Color& Feedback::led() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return led_ != NULL ? *led_ : *default_instance().led_;
#else
  return led_ != NULL ? *led_ : *default_instance_->led_;
#endif
}
inline ::biorobotics::firmware::protos::Color* Feedback::mutable_led() {
  set_has_led();
  if (led_ == NULL) led_ = new ::biorobotics::firmware::protos::Color;
  return led_;
}
inline ::biorobotics::firmware::protos::Color* Feedback::release_led() {
  clear_has_led();
  ::biorobotics::firmware::protos::Color* temp = led_;
  led_ = NULL;
  return temp;
}
inline void Feedback::set_allocated_led(::biorobotics::firmware::protos::Color* led) {
  delete led_;
  led_ = led;
  if (led) {
    set_has_led();
  } else {
    clear_has_led();
  }
}

// optional float position = 1;
inline bool Feedback::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Feedback::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Feedback::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Feedback::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline float Feedback::position() const {
  return position_;
}
inline void Feedback::set_position(float value) {
  set_has_position();
  position_ = value;
}

// optional float velocity = 2;
inline bool Feedback::has_velocity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Feedback::set_has_velocity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Feedback::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Feedback::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
inline float Feedback::velocity() const {
  return velocity_;
}
inline void Feedback::set_velocity(float value) {
  set_has_velocity();
  velocity_ = value;
}

// optional float torque = 3;
inline bool Feedback::has_torque() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Feedback::set_has_torque() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Feedback::clear_has_torque() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Feedback::clear_torque() {
  torque_ = 0;
  clear_has_torque();
}
inline float Feedback::torque() const {
  return torque_;
}
inline void Feedback::set_torque(float value) {
  set_has_torque();
  torque_ = value;
}

// optional float deflection = 4;
inline bool Feedback::has_deflection() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Feedback::set_has_deflection() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Feedback::clear_has_deflection() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Feedback::clear_deflection() {
  deflection_ = 0;
  clear_has_deflection();
}
inline float Feedback::deflection() const {
  return deflection_;
}
inline void Feedback::set_deflection(float value) {
  set_has_deflection();
  deflection_ = value;
}

// optional float motor_velocity = 5;
inline bool Feedback::has_motor_velocity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Feedback::set_has_motor_velocity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Feedback::clear_has_motor_velocity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Feedback::clear_motor_velocity() {
  motor_velocity_ = 0;
  clear_has_motor_velocity();
}
inline float Feedback::motor_velocity() const {
  return motor_velocity_;
}
inline void Feedback::set_motor_velocity(float value) {
  set_has_motor_velocity();
  motor_velocity_ = value;
}

// optional float deflection_velocity = 6;
inline bool Feedback::has_deflection_velocity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Feedback::set_has_deflection_velocity() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Feedback::clear_has_deflection_velocity() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Feedback::clear_deflection_velocity() {
  deflection_velocity_ = 0;
  clear_has_deflection_velocity();
}
inline float Feedback::deflection_velocity() const {
  return deflection_velocity_;
}
inline void Feedback::set_deflection_velocity(float value) {
  set_has_deflection_velocity();
  deflection_velocity_ = value;
}

// optional .biorobotics.firmware.protos.Vector3 accel = 26;
inline bool Feedback::has_accel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Feedback::set_has_accel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Feedback::clear_has_accel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Feedback::clear_accel() {
  if (accel_ != NULL) accel_->::biorobotics::firmware::protos::Vector3::Clear();
  clear_has_accel();
}
inline const ::biorobotics::firmware::protos::Vector3& Feedback::accel() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return accel_ != NULL ? *accel_ : *default_instance().accel_;
#else
  return accel_ != NULL ? *accel_ : *default_instance_->accel_;
#endif
}
inline ::biorobotics::firmware::protos::Vector3* Feedback::mutable_accel() {
  set_has_accel();
  if (accel_ == NULL) accel_ = new ::biorobotics::firmware::protos::Vector3;
  return accel_;
}
inline ::biorobotics::firmware::protos::Vector3* Feedback::release_accel() {
  clear_has_accel();
  ::biorobotics::firmware::protos::Vector3* temp = accel_;
  accel_ = NULL;
  return temp;
}
inline void Feedback::set_allocated_accel(::biorobotics::firmware::protos::Vector3* accel) {
  delete accel_;
  accel_ = accel;
  if (accel) {
    set_has_accel();
  } else {
    clear_has_accel();
  }
}

// optional .biorobotics.firmware.protos.Vector3 gyro = 27;
inline bool Feedback::has_gyro() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Feedback::set_has_gyro() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Feedback::clear_has_gyro() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Feedback::clear_gyro() {
  if (gyro_ != NULL) gyro_->::biorobotics::firmware::protos::Vector3::Clear();
  clear_has_gyro();
}
inline const ::biorobotics::firmware::protos::Vector3& Feedback::gyro() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gyro_ != NULL ? *gyro_ : *default_instance().gyro_;
#else
  return gyro_ != NULL ? *gyro_ : *default_instance_->gyro_;
#endif
}
inline ::biorobotics::firmware::protos::Vector3* Feedback::mutable_gyro() {
  set_has_gyro();
  if (gyro_ == NULL) gyro_ = new ::biorobotics::firmware::protos::Vector3;
  return gyro_;
}
inline ::biorobotics::firmware::protos::Vector3* Feedback::release_gyro() {
  clear_has_gyro();
  ::biorobotics::firmware::protos::Vector3* temp = gyro_;
  gyro_ = NULL;
  return temp;
}
inline void Feedback::set_allocated_gyro(::biorobotics::firmware::protos::Vector3* gyro) {
  delete gyro_;
  gyro_ = gyro;
  if (gyro) {
    set_has_gyro();
  } else {
    clear_has_gyro();
  }
}

// optional .biorobotics.firmware.protos.Vector3 compass = 28;
inline bool Feedback::has_compass() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Feedback::set_has_compass() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Feedback::clear_has_compass() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Feedback::clear_compass() {
  if (compass_ != NULL) compass_->::biorobotics::firmware::protos::Vector3::Clear();
  clear_has_compass();
}
inline const ::biorobotics::firmware::protos::Vector3& Feedback::compass() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return compass_ != NULL ? *compass_ : *default_instance().compass_;
#else
  return compass_ != NULL ? *compass_ : *default_instance_->compass_;
#endif
}
inline ::biorobotics::firmware::protos::Vector3* Feedback::mutable_compass() {
  set_has_compass();
  if (compass_ == NULL) compass_ = new ::biorobotics::firmware::protos::Vector3;
  return compass_;
}
inline ::biorobotics::firmware::protos::Vector3* Feedback::release_compass() {
  clear_has_compass();
  ::biorobotics::firmware::protos::Vector3* temp = compass_;
  compass_ = NULL;
  return temp;
}
inline void Feedback::set_allocated_compass(::biorobotics::firmware::protos::Vector3* compass) {
  delete compass_;
  compass_ = compass;
  if (compass) {
    set_has_compass();
  } else {
    clear_has_compass();
  }
}

// optional float motor_current = 40;
inline bool Feedback::has_motor_current() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Feedback::set_has_motor_current() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Feedback::clear_has_motor_current() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Feedback::clear_motor_current() {
  motor_current_ = 0;
  clear_has_motor_current();
}
inline float Feedback::motor_current() const {
  return motor_current_;
}
inline void Feedback::set_motor_current(float value) {
  set_has_motor_current();
  motor_current_ = value;
}

// optional float module_current = 41;
inline bool Feedback::has_module_current() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Feedback::set_has_module_current() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Feedback::clear_has_module_current() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Feedback::clear_module_current() {
  module_current_ = 0;
  clear_has_module_current();
}
inline float Feedback::module_current() const {
  return module_current_;
}
inline void Feedback::set_module_current(float value) {
  set_has_module_current();
  module_current_ = value;
}

// optional float motor_temperature = 60;
inline bool Feedback::has_motor_temperature() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Feedback::set_has_motor_temperature() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Feedback::clear_has_motor_temperature() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Feedback::clear_motor_temperature() {
  motor_temperature_ = 0;
  clear_has_motor_temperature();
}
inline float Feedback::motor_temperature() const {
  return motor_temperature_;
}
inline void Feedback::set_motor_temperature(float value) {
  set_has_motor_temperature();
  motor_temperature_ = value;
}

// optional float ambient_temperature = 61;
inline bool Feedback::has_ambient_temperature() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Feedback::set_has_ambient_temperature() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Feedback::clear_has_ambient_temperature() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Feedback::clear_ambient_temperature() {
  ambient_temperature_ = 0;
  clear_has_ambient_temperature();
}
inline float Feedback::ambient_temperature() const {
  return ambient_temperature_;
}
inline void Feedback::set_ambient_temperature(float value) {
  set_has_ambient_temperature();
  ambient_temperature_ = value;
}

// optional float processor_temperature = 62;
inline bool Feedback::has_processor_temperature() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Feedback::set_has_processor_temperature() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Feedback::clear_has_processor_temperature() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Feedback::clear_processor_temperature() {
  processor_temperature_ = 0;
  clear_has_processor_temperature();
}
inline float Feedback::processor_temperature() const {
  return processor_temperature_;
}
inline void Feedback::set_processor_temperature(float value) {
  set_has_processor_temperature();
  processor_temperature_ = value;
}

// optional float actuator_temperature = 63;
inline bool Feedback::has_actuator_temperature() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Feedback::set_has_actuator_temperature() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Feedback::clear_has_actuator_temperature() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Feedback::clear_actuator_temperature() {
  actuator_temperature_ = 0;
  clear_has_actuator_temperature();
}
inline float Feedback::actuator_temperature() const {
  return actuator_temperature_;
}
inline void Feedback::set_actuator_temperature(float value) {
  set_has_actuator_temperature();
  actuator_temperature_ = value;
}

// optional float winding_temperature = 64;
inline bool Feedback::has_winding_temperature() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Feedback::set_has_winding_temperature() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Feedback::clear_has_winding_temperature() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Feedback::clear_winding_temperature() {
  winding_temperature_ = 0;
  clear_has_winding_temperature();
}
inline float Feedback::winding_temperature() const {
  return winding_temperature_;
}
inline void Feedback::set_winding_temperature(float value) {
  set_has_winding_temperature();
  winding_temperature_ = value;
}

// optional float pressure = 80;
inline bool Feedback::has_pressure() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Feedback::set_has_pressure() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Feedback::clear_has_pressure() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Feedback::clear_pressure() {
  pressure_ = 0;
  clear_has_pressure();
}
inline float Feedback::pressure() const {
  return pressure_;
}
inline void Feedback::set_pressure(float value) {
  set_has_pressure();
  pressure_ = value;
}

// optional float voltage = 81;
inline bool Feedback::has_voltage() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Feedback::set_has_voltage() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Feedback::clear_has_voltage() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Feedback::clear_voltage() {
  voltage_ = 0;
  clear_has_voltage();
}
inline float Feedback::voltage() const {
  return voltage_;
}
inline void Feedback::set_voltage(float value) {
  set_has_voltage();
  voltage_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace firmware
}  // namespace biorobotics

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Control_2eproto__INCLUDED
