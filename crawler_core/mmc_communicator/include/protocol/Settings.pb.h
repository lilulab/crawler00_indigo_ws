// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Settings.proto

#ifndef PROTOBUF_Settings_2eproto__INCLUDED
#define PROTOBUF_Settings_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace biorobotics {
namespace firmware {
namespace protos {
namespace settings {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Settings_2eproto();
void protobuf_AssignDesc_Settings_2eproto();
void protobuf_ShutdownFile_Settings_2eproto();

class Pid;
class Controller;
class Imu;
class EncoderFilter;
class SpringModel;
class ThermalModel;
class SafetyLimits;
class Name;
class Settings;

enum Controller_ControlStrategy {
  Controller_ControlStrategy_OFF = 1,
  Controller_ControlStrategy_CASCADED_INNER_TORQUE = 2,
  Controller_ControlStrategy_CASCADED_OUTER_TORQUE = 3,
  Controller_ControlStrategy_DIRECT_PWM = 4
};
bool Controller_ControlStrategy_IsValid(int value);
const Controller_ControlStrategy Controller_ControlStrategy_ControlStrategy_MIN = Controller_ControlStrategy_OFF;
const Controller_ControlStrategy Controller_ControlStrategy_ControlStrategy_MAX = Controller_ControlStrategy_DIRECT_PWM;
const int Controller_ControlStrategy_ControlStrategy_ARRAYSIZE = Controller_ControlStrategy_ControlStrategy_MAX + 1;

enum Imu_AccelScale {
  Imu_AccelScale_G_2 = 2,
  Imu_AccelScale_G_4 = 4,
  Imu_AccelScale_G_8 = 8,
  Imu_AccelScale_G_16 = 16
};
bool Imu_AccelScale_IsValid(int value);
const Imu_AccelScale Imu_AccelScale_AccelScale_MIN = Imu_AccelScale_G_2;
const Imu_AccelScale Imu_AccelScale_AccelScale_MAX = Imu_AccelScale_G_16;
const int Imu_AccelScale_AccelScale_ARRAYSIZE = Imu_AccelScale_AccelScale_MAX + 1;

enum Imu_AccelCutoff {
  Imu_AccelCutoff_Hz_260 = 1,
  Imu_AccelCutoff_Hz_184 = 2,
  Imu_AccelCutoff_Hz_94 = 3,
  Imu_AccelCutoff_Hz_44 = 4,
  Imu_AccelCutoff_Hz_21 = 5,
  Imu_AccelCutoff_Hz_10 = 6,
  Imu_AccelCutoff_Hz_5 = 7
};
bool Imu_AccelCutoff_IsValid(int value);
const Imu_AccelCutoff Imu_AccelCutoff_AccelCutoff_MIN = Imu_AccelCutoff_Hz_260;
const Imu_AccelCutoff Imu_AccelCutoff_AccelCutoff_MAX = Imu_AccelCutoff_Hz_5;
const int Imu_AccelCutoff_AccelCutoff_ARRAYSIZE = Imu_AccelCutoff_AccelCutoff_MAX + 1;

enum Imu_GyroScale {
  Imu_GyroScale_DEG_PER_S_250 = 1,
  Imu_GyroScale_DEG_PER_S_500 = 2,
  Imu_GyroScale_DEG_PER_S_1000 = 3,
  Imu_GyroScale_DEG_PER_S_2000 = 4
};
bool Imu_GyroScale_IsValid(int value);
const Imu_GyroScale Imu_GyroScale_GyroScale_MIN = Imu_GyroScale_DEG_PER_S_250;
const Imu_GyroScale Imu_GyroScale_GyroScale_MAX = Imu_GyroScale_DEG_PER_S_2000;
const int Imu_GyroScale_GyroScale_ARRAYSIZE = Imu_GyroScale_GyroScale_MAX + 1;

// ===================================================================

class Pid : public ::google::protobuf::MessageLite {
 public:
  Pid();
  virtual ~Pid();

  Pid(const Pid& from);

  inline Pid& operator=(const Pid& from) {
    CopyFrom(from);
    return *this;
  }

  static const Pid& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Pid* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Pid* other);

  // implements Message ----------------------------------------------

  Pid* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Pid& from);
  void MergeFrom(const Pid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float kp = 1;
  inline bool has_kp() const;
  inline void clear_kp();
  static const int kKpFieldNumber = 1;
  inline float kp() const;
  inline void set_kp(float value);

  // optional float ki = 2;
  inline bool has_ki() const;
  inline void clear_ki();
  static const int kKiFieldNumber = 2;
  inline float ki() const;
  inline void set_ki(float value);

  // optional float kd = 3;
  inline bool has_kd() const;
  inline void clear_kd();
  static const int kKdFieldNumber = 3;
  inline float kd() const;
  inline void set_kd(float value);

  // optional float ff = 4;
  inline bool has_ff() const;
  inline void clear_ff();
  static const int kFfFieldNumber = 4;
  inline float ff() const;
  inline void set_ff(float value);

  // optional float dead_zone = 5;
  inline bool has_dead_zone() const;
  inline void clear_dead_zone();
  static const int kDeadZoneFieldNumber = 5;
  inline float dead_zone() const;
  inline void set_dead_zone(float value);

  // optional float i_clamp = 6;
  inline bool has_i_clamp() const;
  inline void clear_i_clamp();
  static const int kIClampFieldNumber = 6;
  inline float i_clamp() const;
  inline void set_i_clamp(float value);

  // optional bool enabled = 7;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 7;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // optional float punch = 8;
  inline bool has_punch() const;
  inline void clear_punch();
  static const int kPunchFieldNumber = 8;
  inline float punch() const;
  inline void set_punch(float value);

  // optional float d_window_size = 9;
  inline bool has_d_window_size() const;
  inline void clear_d_window_size();
  static const int kDWindowSizeFieldNumber = 9;
  inline float d_window_size() const;
  inline void set_d_window_size(float value);

  // optional float min_target_value = 15;
  inline bool has_min_target_value() const;
  inline void clear_min_target_value();
  static const int kMinTargetValueFieldNumber = 15;
  inline float min_target_value() const;
  inline void set_min_target_value(float value);

  // optional float max_target_value = 10;
  inline bool has_max_target_value() const;
  inline void clear_max_target_value();
  static const int kMaxTargetValueFieldNumber = 10;
  inline float max_target_value() const;
  inline void set_max_target_value(float value);

  // optional float min_output_value = 16;
  inline bool has_min_output_value() const;
  inline void clear_min_output_value();
  static const int kMinOutputValueFieldNumber = 16;
  inline float min_output_value() const;
  inline void set_min_output_value(float value);

  // optional float max_output_value = 11;
  inline bool has_max_output_value() const;
  inline void clear_max_output_value();
  static const int kMaxOutputValueFieldNumber = 11;
  inline float max_output_value() const;
  inline void set_max_output_value(float value);

  // optional float target_lowpass_gain = 12;
  inline bool has_target_lowpass_gain() const;
  inline void clear_target_lowpass_gain();
  static const int kTargetLowpassGainFieldNumber = 12;
  inline float target_lowpass_gain() const;
  inline void set_target_lowpass_gain(float value);

  // optional float output_lowpass_gain = 13;
  inline bool has_output_lowpass_gain() const;
  inline void clear_output_lowpass_gain();
  static const int kOutputLowpassGainFieldNumber = 13;
  inline float output_lowpass_gain() const;
  inline void set_output_lowpass_gain(float value);

  // optional bool d_on_error = 14;
  inline bool has_d_on_error() const;
  inline void clear_d_on_error();
  static const int kDOnErrorFieldNumber = 14;
  inline bool d_on_error() const;
  inline void set_d_on_error(bool value);

  // @@protoc_insertion_point(class_scope:biorobotics.firmware.protos.settings.Pid)
 private:
  inline void set_has_kp();
  inline void clear_has_kp();
  inline void set_has_ki();
  inline void clear_has_ki();
  inline void set_has_kd();
  inline void clear_has_kd();
  inline void set_has_ff();
  inline void clear_has_ff();
  inline void set_has_dead_zone();
  inline void clear_has_dead_zone();
  inline void set_has_i_clamp();
  inline void clear_has_i_clamp();
  inline void set_has_enabled();
  inline void clear_has_enabled();
  inline void set_has_punch();
  inline void clear_has_punch();
  inline void set_has_d_window_size();
  inline void clear_has_d_window_size();
  inline void set_has_min_target_value();
  inline void clear_has_min_target_value();
  inline void set_has_max_target_value();
  inline void clear_has_max_target_value();
  inline void set_has_min_output_value();
  inline void clear_has_min_output_value();
  inline void set_has_max_output_value();
  inline void clear_has_max_output_value();
  inline void set_has_target_lowpass_gain();
  inline void clear_has_target_lowpass_gain();
  inline void set_has_output_lowpass_gain();
  inline void clear_has_output_lowpass_gain();
  inline void set_has_d_on_error();
  inline void clear_has_d_on_error();

  float kp_;
  float ki_;
  float kd_;
  float ff_;
  float dead_zone_;
  float i_clamp_;
  float punch_;
  float d_window_size_;
  float min_target_value_;
  float max_target_value_;
  bool enabled_;
  bool d_on_error_;
  float min_output_value_;
  float max_output_value_;
  float target_lowpass_gain_;
  float output_lowpass_gain_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Settings_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Settings_2eproto();
  #endif
  friend void protobuf_AssignDesc_Settings_2eproto();
  friend void protobuf_ShutdownFile_Settings_2eproto();

  void InitAsDefaultInstance();
  static Pid* default_instance_;
};
// -------------------------------------------------------------------

class Controller : public ::google::protobuf::MessageLite {
 public:
  Controller();
  virtual ~Controller();

  Controller(const Controller& from);

  inline Controller& operator=(const Controller& from) {
    CopyFrom(from);
    return *this;
  }

  static const Controller& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Controller* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Controller* other);

  // implements Message ----------------------------------------------

  Controller* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Controller& from);
  void MergeFrom(const Controller& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Controller_ControlStrategy ControlStrategy;
  static const ControlStrategy OFF = Controller_ControlStrategy_OFF;
  static const ControlStrategy CASCADED_INNER_TORQUE = Controller_ControlStrategy_CASCADED_INNER_TORQUE;
  static const ControlStrategy CASCADED_OUTER_TORQUE = Controller_ControlStrategy_CASCADED_OUTER_TORQUE;
  static const ControlStrategy DIRECT_PWM = Controller_ControlStrategy_DIRECT_PWM;
  static inline bool ControlStrategy_IsValid(int value) {
    return Controller_ControlStrategy_IsValid(value);
  }
  static const ControlStrategy ControlStrategy_MIN =
    Controller_ControlStrategy_ControlStrategy_MIN;
  static const ControlStrategy ControlStrategy_MAX =
    Controller_ControlStrategy_ControlStrategy_MAX;
  static const int ControlStrategy_ARRAYSIZE =
    Controller_ControlStrategy_ControlStrategy_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .biorobotics.firmware.protos.settings.Controller.ControlStrategy strategy = 3;
  inline bool has_strategy() const;
  inline void clear_strategy();
  static const int kStrategyFieldNumber = 3;
  inline ::biorobotics::firmware::protos::settings::Controller_ControlStrategy strategy() const;
  inline void set_strategy(::biorobotics::firmware::protos::settings::Controller_ControlStrategy value);

  // optional uint32 period_msec = 5;
  inline bool has_period_msec() const;
  inline void clear_period_msec();
  static const int kPeriodMsecFieldNumber = 5;
  inline ::google::protobuf::uint32 period_msec() const;
  inline void set_period_msec(::google::protobuf::uint32 value);

  // optional .biorobotics.firmware.protos.settings.Pid position_pid = 6;
  inline bool has_position_pid() const;
  inline void clear_position_pid();
  static const int kPositionPidFieldNumber = 6;
  inline const ::biorobotics::firmware::protos::settings::Pid& position_pid() const;
  inline ::biorobotics::firmware::protos::settings::Pid* mutable_position_pid();
  inline ::biorobotics::firmware::protos::settings::Pid* release_position_pid();
  inline void set_allocated_position_pid(::biorobotics::firmware::protos::settings::Pid* position_pid);

  // optional .biorobotics.firmware.protos.settings.Pid velocity_pid = 7;
  inline bool has_velocity_pid() const;
  inline void clear_velocity_pid();
  static const int kVelocityPidFieldNumber = 7;
  inline const ::biorobotics::firmware::protos::settings::Pid& velocity_pid() const;
  inline ::biorobotics::firmware::protos::settings::Pid* mutable_velocity_pid();
  inline ::biorobotics::firmware::protos::settings::Pid* release_velocity_pid();
  inline void set_allocated_velocity_pid(::biorobotics::firmware::protos::settings::Pid* velocity_pid);

  // optional .biorobotics.firmware.protos.settings.Pid torque_pid = 8;
  inline bool has_torque_pid() const;
  inline void clear_torque_pid();
  static const int kTorquePidFieldNumber = 8;
  inline const ::biorobotics::firmware::protos::settings::Pid& torque_pid() const;
  inline ::biorobotics::firmware::protos::settings::Pid* mutable_torque_pid();
  inline ::biorobotics::firmware::protos::settings::Pid* release_torque_pid();
  inline void set_allocated_torque_pid(::biorobotics::firmware::protos::settings::Pid* torque_pid);

  // @@protoc_insertion_point(class_scope:biorobotics.firmware.protos.settings.Controller)
 private:
  inline void set_has_strategy();
  inline void clear_has_strategy();
  inline void set_has_period_msec();
  inline void clear_has_period_msec();
  inline void set_has_position_pid();
  inline void clear_has_position_pid();
  inline void set_has_velocity_pid();
  inline void clear_has_velocity_pid();
  inline void set_has_torque_pid();
  inline void clear_has_torque_pid();

  int strategy_;
  ::google::protobuf::uint32 period_msec_;
  ::biorobotics::firmware::protos::settings::Pid* position_pid_;
  ::biorobotics::firmware::protos::settings::Pid* velocity_pid_;
  ::biorobotics::firmware::protos::settings::Pid* torque_pid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Settings_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Settings_2eproto();
  #endif
  friend void protobuf_AssignDesc_Settings_2eproto();
  friend void protobuf_ShutdownFile_Settings_2eproto();

  void InitAsDefaultInstance();
  static Controller* default_instance_;
};
// -------------------------------------------------------------------

class Imu : public ::google::protobuf::MessageLite {
 public:
  Imu();
  virtual ~Imu();

  Imu(const Imu& from);

  inline Imu& operator=(const Imu& from) {
    CopyFrom(from);
    return *this;
  }

  static const Imu& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Imu* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Imu* other);

  // implements Message ----------------------------------------------

  Imu* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Imu& from);
  void MergeFrom(const Imu& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Imu_AccelScale AccelScale;
  static const AccelScale G_2 = Imu_AccelScale_G_2;
  static const AccelScale G_4 = Imu_AccelScale_G_4;
  static const AccelScale G_8 = Imu_AccelScale_G_8;
  static const AccelScale G_16 = Imu_AccelScale_G_16;
  static inline bool AccelScale_IsValid(int value) {
    return Imu_AccelScale_IsValid(value);
  }
  static const AccelScale AccelScale_MIN =
    Imu_AccelScale_AccelScale_MIN;
  static const AccelScale AccelScale_MAX =
    Imu_AccelScale_AccelScale_MAX;
  static const int AccelScale_ARRAYSIZE =
    Imu_AccelScale_AccelScale_ARRAYSIZE;

  typedef Imu_AccelCutoff AccelCutoff;
  static const AccelCutoff Hz_260 = Imu_AccelCutoff_Hz_260;
  static const AccelCutoff Hz_184 = Imu_AccelCutoff_Hz_184;
  static const AccelCutoff Hz_94 = Imu_AccelCutoff_Hz_94;
  static const AccelCutoff Hz_44 = Imu_AccelCutoff_Hz_44;
  static const AccelCutoff Hz_21 = Imu_AccelCutoff_Hz_21;
  static const AccelCutoff Hz_10 = Imu_AccelCutoff_Hz_10;
  static const AccelCutoff Hz_5 = Imu_AccelCutoff_Hz_5;
  static inline bool AccelCutoff_IsValid(int value) {
    return Imu_AccelCutoff_IsValid(value);
  }
  static const AccelCutoff AccelCutoff_MIN =
    Imu_AccelCutoff_AccelCutoff_MIN;
  static const AccelCutoff AccelCutoff_MAX =
    Imu_AccelCutoff_AccelCutoff_MAX;
  static const int AccelCutoff_ARRAYSIZE =
    Imu_AccelCutoff_AccelCutoff_ARRAYSIZE;

  typedef Imu_GyroScale GyroScale;
  static const GyroScale DEG_PER_S_250 = Imu_GyroScale_DEG_PER_S_250;
  static const GyroScale DEG_PER_S_500 = Imu_GyroScale_DEG_PER_S_500;
  static const GyroScale DEG_PER_S_1000 = Imu_GyroScale_DEG_PER_S_1000;
  static const GyroScale DEG_PER_S_2000 = Imu_GyroScale_DEG_PER_S_2000;
  static inline bool GyroScale_IsValid(int value) {
    return Imu_GyroScale_IsValid(value);
  }
  static const GyroScale GyroScale_MIN =
    Imu_GyroScale_GyroScale_MIN;
  static const GyroScale GyroScale_MAX =
    Imu_GyroScale_GyroScale_MAX;
  static const int GyroScale_ARRAYSIZE =
    Imu_GyroScale_GyroScale_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .biorobotics.firmware.protos.settings.Imu.AccelScale accel_scale = 10;
  inline bool has_accel_scale() const;
  inline void clear_accel_scale();
  static const int kAccelScaleFieldNumber = 10;
  inline ::biorobotics::firmware::protos::settings::Imu_AccelScale accel_scale() const;
  inline void set_accel_scale(::biorobotics::firmware::protos::settings::Imu_AccelScale value);

  // optional .biorobotics.firmware.protos.settings.Imu.AccelCutoff accel_cutoff = 11;
  inline bool has_accel_cutoff() const;
  inline void clear_accel_cutoff();
  static const int kAccelCutoffFieldNumber = 11;
  inline ::biorobotics::firmware::protos::settings::Imu_AccelCutoff accel_cutoff() const;
  inline void set_accel_cutoff(::biorobotics::firmware::protos::settings::Imu_AccelCutoff value);

  // optional .biorobotics.firmware.protos.settings.Imu.GyroScale gyro_scale = 20;
  inline bool has_gyro_scale() const;
  inline void clear_gyro_scale();
  static const int kGyroScaleFieldNumber = 20;
  inline ::biorobotics::firmware::protos::settings::Imu_GyroScale gyro_scale() const;
  inline void set_gyro_scale(::biorobotics::firmware::protos::settings::Imu_GyroScale value);

  // @@protoc_insertion_point(class_scope:biorobotics.firmware.protos.settings.Imu)
 private:
  inline void set_has_accel_scale();
  inline void clear_has_accel_scale();
  inline void set_has_accel_cutoff();
  inline void clear_has_accel_cutoff();
  inline void set_has_gyro_scale();
  inline void clear_has_gyro_scale();

  int accel_scale_;
  int accel_cutoff_;
  int gyro_scale_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Settings_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Settings_2eproto();
  #endif
  friend void protobuf_AssignDesc_Settings_2eproto();
  friend void protobuf_ShutdownFile_Settings_2eproto();

  void InitAsDefaultInstance();
  static Imu* default_instance_;
};
// -------------------------------------------------------------------

class EncoderFilter : public ::google::protobuf::MessageLite {
 public:
  EncoderFilter();
  virtual ~EncoderFilter();

  EncoderFilter(const EncoderFilter& from);

  inline EncoderFilter& operator=(const EncoderFilter& from) {
    CopyFrom(from);
    return *this;
  }

  static const EncoderFilter& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EncoderFilter* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EncoderFilter* other);

  // implements Message ----------------------------------------------

  EncoderFilter* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EncoderFilter& from);
  void MergeFrom(const EncoderFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float inner_encoder_kalman_gains = 5 [packed = true];
  inline int inner_encoder_kalman_gains_size() const;
  inline void clear_inner_encoder_kalman_gains();
  static const int kInnerEncoderKalmanGainsFieldNumber = 5;
  inline float inner_encoder_kalman_gains(int index) const;
  inline void set_inner_encoder_kalman_gains(int index, float value);
  inline void add_inner_encoder_kalman_gains(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      inner_encoder_kalman_gains() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_inner_encoder_kalman_gains();

  // optional float inner_encoder_accel_damp = 6;
  inline bool has_inner_encoder_accel_damp() const;
  inline void clear_inner_encoder_accel_damp();
  static const int kInnerEncoderAccelDampFieldNumber = 6;
  inline float inner_encoder_accel_damp() const;
  inline void set_inner_encoder_accel_damp(float value);

  // repeated float outer_encoder_kalman_gains = 8 [packed = true];
  inline int outer_encoder_kalman_gains_size() const;
  inline void clear_outer_encoder_kalman_gains();
  static const int kOuterEncoderKalmanGainsFieldNumber = 8;
  inline float outer_encoder_kalman_gains(int index) const;
  inline void set_outer_encoder_kalman_gains(int index, float value);
  inline void add_outer_encoder_kalman_gains(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      outer_encoder_kalman_gains() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_outer_encoder_kalman_gains();

  // optional float outer_encoder_accel_damp = 9;
  inline bool has_outer_encoder_accel_damp() const;
  inline void clear_outer_encoder_accel_damp();
  static const int kOuterEncoderAccelDampFieldNumber = 9;
  inline float outer_encoder_accel_damp() const;
  inline void set_outer_encoder_accel_damp(float value);

  // @@protoc_insertion_point(class_scope:biorobotics.firmware.protos.settings.EncoderFilter)
 private:
  inline void set_has_inner_encoder_accel_damp();
  inline void clear_has_inner_encoder_accel_damp();
  inline void set_has_outer_encoder_accel_damp();
  inline void clear_has_outer_encoder_accel_damp();

  ::google::protobuf::RepeatedField< float > inner_encoder_kalman_gains_;
  mutable int _inner_encoder_kalman_gains_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > outer_encoder_kalman_gains_;
  mutable int _outer_encoder_kalman_gains_cached_byte_size_;
  float inner_encoder_accel_damp_;
  float outer_encoder_accel_damp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Settings_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Settings_2eproto();
  #endif
  friend void protobuf_AssignDesc_Settings_2eproto();
  friend void protobuf_ShutdownFile_Settings_2eproto();

  void InitAsDefaultInstance();
  static EncoderFilter* default_instance_;
};
// -------------------------------------------------------------------

class SpringModel : public ::google::protobuf::MessageLite {
 public:
  SpringModel();
  virtual ~SpringModel();

  SpringModel(const SpringModel& from);

  inline SpringModel& operator=(const SpringModel& from) {
    CopyFrom(from);
    return *this;
  }

  static const SpringModel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SpringModel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SpringModel* other);

  // implements Message ----------------------------------------------

  SpringModel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SpringModel& from);
  void MergeFrom(const SpringModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float spring_constant = 5;
  inline bool has_spring_constant() const;
  inline void clear_spring_constant();
  static const int kSpringConstantFieldNumber = 5;
  inline float spring_constant() const;
  inline void set_spring_constant(float value);

  // @@protoc_insertion_point(class_scope:biorobotics.firmware.protos.settings.SpringModel)
 private:
  inline void set_has_spring_constant();
  inline void clear_has_spring_constant();

  float spring_constant_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Settings_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Settings_2eproto();
  #endif
  friend void protobuf_AssignDesc_Settings_2eproto();
  friend void protobuf_ShutdownFile_Settings_2eproto();

  void InitAsDefaultInstance();
  static SpringModel* default_instance_;
};
// -------------------------------------------------------------------

class ThermalModel : public ::google::protobuf::MessageLite {
 public:
  ThermalModel();
  virtual ~ThermalModel();

  ThermalModel(const ThermalModel& from);

  inline ThermalModel& operator=(const ThermalModel& from) {
    CopyFrom(from);
    return *this;
  }

  static const ThermalModel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ThermalModel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ThermalModel* other);

  // implements Message ----------------------------------------------

  ThermalModel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ThermalModel& from);
  void MergeFrom(const ThermalModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float motor_housing_thermal_resistance = 5;
  inline bool has_motor_housing_thermal_resistance() const;
  inline void clear_motor_housing_thermal_resistance();
  static const int kMotorHousingThermalResistanceFieldNumber = 5;
  inline float motor_housing_thermal_resistance() const;
  inline void set_motor_housing_thermal_resistance(float value);

  // @@protoc_insertion_point(class_scope:biorobotics.firmware.protos.settings.ThermalModel)
 private:
  inline void set_has_motor_housing_thermal_resistance();
  inline void clear_has_motor_housing_thermal_resistance();

  float motor_housing_thermal_resistance_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Settings_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Settings_2eproto();
  #endif
  friend void protobuf_AssignDesc_Settings_2eproto();
  friend void protobuf_ShutdownFile_Settings_2eproto();

  void InitAsDefaultInstance();
  static ThermalModel* default_instance_;
};
// -------------------------------------------------------------------

class SafetyLimits : public ::google::protobuf::MessageLite {
 public:
  SafetyLimits();
  virtual ~SafetyLimits();

  SafetyLimits(const SafetyLimits& from);

  inline SafetyLimits& operator=(const SafetyLimits& from) {
    CopyFrom(from);
    return *this;
  }

  static const SafetyLimits& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SafetyLimits* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SafetyLimits* other);

  // implements Message ----------------------------------------------

  SafetyLimits* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SafetyLimits& from);
  void MergeFrom(const SafetyLimits& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float motor_current_limit = 5;
  inline bool has_motor_current_limit() const;
  inline void clear_motor_current_limit();
  static const int kMotorCurrentLimitFieldNumber = 5;
  inline float motor_current_limit() const;
  inline void set_motor_current_limit(float value);

  // @@protoc_insertion_point(class_scope:biorobotics.firmware.protos.settings.SafetyLimits)
 private:
  inline void set_has_motor_current_limit();
  inline void clear_has_motor_current_limit();

  float motor_current_limit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Settings_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Settings_2eproto();
  #endif
  friend void protobuf_AssignDesc_Settings_2eproto();
  friend void protobuf_ShutdownFile_Settings_2eproto();

  void InitAsDefaultInstance();
  static SafetyLimits* default_instance_;
};
// -------------------------------------------------------------------

class Name : public ::google::protobuf::MessageLite {
 public:
  Name();
  virtual ~Name();

  Name(const Name& from);

  inline Name& operator=(const Name& from) {
    CopyFrom(from);
    return *this;
  }

  static const Name& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Name* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Name* other);

  // implements Message ----------------------------------------------

  Name* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Name& from);
  void MergeFrom(const Name& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string group_name = 2;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 2;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // @@protoc_insertion_point(class_scope:biorobotics.firmware.protos.settings.Name)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_group_name();
  inline void clear_has_group_name();

  ::std::string* name_;
  ::std::string* group_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Settings_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Settings_2eproto();
  #endif
  friend void protobuf_AssignDesc_Settings_2eproto();
  friend void protobuf_ShutdownFile_Settings_2eproto();

  void InitAsDefaultInstance();
  static Name* default_instance_;
};
// -------------------------------------------------------------------

class Settings : public ::google::protobuf::MessageLite {
 public:
  Settings();
  virtual ~Settings();

  Settings(const Settings& from);

  inline Settings& operator=(const Settings& from) {
    CopyFrom(from);
    return *this;
  }

  static const Settings& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Settings* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Settings* other);

  // implements Message ----------------------------------------------

  Settings* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Settings& from);
  void MergeFrom(const Settings& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .biorobotics.firmware.protos.settings.Controller controller = 2;
  inline bool has_controller() const;
  inline void clear_controller();
  static const int kControllerFieldNumber = 2;
  inline const ::biorobotics::firmware::protos::settings::Controller& controller() const;
  inline ::biorobotics::firmware::protos::settings::Controller* mutable_controller();
  inline ::biorobotics::firmware::protos::settings::Controller* release_controller();
  inline void set_allocated_controller(::biorobotics::firmware::protos::settings::Controller* controller);

  // optional .biorobotics.firmware.protos.settings.Imu imu = 3;
  inline bool has_imu() const;
  inline void clear_imu();
  static const int kImuFieldNumber = 3;
  inline const ::biorobotics::firmware::protos::settings::Imu& imu() const;
  inline ::biorobotics::firmware::protos::settings::Imu* mutable_imu();
  inline ::biorobotics::firmware::protos::settings::Imu* release_imu();
  inline void set_allocated_imu(::biorobotics::firmware::protos::settings::Imu* imu);

  // optional .biorobotics.firmware.protos.settings.EncoderFilter encoder_filter = 4;
  inline bool has_encoder_filter() const;
  inline void clear_encoder_filter();
  static const int kEncoderFilterFieldNumber = 4;
  inline const ::biorobotics::firmware::protos::settings::EncoderFilter& encoder_filter() const;
  inline ::biorobotics::firmware::protos::settings::EncoderFilter* mutable_encoder_filter();
  inline ::biorobotics::firmware::protos::settings::EncoderFilter* release_encoder_filter();
  inline void set_allocated_encoder_filter(::biorobotics::firmware::protos::settings::EncoderFilter* encoder_filter);

  // optional .biorobotics.firmware.protos.settings.SpringModel spring_model = 5;
  inline bool has_spring_model() const;
  inline void clear_spring_model();
  static const int kSpringModelFieldNumber = 5;
  inline const ::biorobotics::firmware::protos::settings::SpringModel& spring_model() const;
  inline ::biorobotics::firmware::protos::settings::SpringModel* mutable_spring_model();
  inline ::biorobotics::firmware::protos::settings::SpringModel* release_spring_model();
  inline void set_allocated_spring_model(::biorobotics::firmware::protos::settings::SpringModel* spring_model);

  // optional .biorobotics.firmware.protos.settings.ThermalModel thermal_model = 6;
  inline bool has_thermal_model() const;
  inline void clear_thermal_model();
  static const int kThermalModelFieldNumber = 6;
  inline const ::biorobotics::firmware::protos::settings::ThermalModel& thermal_model() const;
  inline ::biorobotics::firmware::protos::settings::ThermalModel* mutable_thermal_model();
  inline ::biorobotics::firmware::protos::settings::ThermalModel* release_thermal_model();
  inline void set_allocated_thermal_model(::biorobotics::firmware::protos::settings::ThermalModel* thermal_model);

  // optional .biorobotics.firmware.protos.settings.SafetyLimits safety_limits = 7;
  inline bool has_safety_limits() const;
  inline void clear_safety_limits();
  static const int kSafetyLimitsFieldNumber = 7;
  inline const ::biorobotics::firmware::protos::settings::SafetyLimits& safety_limits() const;
  inline ::biorobotics::firmware::protos::settings::SafetyLimits* mutable_safety_limits();
  inline ::biorobotics::firmware::protos::settings::SafetyLimits* release_safety_limits();
  inline void set_allocated_safety_limits(::biorobotics::firmware::protos::settings::SafetyLimits* safety_limits);

  // optional .biorobotics.firmware.protos.settings.Name name = 8;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 8;
  inline const ::biorobotics::firmware::protos::settings::Name& name() const;
  inline ::biorobotics::firmware::protos::settings::Name* mutable_name();
  inline ::biorobotics::firmware::protos::settings::Name* release_name();
  inline void set_allocated_name(::biorobotics::firmware::protos::settings::Name* name);

  // optional bool persist_all = 1001;
  inline bool has_persist_all() const;
  inline void clear_persist_all();
  static const int kPersistAllFieldNumber = 1001;
  inline bool persist_all() const;
  inline void set_persist_all(bool value);

  // @@protoc_insertion_point(class_scope:biorobotics.firmware.protos.settings.Settings)
 private:
  inline void set_has_controller();
  inline void clear_has_controller();
  inline void set_has_imu();
  inline void clear_has_imu();
  inline void set_has_encoder_filter();
  inline void clear_has_encoder_filter();
  inline void set_has_spring_model();
  inline void clear_has_spring_model();
  inline void set_has_thermal_model();
  inline void clear_has_thermal_model();
  inline void set_has_safety_limits();
  inline void clear_has_safety_limits();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_persist_all();
  inline void clear_has_persist_all();

  ::biorobotics::firmware::protos::settings::Controller* controller_;
  ::biorobotics::firmware::protos::settings::Imu* imu_;
  ::biorobotics::firmware::protos::settings::EncoderFilter* encoder_filter_;
  ::biorobotics::firmware::protos::settings::SpringModel* spring_model_;
  ::biorobotics::firmware::protos::settings::ThermalModel* thermal_model_;
  ::biorobotics::firmware::protos::settings::SafetyLimits* safety_limits_;
  ::biorobotics::firmware::protos::settings::Name* name_;
  bool persist_all_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Settings_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Settings_2eproto();
  #endif
  friend void protobuf_AssignDesc_Settings_2eproto();
  friend void protobuf_ShutdownFile_Settings_2eproto();

  void InitAsDefaultInstance();
  static Settings* default_instance_;
};
// ===================================================================


// ===================================================================

// Pid

// optional float kp = 1;
inline bool Pid::has_kp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pid::set_has_kp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pid::clear_has_kp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pid::clear_kp() {
  kp_ = 0;
  clear_has_kp();
}
inline float Pid::kp() const {
  return kp_;
}
inline void Pid::set_kp(float value) {
  set_has_kp();
  kp_ = value;
}

// optional float ki = 2;
inline bool Pid::has_ki() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pid::set_has_ki() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pid::clear_has_ki() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pid::clear_ki() {
  ki_ = 0;
  clear_has_ki();
}
inline float Pid::ki() const {
  return ki_;
}
inline void Pid::set_ki(float value) {
  set_has_ki();
  ki_ = value;
}

// optional float kd = 3;
inline bool Pid::has_kd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Pid::set_has_kd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Pid::clear_has_kd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Pid::clear_kd() {
  kd_ = 0;
  clear_has_kd();
}
inline float Pid::kd() const {
  return kd_;
}
inline void Pid::set_kd(float value) {
  set_has_kd();
  kd_ = value;
}

// optional float ff = 4;
inline bool Pid::has_ff() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Pid::set_has_ff() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Pid::clear_has_ff() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Pid::clear_ff() {
  ff_ = 0;
  clear_has_ff();
}
inline float Pid::ff() const {
  return ff_;
}
inline void Pid::set_ff(float value) {
  set_has_ff();
  ff_ = value;
}

// optional float dead_zone = 5;
inline bool Pid::has_dead_zone() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Pid::set_has_dead_zone() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Pid::clear_has_dead_zone() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Pid::clear_dead_zone() {
  dead_zone_ = 0;
  clear_has_dead_zone();
}
inline float Pid::dead_zone() const {
  return dead_zone_;
}
inline void Pid::set_dead_zone(float value) {
  set_has_dead_zone();
  dead_zone_ = value;
}

// optional float i_clamp = 6;
inline bool Pid::has_i_clamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Pid::set_has_i_clamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Pid::clear_has_i_clamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Pid::clear_i_clamp() {
  i_clamp_ = 0;
  clear_has_i_clamp();
}
inline float Pid::i_clamp() const {
  return i_clamp_;
}
inline void Pid::set_i_clamp(float value) {
  set_has_i_clamp();
  i_clamp_ = value;
}

// optional bool enabled = 7;
inline bool Pid::has_enabled() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Pid::set_has_enabled() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Pid::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Pid::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool Pid::enabled() const {
  return enabled_;
}
inline void Pid::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// optional float punch = 8;
inline bool Pid::has_punch() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Pid::set_has_punch() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Pid::clear_has_punch() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Pid::clear_punch() {
  punch_ = 0;
  clear_has_punch();
}
inline float Pid::punch() const {
  return punch_;
}
inline void Pid::set_punch(float value) {
  set_has_punch();
  punch_ = value;
}

// optional float d_window_size = 9;
inline bool Pid::has_d_window_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Pid::set_has_d_window_size() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Pid::clear_has_d_window_size() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Pid::clear_d_window_size() {
  d_window_size_ = 0;
  clear_has_d_window_size();
}
inline float Pid::d_window_size() const {
  return d_window_size_;
}
inline void Pid::set_d_window_size(float value) {
  set_has_d_window_size();
  d_window_size_ = value;
}

// optional float min_target_value = 15;
inline bool Pid::has_min_target_value() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Pid::set_has_min_target_value() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Pid::clear_has_min_target_value() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Pid::clear_min_target_value() {
  min_target_value_ = 0;
  clear_has_min_target_value();
}
inline float Pid::min_target_value() const {
  return min_target_value_;
}
inline void Pid::set_min_target_value(float value) {
  set_has_min_target_value();
  min_target_value_ = value;
}

// optional float max_target_value = 10;
inline bool Pid::has_max_target_value() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Pid::set_has_max_target_value() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Pid::clear_has_max_target_value() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Pid::clear_max_target_value() {
  max_target_value_ = 0;
  clear_has_max_target_value();
}
inline float Pid::max_target_value() const {
  return max_target_value_;
}
inline void Pid::set_max_target_value(float value) {
  set_has_max_target_value();
  max_target_value_ = value;
}

// optional float min_output_value = 16;
inline bool Pid::has_min_output_value() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Pid::set_has_min_output_value() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Pid::clear_has_min_output_value() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Pid::clear_min_output_value() {
  min_output_value_ = 0;
  clear_has_min_output_value();
}
inline float Pid::min_output_value() const {
  return min_output_value_;
}
inline void Pid::set_min_output_value(float value) {
  set_has_min_output_value();
  min_output_value_ = value;
}

// optional float max_output_value = 11;
inline bool Pid::has_max_output_value() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Pid::set_has_max_output_value() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Pid::clear_has_max_output_value() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Pid::clear_max_output_value() {
  max_output_value_ = 0;
  clear_has_max_output_value();
}
inline float Pid::max_output_value() const {
  return max_output_value_;
}
inline void Pid::set_max_output_value(float value) {
  set_has_max_output_value();
  max_output_value_ = value;
}

// optional float target_lowpass_gain = 12;
inline bool Pid::has_target_lowpass_gain() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Pid::set_has_target_lowpass_gain() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Pid::clear_has_target_lowpass_gain() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Pid::clear_target_lowpass_gain() {
  target_lowpass_gain_ = 0;
  clear_has_target_lowpass_gain();
}
inline float Pid::target_lowpass_gain() const {
  return target_lowpass_gain_;
}
inline void Pid::set_target_lowpass_gain(float value) {
  set_has_target_lowpass_gain();
  target_lowpass_gain_ = value;
}

// optional float output_lowpass_gain = 13;
inline bool Pid::has_output_lowpass_gain() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Pid::set_has_output_lowpass_gain() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Pid::clear_has_output_lowpass_gain() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Pid::clear_output_lowpass_gain() {
  output_lowpass_gain_ = 0;
  clear_has_output_lowpass_gain();
}
inline float Pid::output_lowpass_gain() const {
  return output_lowpass_gain_;
}
inline void Pid::set_output_lowpass_gain(float value) {
  set_has_output_lowpass_gain();
  output_lowpass_gain_ = value;
}

// optional bool d_on_error = 14;
inline bool Pid::has_d_on_error() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Pid::set_has_d_on_error() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Pid::clear_has_d_on_error() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Pid::clear_d_on_error() {
  d_on_error_ = false;
  clear_has_d_on_error();
}
inline bool Pid::d_on_error() const {
  return d_on_error_;
}
inline void Pid::set_d_on_error(bool value) {
  set_has_d_on_error();
  d_on_error_ = value;
}

// -------------------------------------------------------------------

// Controller

// optional .biorobotics.firmware.protos.settings.Controller.ControlStrategy strategy = 3;
inline bool Controller::has_strategy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Controller::set_has_strategy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Controller::clear_has_strategy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Controller::clear_strategy() {
  strategy_ = 1;
  clear_has_strategy();
}
inline ::biorobotics::firmware::protos::settings::Controller_ControlStrategy Controller::strategy() const {
  return static_cast< ::biorobotics::firmware::protos::settings::Controller_ControlStrategy >(strategy_);
}
inline void Controller::set_strategy(::biorobotics::firmware::protos::settings::Controller_ControlStrategy value) {
  assert(::biorobotics::firmware::protos::settings::Controller_ControlStrategy_IsValid(value));
  set_has_strategy();
  strategy_ = value;
}

// optional uint32 period_msec = 5;
inline bool Controller::has_period_msec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Controller::set_has_period_msec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Controller::clear_has_period_msec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Controller::clear_period_msec() {
  period_msec_ = 0u;
  clear_has_period_msec();
}
inline ::google::protobuf::uint32 Controller::period_msec() const {
  return period_msec_;
}
inline void Controller::set_period_msec(::google::protobuf::uint32 value) {
  set_has_period_msec();
  period_msec_ = value;
}

// optional .biorobotics.firmware.protos.settings.Pid position_pid = 6;
inline bool Controller::has_position_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Controller::set_has_position_pid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Controller::clear_has_position_pid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Controller::clear_position_pid() {
  if (position_pid_ != NULL) position_pid_->::biorobotics::firmware::protos::settings::Pid::Clear();
  clear_has_position_pid();
}
inline const ::biorobotics::firmware::protos::settings::Pid& Controller::position_pid() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return position_pid_ != NULL ? *position_pid_ : *default_instance().position_pid_;
#else
  return position_pid_ != NULL ? *position_pid_ : *default_instance_->position_pid_;
#endif
}
inline ::biorobotics::firmware::protos::settings::Pid* Controller::mutable_position_pid() {
  set_has_position_pid();
  if (position_pid_ == NULL) position_pid_ = new ::biorobotics::firmware::protos::settings::Pid;
  return position_pid_;
}
inline ::biorobotics::firmware::protos::settings::Pid* Controller::release_position_pid() {
  clear_has_position_pid();
  ::biorobotics::firmware::protos::settings::Pid* temp = position_pid_;
  position_pid_ = NULL;
  return temp;
}
inline void Controller::set_allocated_position_pid(::biorobotics::firmware::protos::settings::Pid* position_pid) {
  delete position_pid_;
  position_pid_ = position_pid;
  if (position_pid) {
    set_has_position_pid();
  } else {
    clear_has_position_pid();
  }
}

// optional .biorobotics.firmware.protos.settings.Pid velocity_pid = 7;
inline bool Controller::has_velocity_pid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Controller::set_has_velocity_pid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Controller::clear_has_velocity_pid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Controller::clear_velocity_pid() {
  if (velocity_pid_ != NULL) velocity_pid_->::biorobotics::firmware::protos::settings::Pid::Clear();
  clear_has_velocity_pid();
}
inline const ::biorobotics::firmware::protos::settings::Pid& Controller::velocity_pid() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return velocity_pid_ != NULL ? *velocity_pid_ : *default_instance().velocity_pid_;
#else
  return velocity_pid_ != NULL ? *velocity_pid_ : *default_instance_->velocity_pid_;
#endif
}
inline ::biorobotics::firmware::protos::settings::Pid* Controller::mutable_velocity_pid() {
  set_has_velocity_pid();
  if (velocity_pid_ == NULL) velocity_pid_ = new ::biorobotics::firmware::protos::settings::Pid;
  return velocity_pid_;
}
inline ::biorobotics::firmware::protos::settings::Pid* Controller::release_velocity_pid() {
  clear_has_velocity_pid();
  ::biorobotics::firmware::protos::settings::Pid* temp = velocity_pid_;
  velocity_pid_ = NULL;
  return temp;
}
inline void Controller::set_allocated_velocity_pid(::biorobotics::firmware::protos::settings::Pid* velocity_pid) {
  delete velocity_pid_;
  velocity_pid_ = velocity_pid;
  if (velocity_pid) {
    set_has_velocity_pid();
  } else {
    clear_has_velocity_pid();
  }
}

// optional .biorobotics.firmware.protos.settings.Pid torque_pid = 8;
inline bool Controller::has_torque_pid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Controller::set_has_torque_pid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Controller::clear_has_torque_pid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Controller::clear_torque_pid() {
  if (torque_pid_ != NULL) torque_pid_->::biorobotics::firmware::protos::settings::Pid::Clear();
  clear_has_torque_pid();
}
inline const ::biorobotics::firmware::protos::settings::Pid& Controller::torque_pid() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return torque_pid_ != NULL ? *torque_pid_ : *default_instance().torque_pid_;
#else
  return torque_pid_ != NULL ? *torque_pid_ : *default_instance_->torque_pid_;
#endif
}
inline ::biorobotics::firmware::protos::settings::Pid* Controller::mutable_torque_pid() {
  set_has_torque_pid();
  if (torque_pid_ == NULL) torque_pid_ = new ::biorobotics::firmware::protos::settings::Pid;
  return torque_pid_;
}
inline ::biorobotics::firmware::protos::settings::Pid* Controller::release_torque_pid() {
  clear_has_torque_pid();
  ::biorobotics::firmware::protos::settings::Pid* temp = torque_pid_;
  torque_pid_ = NULL;
  return temp;
}
inline void Controller::set_allocated_torque_pid(::biorobotics::firmware::protos::settings::Pid* torque_pid) {
  delete torque_pid_;
  torque_pid_ = torque_pid;
  if (torque_pid) {
    set_has_torque_pid();
  } else {
    clear_has_torque_pid();
  }
}

// -------------------------------------------------------------------

// Imu

// optional .biorobotics.firmware.protos.settings.Imu.AccelScale accel_scale = 10;
inline bool Imu::has_accel_scale() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Imu::set_has_accel_scale() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Imu::clear_has_accel_scale() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Imu::clear_accel_scale() {
  accel_scale_ = 2;
  clear_has_accel_scale();
}
inline ::biorobotics::firmware::protos::settings::Imu_AccelScale Imu::accel_scale() const {
  return static_cast< ::biorobotics::firmware::protos::settings::Imu_AccelScale >(accel_scale_);
}
inline void Imu::set_accel_scale(::biorobotics::firmware::protos::settings::Imu_AccelScale value) {
  assert(::biorobotics::firmware::protos::settings::Imu_AccelScale_IsValid(value));
  set_has_accel_scale();
  accel_scale_ = value;
}

// optional .biorobotics.firmware.protos.settings.Imu.AccelCutoff accel_cutoff = 11;
inline bool Imu::has_accel_cutoff() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Imu::set_has_accel_cutoff() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Imu::clear_has_accel_cutoff() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Imu::clear_accel_cutoff() {
  accel_cutoff_ = 1;
  clear_has_accel_cutoff();
}
inline ::biorobotics::firmware::protos::settings::Imu_AccelCutoff Imu::accel_cutoff() const {
  return static_cast< ::biorobotics::firmware::protos::settings::Imu_AccelCutoff >(accel_cutoff_);
}
inline void Imu::set_accel_cutoff(::biorobotics::firmware::protos::settings::Imu_AccelCutoff value) {
  assert(::biorobotics::firmware::protos::settings::Imu_AccelCutoff_IsValid(value));
  set_has_accel_cutoff();
  accel_cutoff_ = value;
}

// optional .biorobotics.firmware.protos.settings.Imu.GyroScale gyro_scale = 20;
inline bool Imu::has_gyro_scale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Imu::set_has_gyro_scale() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Imu::clear_has_gyro_scale() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Imu::clear_gyro_scale() {
  gyro_scale_ = 1;
  clear_has_gyro_scale();
}
inline ::biorobotics::firmware::protos::settings::Imu_GyroScale Imu::gyro_scale() const {
  return static_cast< ::biorobotics::firmware::protos::settings::Imu_GyroScale >(gyro_scale_);
}
inline void Imu::set_gyro_scale(::biorobotics::firmware::protos::settings::Imu_GyroScale value) {
  assert(::biorobotics::firmware::protos::settings::Imu_GyroScale_IsValid(value));
  set_has_gyro_scale();
  gyro_scale_ = value;
}

// -------------------------------------------------------------------

// EncoderFilter

// repeated float inner_encoder_kalman_gains = 5 [packed = true];
inline int EncoderFilter::inner_encoder_kalman_gains_size() const {
  return inner_encoder_kalman_gains_.size();
}
inline void EncoderFilter::clear_inner_encoder_kalman_gains() {
  inner_encoder_kalman_gains_.Clear();
}
inline float EncoderFilter::inner_encoder_kalman_gains(int index) const {
  return inner_encoder_kalman_gains_.Get(index);
}
inline void EncoderFilter::set_inner_encoder_kalman_gains(int index, float value) {
  inner_encoder_kalman_gains_.Set(index, value);
}
inline void EncoderFilter::add_inner_encoder_kalman_gains(float value) {
  inner_encoder_kalman_gains_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
EncoderFilter::inner_encoder_kalman_gains() const {
  return inner_encoder_kalman_gains_;
}
inline ::google::protobuf::RepeatedField< float >*
EncoderFilter::mutable_inner_encoder_kalman_gains() {
  return &inner_encoder_kalman_gains_;
}

// optional float inner_encoder_accel_damp = 6;
inline bool EncoderFilter::has_inner_encoder_accel_damp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EncoderFilter::set_has_inner_encoder_accel_damp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EncoderFilter::clear_has_inner_encoder_accel_damp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EncoderFilter::clear_inner_encoder_accel_damp() {
  inner_encoder_accel_damp_ = 0;
  clear_has_inner_encoder_accel_damp();
}
inline float EncoderFilter::inner_encoder_accel_damp() const {
  return inner_encoder_accel_damp_;
}
inline void EncoderFilter::set_inner_encoder_accel_damp(float value) {
  set_has_inner_encoder_accel_damp();
  inner_encoder_accel_damp_ = value;
}

// repeated float outer_encoder_kalman_gains = 8 [packed = true];
inline int EncoderFilter::outer_encoder_kalman_gains_size() const {
  return outer_encoder_kalman_gains_.size();
}
inline void EncoderFilter::clear_outer_encoder_kalman_gains() {
  outer_encoder_kalman_gains_.Clear();
}
inline float EncoderFilter::outer_encoder_kalman_gains(int index) const {
  return outer_encoder_kalman_gains_.Get(index);
}
inline void EncoderFilter::set_outer_encoder_kalman_gains(int index, float value) {
  outer_encoder_kalman_gains_.Set(index, value);
}
inline void EncoderFilter::add_outer_encoder_kalman_gains(float value) {
  outer_encoder_kalman_gains_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
EncoderFilter::outer_encoder_kalman_gains() const {
  return outer_encoder_kalman_gains_;
}
inline ::google::protobuf::RepeatedField< float >*
EncoderFilter::mutable_outer_encoder_kalman_gains() {
  return &outer_encoder_kalman_gains_;
}

// optional float outer_encoder_accel_damp = 9;
inline bool EncoderFilter::has_outer_encoder_accel_damp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EncoderFilter::set_has_outer_encoder_accel_damp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EncoderFilter::clear_has_outer_encoder_accel_damp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EncoderFilter::clear_outer_encoder_accel_damp() {
  outer_encoder_accel_damp_ = 0;
  clear_has_outer_encoder_accel_damp();
}
inline float EncoderFilter::outer_encoder_accel_damp() const {
  return outer_encoder_accel_damp_;
}
inline void EncoderFilter::set_outer_encoder_accel_damp(float value) {
  set_has_outer_encoder_accel_damp();
  outer_encoder_accel_damp_ = value;
}

// -------------------------------------------------------------------

// SpringModel

// optional float spring_constant = 5;
inline bool SpringModel::has_spring_constant() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpringModel::set_has_spring_constant() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpringModel::clear_has_spring_constant() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpringModel::clear_spring_constant() {
  spring_constant_ = 0;
  clear_has_spring_constant();
}
inline float SpringModel::spring_constant() const {
  return spring_constant_;
}
inline void SpringModel::set_spring_constant(float value) {
  set_has_spring_constant();
  spring_constant_ = value;
}

// -------------------------------------------------------------------

// ThermalModel

// optional float motor_housing_thermal_resistance = 5;
inline bool ThermalModel::has_motor_housing_thermal_resistance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThermalModel::set_has_motor_housing_thermal_resistance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThermalModel::clear_has_motor_housing_thermal_resistance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThermalModel::clear_motor_housing_thermal_resistance() {
  motor_housing_thermal_resistance_ = 0;
  clear_has_motor_housing_thermal_resistance();
}
inline float ThermalModel::motor_housing_thermal_resistance() const {
  return motor_housing_thermal_resistance_;
}
inline void ThermalModel::set_motor_housing_thermal_resistance(float value) {
  set_has_motor_housing_thermal_resistance();
  motor_housing_thermal_resistance_ = value;
}

// -------------------------------------------------------------------

// SafetyLimits

// optional float motor_current_limit = 5;
inline bool SafetyLimits::has_motor_current_limit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SafetyLimits::set_has_motor_current_limit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SafetyLimits::clear_has_motor_current_limit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SafetyLimits::clear_motor_current_limit() {
  motor_current_limit_ = 0;
  clear_has_motor_current_limit();
}
inline float SafetyLimits::motor_current_limit() const {
  return motor_current_limit_;
}
inline void SafetyLimits::set_motor_current_limit(float value) {
  set_has_motor_current_limit();
  motor_current_limit_ = value;
}

// -------------------------------------------------------------------

// Name

// optional string name = 1;
inline bool Name::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Name::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Name::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Name::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Name::name() const {
  return *name_;
}
inline void Name::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Name::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Name::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Name::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Name::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Name::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string group_name = 2;
inline bool Name::has_group_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Name::set_has_group_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Name::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Name::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& Name::group_name() const {
  return *group_name_;
}
inline void Name::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void Name::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void Name::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Name::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  return group_name_;
}
inline ::std::string* Name::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Name::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Settings

// optional .biorobotics.firmware.protos.settings.Controller controller = 2;
inline bool Settings::has_controller() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Settings::set_has_controller() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Settings::clear_has_controller() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Settings::clear_controller() {
  if (controller_ != NULL) controller_->::biorobotics::firmware::protos::settings::Controller::Clear();
  clear_has_controller();
}
inline const ::biorobotics::firmware::protos::settings::Controller& Settings::controller() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return controller_ != NULL ? *controller_ : *default_instance().controller_;
#else
  return controller_ != NULL ? *controller_ : *default_instance_->controller_;
#endif
}
inline ::biorobotics::firmware::protos::settings::Controller* Settings::mutable_controller() {
  set_has_controller();
  if (controller_ == NULL) controller_ = new ::biorobotics::firmware::protos::settings::Controller;
  return controller_;
}
inline ::biorobotics::firmware::protos::settings::Controller* Settings::release_controller() {
  clear_has_controller();
  ::biorobotics::firmware::protos::settings::Controller* temp = controller_;
  controller_ = NULL;
  return temp;
}
inline void Settings::set_allocated_controller(::biorobotics::firmware::protos::settings::Controller* controller) {
  delete controller_;
  controller_ = controller;
  if (controller) {
    set_has_controller();
  } else {
    clear_has_controller();
  }
}

// optional .biorobotics.firmware.protos.settings.Imu imu = 3;
inline bool Settings::has_imu() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Settings::set_has_imu() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Settings::clear_has_imu() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Settings::clear_imu() {
  if (imu_ != NULL) imu_->::biorobotics::firmware::protos::settings::Imu::Clear();
  clear_has_imu();
}
inline const ::biorobotics::firmware::protos::settings::Imu& Settings::imu() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return imu_ != NULL ? *imu_ : *default_instance().imu_;
#else
  return imu_ != NULL ? *imu_ : *default_instance_->imu_;
#endif
}
inline ::biorobotics::firmware::protos::settings::Imu* Settings::mutable_imu() {
  set_has_imu();
  if (imu_ == NULL) imu_ = new ::biorobotics::firmware::protos::settings::Imu;
  return imu_;
}
inline ::biorobotics::firmware::protos::settings::Imu* Settings::release_imu() {
  clear_has_imu();
  ::biorobotics::firmware::protos::settings::Imu* temp = imu_;
  imu_ = NULL;
  return temp;
}
inline void Settings::set_allocated_imu(::biorobotics::firmware::protos::settings::Imu* imu) {
  delete imu_;
  imu_ = imu;
  if (imu) {
    set_has_imu();
  } else {
    clear_has_imu();
  }
}

// optional .biorobotics.firmware.protos.settings.EncoderFilter encoder_filter = 4;
inline bool Settings::has_encoder_filter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Settings::set_has_encoder_filter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Settings::clear_has_encoder_filter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Settings::clear_encoder_filter() {
  if (encoder_filter_ != NULL) encoder_filter_->::biorobotics::firmware::protos::settings::EncoderFilter::Clear();
  clear_has_encoder_filter();
}
inline const ::biorobotics::firmware::protos::settings::EncoderFilter& Settings::encoder_filter() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return encoder_filter_ != NULL ? *encoder_filter_ : *default_instance().encoder_filter_;
#else
  return encoder_filter_ != NULL ? *encoder_filter_ : *default_instance_->encoder_filter_;
#endif
}
inline ::biorobotics::firmware::protos::settings::EncoderFilter* Settings::mutable_encoder_filter() {
  set_has_encoder_filter();
  if (encoder_filter_ == NULL) encoder_filter_ = new ::biorobotics::firmware::protos::settings::EncoderFilter;
  return encoder_filter_;
}
inline ::biorobotics::firmware::protos::settings::EncoderFilter* Settings::release_encoder_filter() {
  clear_has_encoder_filter();
  ::biorobotics::firmware::protos::settings::EncoderFilter* temp = encoder_filter_;
  encoder_filter_ = NULL;
  return temp;
}
inline void Settings::set_allocated_encoder_filter(::biorobotics::firmware::protos::settings::EncoderFilter* encoder_filter) {
  delete encoder_filter_;
  encoder_filter_ = encoder_filter;
  if (encoder_filter) {
    set_has_encoder_filter();
  } else {
    clear_has_encoder_filter();
  }
}

// optional .biorobotics.firmware.protos.settings.SpringModel spring_model = 5;
inline bool Settings::has_spring_model() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Settings::set_has_spring_model() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Settings::clear_has_spring_model() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Settings::clear_spring_model() {
  if (spring_model_ != NULL) spring_model_->::biorobotics::firmware::protos::settings::SpringModel::Clear();
  clear_has_spring_model();
}
inline const ::biorobotics::firmware::protos::settings::SpringModel& Settings::spring_model() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return spring_model_ != NULL ? *spring_model_ : *default_instance().spring_model_;
#else
  return spring_model_ != NULL ? *spring_model_ : *default_instance_->spring_model_;
#endif
}
inline ::biorobotics::firmware::protos::settings::SpringModel* Settings::mutable_spring_model() {
  set_has_spring_model();
  if (spring_model_ == NULL) spring_model_ = new ::biorobotics::firmware::protos::settings::SpringModel;
  return spring_model_;
}
inline ::biorobotics::firmware::protos::settings::SpringModel* Settings::release_spring_model() {
  clear_has_spring_model();
  ::biorobotics::firmware::protos::settings::SpringModel* temp = spring_model_;
  spring_model_ = NULL;
  return temp;
}
inline void Settings::set_allocated_spring_model(::biorobotics::firmware::protos::settings::SpringModel* spring_model) {
  delete spring_model_;
  spring_model_ = spring_model;
  if (spring_model) {
    set_has_spring_model();
  } else {
    clear_has_spring_model();
  }
}

// optional .biorobotics.firmware.protos.settings.ThermalModel thermal_model = 6;
inline bool Settings::has_thermal_model() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Settings::set_has_thermal_model() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Settings::clear_has_thermal_model() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Settings::clear_thermal_model() {
  if (thermal_model_ != NULL) thermal_model_->::biorobotics::firmware::protos::settings::ThermalModel::Clear();
  clear_has_thermal_model();
}
inline const ::biorobotics::firmware::protos::settings::ThermalModel& Settings::thermal_model() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return thermal_model_ != NULL ? *thermal_model_ : *default_instance().thermal_model_;
#else
  return thermal_model_ != NULL ? *thermal_model_ : *default_instance_->thermal_model_;
#endif
}
inline ::biorobotics::firmware::protos::settings::ThermalModel* Settings::mutable_thermal_model() {
  set_has_thermal_model();
  if (thermal_model_ == NULL) thermal_model_ = new ::biorobotics::firmware::protos::settings::ThermalModel;
  return thermal_model_;
}
inline ::biorobotics::firmware::protos::settings::ThermalModel* Settings::release_thermal_model() {
  clear_has_thermal_model();
  ::biorobotics::firmware::protos::settings::ThermalModel* temp = thermal_model_;
  thermal_model_ = NULL;
  return temp;
}
inline void Settings::set_allocated_thermal_model(::biorobotics::firmware::protos::settings::ThermalModel* thermal_model) {
  delete thermal_model_;
  thermal_model_ = thermal_model;
  if (thermal_model) {
    set_has_thermal_model();
  } else {
    clear_has_thermal_model();
  }
}

// optional .biorobotics.firmware.protos.settings.SafetyLimits safety_limits = 7;
inline bool Settings::has_safety_limits() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Settings::set_has_safety_limits() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Settings::clear_has_safety_limits() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Settings::clear_safety_limits() {
  if (safety_limits_ != NULL) safety_limits_->::biorobotics::firmware::protos::settings::SafetyLimits::Clear();
  clear_has_safety_limits();
}
inline const ::biorobotics::firmware::protos::settings::SafetyLimits& Settings::safety_limits() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return safety_limits_ != NULL ? *safety_limits_ : *default_instance().safety_limits_;
#else
  return safety_limits_ != NULL ? *safety_limits_ : *default_instance_->safety_limits_;
#endif
}
inline ::biorobotics::firmware::protos::settings::SafetyLimits* Settings::mutable_safety_limits() {
  set_has_safety_limits();
  if (safety_limits_ == NULL) safety_limits_ = new ::biorobotics::firmware::protos::settings::SafetyLimits;
  return safety_limits_;
}
inline ::biorobotics::firmware::protos::settings::SafetyLimits* Settings::release_safety_limits() {
  clear_has_safety_limits();
  ::biorobotics::firmware::protos::settings::SafetyLimits* temp = safety_limits_;
  safety_limits_ = NULL;
  return temp;
}
inline void Settings::set_allocated_safety_limits(::biorobotics::firmware::protos::settings::SafetyLimits* safety_limits) {
  delete safety_limits_;
  safety_limits_ = safety_limits;
  if (safety_limits) {
    set_has_safety_limits();
  } else {
    clear_has_safety_limits();
  }
}

// optional .biorobotics.firmware.protos.settings.Name name = 8;
inline bool Settings::has_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Settings::set_has_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Settings::clear_has_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Settings::clear_name() {
  if (name_ != NULL) name_->::biorobotics::firmware::protos::settings::Name::Clear();
  clear_has_name();
}
inline const ::biorobotics::firmware::protos::settings::Name& Settings::name() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return name_ != NULL ? *name_ : *default_instance().name_;
#else
  return name_ != NULL ? *name_ : *default_instance_->name_;
#endif
}
inline ::biorobotics::firmware::protos::settings::Name* Settings::mutable_name() {
  set_has_name();
  if (name_ == NULL) name_ = new ::biorobotics::firmware::protos::settings::Name;
  return name_;
}
inline ::biorobotics::firmware::protos::settings::Name* Settings::release_name() {
  clear_has_name();
  ::biorobotics::firmware::protos::settings::Name* temp = name_;
  name_ = NULL;
  return temp;
}
inline void Settings::set_allocated_name(::biorobotics::firmware::protos::settings::Name* name) {
  delete name_;
  name_ = name;
  if (name) {
    set_has_name();
  } else {
    clear_has_name();
  }
}

// optional bool persist_all = 1001;
inline bool Settings::has_persist_all() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Settings::set_has_persist_all() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Settings::clear_has_persist_all() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Settings::clear_persist_all() {
  persist_all_ = false;
  clear_has_persist_all();
}
inline bool Settings::persist_all() const {
  return persist_all_;
}
inline void Settings::set_persist_all(bool value) {
  set_has_persist_all();
  persist_all_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace settings
}  // namespace protos
}  // namespace firmware
}  // namespace biorobotics

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Settings_2eproto__INCLUDED
