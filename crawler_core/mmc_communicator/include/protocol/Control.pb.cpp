// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Control.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Control.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace biorobotics {
namespace firmware {
namespace protos {

void protobuf_ShutdownFile_Control_2eproto() {
  delete Command::default_instance_;
  delete Feedback::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_Control_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_Control_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::biorobotics::firmware::protos::protobuf_AddDesc_DataTypes_2eproto();
  Command::default_instance_ = new Command();
  Feedback::default_instance_ = new Feedback();
  Command::default_instance_->InitAsDefaultInstance();
  Feedback::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Control_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_Control_2eproto_once_);
void protobuf_AddDesc_Control_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_Control_2eproto_once_,
                 &protobuf_AddDesc_Control_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Control_2eproto {
  StaticDescriptorInitializer_Control_2eproto() {
    protobuf_AddDesc_Control_2eproto();
  }
} static_descriptor_initializer_Control_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int Command::kPositionFieldNumber;
const int Command::kVelocityFieldNumber;
const int Command::kTorqueFieldNumber;
const int Command::kPwmFieldNumber;
const int Command::kInnerTorqueFieldNumber;
const int Command::kLedFieldNumber;
#endif  // !_MSC_VER

Command::Command()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Command::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  led_ = const_cast< ::biorobotics::firmware::protos::Color*>(
      ::biorobotics::firmware::protos::Color::internal_default_instance());
#else
  led_ = const_cast< ::biorobotics::firmware::protos::Color*>(&::biorobotics::firmware::protos::Color::default_instance());
#endif
}

Command::Command(const Command& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Command::SharedCtor() {
  _cached_size_ = 0;
  position_ = 0;
  velocity_ = 0;
  torque_ = 0;
  pwm_ = 0;
  inner_torque_ = 0;
  led_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Command::~Command() {
  SharedDtor();
}

void Command::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete led_;
  }
}

void Command::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Command& Command::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Control_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Control_2eproto();
#endif
  return *default_instance_;
}

Command* Command::default_instance_ = NULL;

Command* Command::New() const {
  return new Command;
}

void Command::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    position_ = 0;
    velocity_ = 0;
    torque_ = 0;
    pwm_ = 0;
    inner_torque_ = 0;
    if (has_led()) {
      if (led_ != NULL) led_->::biorobotics::firmware::protos::Color::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Command::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float position = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &position_)));
          set_has_position();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_velocity;
        break;
      }

      // optional float velocity = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &velocity_)));
          set_has_velocity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_torque;
        break;
      }

      // optional float torque = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_torque:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &torque_)));
          set_has_torque();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_pwm;
        break;
      }

      // optional float pwm = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_pwm:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &pwm_)));
          set_has_pwm();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(77)) goto parse_inner_torque;
        break;
      }

      // optional float inner_torque = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_inner_torque:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &inner_torque_)));
          set_has_inner_torque();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_led;
        break;
      }

      // optional .biorobotics.firmware.protos.Color led = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_led:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_led()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Command::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float position = 1;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->position(), output);
  }

  // optional float velocity = 2;
  if (has_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->velocity(), output);
  }

  // optional float torque = 3;
  if (has_torque()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->torque(), output);
  }

  // optional float pwm = 8;
  if (has_pwm()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->pwm(), output);
  }

  // optional float inner_torque = 9;
  if (has_inner_torque()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->inner_torque(), output);
  }

  // optional .biorobotics.firmware.protos.Color led = 10;
  if (has_led()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, this->led(), output);
  }

}

int Command::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float position = 1;
    if (has_position()) {
      total_size += 1 + 4;
    }

    // optional float velocity = 2;
    if (has_velocity()) {
      total_size += 1 + 4;
    }

    // optional float torque = 3;
    if (has_torque()) {
      total_size += 1 + 4;
    }

    // optional float pwm = 8;
    if (has_pwm()) {
      total_size += 1 + 4;
    }

    // optional float inner_torque = 9;
    if (has_inner_torque()) {
      total_size += 1 + 4;
    }

    // optional .biorobotics.firmware.protos.Color led = 10;
    if (has_led()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->led());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Command::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Command*>(&from));
}

void Command::MergeFrom(const Command& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_position()) {
      set_position(from.position());
    }
    if (from.has_velocity()) {
      set_velocity(from.velocity());
    }
    if (from.has_torque()) {
      set_torque(from.torque());
    }
    if (from.has_pwm()) {
      set_pwm(from.pwm());
    }
    if (from.has_inner_torque()) {
      set_inner_torque(from.inner_torque());
    }
    if (from.has_led()) {
      mutable_led()->::biorobotics::firmware::protos::Color::MergeFrom(from.led());
    }
  }
}

void Command::CopyFrom(const Command& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Command::IsInitialized() const {

  return true;
}

void Command::Swap(Command* other) {
  if (other != this) {
    std::swap(position_, other->position_);
    std::swap(velocity_, other->velocity_);
    std::swap(torque_, other->torque_);
    std::swap(pwm_, other->pwm_);
    std::swap(inner_torque_, other->inner_torque_);
    std::swap(led_, other->led_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Command::GetTypeName() const {
  return "biorobotics.firmware.protos.Command";
}


// ===================================================================

#ifndef _MSC_VER
const int Feedback::kLedFieldNumber;
const int Feedback::kPositionFieldNumber;
const int Feedback::kVelocityFieldNumber;
const int Feedback::kTorqueFieldNumber;
const int Feedback::kDeflectionFieldNumber;
const int Feedback::kMotorVelocityFieldNumber;
const int Feedback::kDeflectionVelocityFieldNumber;
const int Feedback::kAccelFieldNumber;
const int Feedback::kGyroFieldNumber;
const int Feedback::kCompassFieldNumber;
const int Feedback::kMotorCurrentFieldNumber;
const int Feedback::kModuleCurrentFieldNumber;
const int Feedback::kMotorTemperatureFieldNumber;
const int Feedback::kAmbientTemperatureFieldNumber;
const int Feedback::kProcessorTemperatureFieldNumber;
const int Feedback::kActuatorTemperatureFieldNumber;
const int Feedback::kWindingTemperatureFieldNumber;
const int Feedback::kPressureFieldNumber;
const int Feedback::kVoltageFieldNumber;
#endif  // !_MSC_VER

Feedback::Feedback()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Feedback::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  led_ = const_cast< ::biorobotics::firmware::protos::Color*>(
      ::biorobotics::firmware::protos::Color::internal_default_instance());
#else
  led_ = const_cast< ::biorobotics::firmware::protos::Color*>(&::biorobotics::firmware::protos::Color::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  accel_ = const_cast< ::biorobotics::firmware::protos::Vector3*>(
      ::biorobotics::firmware::protos::Vector3::internal_default_instance());
#else
  accel_ = const_cast< ::biorobotics::firmware::protos::Vector3*>(&::biorobotics::firmware::protos::Vector3::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  gyro_ = const_cast< ::biorobotics::firmware::protos::Vector3*>(
      ::biorobotics::firmware::protos::Vector3::internal_default_instance());
#else
  gyro_ = const_cast< ::biorobotics::firmware::protos::Vector3*>(&::biorobotics::firmware::protos::Vector3::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  compass_ = const_cast< ::biorobotics::firmware::protos::Vector3*>(
      ::biorobotics::firmware::protos::Vector3::internal_default_instance());
#else
  compass_ = const_cast< ::biorobotics::firmware::protos::Vector3*>(&::biorobotics::firmware::protos::Vector3::default_instance());
#endif
}

Feedback::Feedback(const Feedback& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Feedback::SharedCtor() {
  _cached_size_ = 0;
  led_ = NULL;
  position_ = 0;
  velocity_ = 0;
  torque_ = 0;
  deflection_ = 0;
  motor_velocity_ = 0;
  deflection_velocity_ = 0;
  accel_ = NULL;
  gyro_ = NULL;
  compass_ = NULL;
  motor_current_ = 0;
  module_current_ = 0;
  motor_temperature_ = 0;
  ambient_temperature_ = 0;
  processor_temperature_ = 0;
  actuator_temperature_ = 0;
  winding_temperature_ = 0;
  pressure_ = 0;
  voltage_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Feedback::~Feedback() {
  SharedDtor();
}

void Feedback::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete led_;
    delete accel_;
    delete gyro_;
    delete compass_;
  }
}

void Feedback::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Feedback& Feedback::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Control_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Control_2eproto();
#endif
  return *default_instance_;
}

Feedback* Feedback::default_instance_ = NULL;

Feedback* Feedback::New() const {
  return new Feedback;
}

void Feedback::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_led()) {
      if (led_ != NULL) led_->::biorobotics::firmware::protos::Color::Clear();
    }
    position_ = 0;
    velocity_ = 0;
    torque_ = 0;
    deflection_ = 0;
    motor_velocity_ = 0;
    deflection_velocity_ = 0;
    if (has_accel()) {
      if (accel_ != NULL) accel_->::biorobotics::firmware::protos::Vector3::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_gyro()) {
      if (gyro_ != NULL) gyro_->::biorobotics::firmware::protos::Vector3::Clear();
    }
    if (has_compass()) {
      if (compass_ != NULL) compass_->::biorobotics::firmware::protos::Vector3::Clear();
    }
    motor_current_ = 0;
    module_current_ = 0;
    motor_temperature_ = 0;
    ambient_temperature_ = 0;
    processor_temperature_ = 0;
    actuator_temperature_ = 0;
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    winding_temperature_ = 0;
    pressure_ = 0;
    voltage_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Feedback::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float position = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &position_)));
          set_has_position();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_velocity;
        break;
      }

      // optional float velocity = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &velocity_)));
          set_has_velocity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_torque;
        break;
      }

      // optional float torque = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_torque:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &torque_)));
          set_has_torque();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_deflection;
        break;
      }

      // optional float deflection = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_deflection:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &deflection_)));
          set_has_deflection();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_motor_velocity;
        break;
      }

      // optional float motor_velocity = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_motor_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &motor_velocity_)));
          set_has_motor_velocity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_deflection_velocity;
        break;
      }

      // optional float deflection_velocity = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_deflection_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &deflection_velocity_)));
          set_has_deflection_velocity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_led;
        break;
      }

      // optional .biorobotics.firmware.protos.Color led = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_led:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_led()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(210)) goto parse_accel;
        break;
      }

      // optional .biorobotics.firmware.protos.Vector3 accel = 26;
      case 26: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_accel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_accel()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(218)) goto parse_gyro;
        break;
      }

      // optional .biorobotics.firmware.protos.Vector3 gyro = 27;
      case 27: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gyro:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gyro()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(226)) goto parse_compass;
        break;
      }

      // optional .biorobotics.firmware.protos.Vector3 compass = 28;
      case 28: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_compass:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_compass()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(325)) goto parse_motor_current;
        break;
      }

      // optional float motor_current = 40;
      case 40: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_motor_current:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &motor_current_)));
          set_has_motor_current();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(333)) goto parse_module_current;
        break;
      }

      // optional float module_current = 41;
      case 41: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_module_current:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &module_current_)));
          set_has_module_current();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(485)) goto parse_motor_temperature;
        break;
      }

      // optional float motor_temperature = 60;
      case 60: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_motor_temperature:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &motor_temperature_)));
          set_has_motor_temperature();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(493)) goto parse_ambient_temperature;
        break;
      }

      // optional float ambient_temperature = 61;
      case 61: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_ambient_temperature:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &ambient_temperature_)));
          set_has_ambient_temperature();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(501)) goto parse_processor_temperature;
        break;
      }

      // optional float processor_temperature = 62;
      case 62: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_processor_temperature:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &processor_temperature_)));
          set_has_processor_temperature();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(509)) goto parse_actuator_temperature;
        break;
      }

      // optional float actuator_temperature = 63;
      case 63: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_actuator_temperature:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &actuator_temperature_)));
          set_has_actuator_temperature();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(517)) goto parse_winding_temperature;
        break;
      }

      // optional float winding_temperature = 64;
      case 64: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_winding_temperature:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &winding_temperature_)));
          set_has_winding_temperature();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(645)) goto parse_pressure;
        break;
      }

      // optional float pressure = 80;
      case 80: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_pressure:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &pressure_)));
          set_has_pressure();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(653)) goto parse_voltage;
        break;
      }

      // optional float voltage = 81;
      case 81: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_voltage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &voltage_)));
          set_has_voltage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Feedback::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float position = 1;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->position(), output);
  }

  // optional float velocity = 2;
  if (has_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->velocity(), output);
  }

  // optional float torque = 3;
  if (has_torque()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->torque(), output);
  }

  // optional float deflection = 4;
  if (has_deflection()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->deflection(), output);
  }

  // optional float motor_velocity = 5;
  if (has_motor_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->motor_velocity(), output);
  }

  // optional float deflection_velocity = 6;
  if (has_deflection_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->deflection_velocity(), output);
  }

  // optional .biorobotics.firmware.protos.Color led = 10;
  if (has_led()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, this->led(), output);
  }

  // optional .biorobotics.firmware.protos.Vector3 accel = 26;
  if (has_accel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      26, this->accel(), output);
  }

  // optional .biorobotics.firmware.protos.Vector3 gyro = 27;
  if (has_gyro()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      27, this->gyro(), output);
  }

  // optional .biorobotics.firmware.protos.Vector3 compass = 28;
  if (has_compass()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      28, this->compass(), output);
  }

  // optional float motor_current = 40;
  if (has_motor_current()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(40, this->motor_current(), output);
  }

  // optional float module_current = 41;
  if (has_module_current()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(41, this->module_current(), output);
  }

  // optional float motor_temperature = 60;
  if (has_motor_temperature()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(60, this->motor_temperature(), output);
  }

  // optional float ambient_temperature = 61;
  if (has_ambient_temperature()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(61, this->ambient_temperature(), output);
  }

  // optional float processor_temperature = 62;
  if (has_processor_temperature()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(62, this->processor_temperature(), output);
  }

  // optional float actuator_temperature = 63;
  if (has_actuator_temperature()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(63, this->actuator_temperature(), output);
  }

  // optional float winding_temperature = 64;
  if (has_winding_temperature()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(64, this->winding_temperature(), output);
  }

  // optional float pressure = 80;
  if (has_pressure()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(80, this->pressure(), output);
  }

  // optional float voltage = 81;
  if (has_voltage()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(81, this->voltage(), output);
  }

}

int Feedback::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .biorobotics.firmware.protos.Color led = 10;
    if (has_led()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->led());
    }

    // optional float position = 1;
    if (has_position()) {
      total_size += 1 + 4;
    }

    // optional float velocity = 2;
    if (has_velocity()) {
      total_size += 1 + 4;
    }

    // optional float torque = 3;
    if (has_torque()) {
      total_size += 1 + 4;
    }

    // optional float deflection = 4;
    if (has_deflection()) {
      total_size += 1 + 4;
    }

    // optional float motor_velocity = 5;
    if (has_motor_velocity()) {
      total_size += 1 + 4;
    }

    // optional float deflection_velocity = 6;
    if (has_deflection_velocity()) {
      total_size += 1 + 4;
    }

    // optional .biorobotics.firmware.protos.Vector3 accel = 26;
    if (has_accel()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->accel());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .biorobotics.firmware.protos.Vector3 gyro = 27;
    if (has_gyro()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->gyro());
    }

    // optional .biorobotics.firmware.protos.Vector3 compass = 28;
    if (has_compass()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->compass());
    }

    // optional float motor_current = 40;
    if (has_motor_current()) {
      total_size += 2 + 4;
    }

    // optional float module_current = 41;
    if (has_module_current()) {
      total_size += 2 + 4;
    }

    // optional float motor_temperature = 60;
    if (has_motor_temperature()) {
      total_size += 2 + 4;
    }

    // optional float ambient_temperature = 61;
    if (has_ambient_temperature()) {
      total_size += 2 + 4;
    }

    // optional float processor_temperature = 62;
    if (has_processor_temperature()) {
      total_size += 2 + 4;
    }

    // optional float actuator_temperature = 63;
    if (has_actuator_temperature()) {
      total_size += 2 + 4;
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional float winding_temperature = 64;
    if (has_winding_temperature()) {
      total_size += 2 + 4;
    }

    // optional float pressure = 80;
    if (has_pressure()) {
      total_size += 2 + 4;
    }

    // optional float voltage = 81;
    if (has_voltage()) {
      total_size += 2 + 4;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Feedback::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Feedback*>(&from));
}

void Feedback::MergeFrom(const Feedback& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_led()) {
      mutable_led()->::biorobotics::firmware::protos::Color::MergeFrom(from.led());
    }
    if (from.has_position()) {
      set_position(from.position());
    }
    if (from.has_velocity()) {
      set_velocity(from.velocity());
    }
    if (from.has_torque()) {
      set_torque(from.torque());
    }
    if (from.has_deflection()) {
      set_deflection(from.deflection());
    }
    if (from.has_motor_velocity()) {
      set_motor_velocity(from.motor_velocity());
    }
    if (from.has_deflection_velocity()) {
      set_deflection_velocity(from.deflection_velocity());
    }
    if (from.has_accel()) {
      mutable_accel()->::biorobotics::firmware::protos::Vector3::MergeFrom(from.accel());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_gyro()) {
      mutable_gyro()->::biorobotics::firmware::protos::Vector3::MergeFrom(from.gyro());
    }
    if (from.has_compass()) {
      mutable_compass()->::biorobotics::firmware::protos::Vector3::MergeFrom(from.compass());
    }
    if (from.has_motor_current()) {
      set_motor_current(from.motor_current());
    }
    if (from.has_module_current()) {
      set_module_current(from.module_current());
    }
    if (from.has_motor_temperature()) {
      set_motor_temperature(from.motor_temperature());
    }
    if (from.has_ambient_temperature()) {
      set_ambient_temperature(from.ambient_temperature());
    }
    if (from.has_processor_temperature()) {
      set_processor_temperature(from.processor_temperature());
    }
    if (from.has_actuator_temperature()) {
      set_actuator_temperature(from.actuator_temperature());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_winding_temperature()) {
      set_winding_temperature(from.winding_temperature());
    }
    if (from.has_pressure()) {
      set_pressure(from.pressure());
    }
    if (from.has_voltage()) {
      set_voltage(from.voltage());
    }
  }
}

void Feedback::CopyFrom(const Feedback& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Feedback::IsInitialized() const {

  return true;
}

void Feedback::Swap(Feedback* other) {
  if (other != this) {
    std::swap(led_, other->led_);
    std::swap(position_, other->position_);
    std::swap(velocity_, other->velocity_);
    std::swap(torque_, other->torque_);
    std::swap(deflection_, other->deflection_);
    std::swap(motor_velocity_, other->motor_velocity_);
    std::swap(deflection_velocity_, other->deflection_velocity_);
    std::swap(accel_, other->accel_);
    std::swap(gyro_, other->gyro_);
    std::swap(compass_, other->compass_);
    std::swap(motor_current_, other->motor_current_);
    std::swap(module_current_, other->module_current_);
    std::swap(motor_temperature_, other->motor_temperature_);
    std::swap(ambient_temperature_, other->ambient_temperature_);
    std::swap(processor_temperature_, other->processor_temperature_);
    std::swap(actuator_temperature_, other->actuator_temperature_);
    std::swap(winding_temperature_, other->winding_temperature_);
    std::swap(pressure_, other->pressure_);
    std::swap(voltage_, other->voltage_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Feedback::GetTypeName() const {
  return "biorobotics.firmware.protos.Feedback";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace firmware
}  // namespace biorobotics

// @@protoc_insertion_point(global_scope)
