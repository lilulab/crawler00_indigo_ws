// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Core.proto

#ifndef PROTOBUF_Core_2eproto__INCLUDED
#define PROTOBUF_Core_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "Settings.pb.h"
#include "RemoteServices.pb.h"
#include "Control.pb.h"
// @@protoc_insertion_point(includes)

namespace biorobotics {
namespace firmware {
namespace protos {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Core_2eproto();
void protobuf_AssignDesc_Core_2eproto();
void protobuf_ShutdownFile_Core_2eproto();

class Echo;
class FirmwareInfo;
class HardwareInfo;
class EthernetInfo;
class DebugMessage;
class RootMessage;

enum FirmwareInfo_FirmwareType {
  FirmwareInfo_FirmwareType_APPLICATION = 0,
  FirmwareInfo_FirmwareType_BOOTLOADER = 1
};
bool FirmwareInfo_FirmwareType_IsValid(int value);
const FirmwareInfo_FirmwareType FirmwareInfo_FirmwareType_FirmwareType_MIN = FirmwareInfo_FirmwareType_APPLICATION;
const FirmwareInfo_FirmwareType FirmwareInfo_FirmwareType_FirmwareType_MAX = FirmwareInfo_FirmwareType_BOOTLOADER;
const int FirmwareInfo_FirmwareType_FirmwareType_ARRAYSIZE = FirmwareInfo_FirmwareType_FirmwareType_MAX + 1;

// ===================================================================

class Echo : public ::google::protobuf::MessageLite {
 public:
  Echo();
  virtual ~Echo();

  Echo(const Echo& from);

  inline Echo& operator=(const Echo& from) {
    CopyFrom(from);
    return *this;
  }

  static const Echo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Echo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Echo* other);

  // implements Message ----------------------------------------------

  Echo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Echo& from);
  void MergeFrom(const Echo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes payload = 1;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 1;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // optional uint32 tx_time_sec = 2;
  inline bool has_tx_time_sec() const;
  inline void clear_tx_time_sec();
  static const int kTxTimeSecFieldNumber = 2;
  inline ::google::protobuf::uint32 tx_time_sec() const;
  inline void set_tx_time_sec(::google::protobuf::uint32 value);

  // optional uint32 tx_time_usec = 3;
  inline bool has_tx_time_usec() const;
  inline void clear_tx_time_usec();
  static const int kTxTimeUsecFieldNumber = 3;
  inline ::google::protobuf::uint32 tx_time_usec() const;
  inline void set_tx_time_usec(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:biorobotics.firmware.protos.Echo)
 private:
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_tx_time_sec();
  inline void clear_has_tx_time_sec();
  inline void set_has_tx_time_usec();
  inline void clear_has_tx_time_usec();

  ::std::string* payload_;
  ::google::protobuf::uint32 tx_time_sec_;
  ::google::protobuf::uint32 tx_time_usec_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Core_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Core_2eproto();
  #endif
  friend void protobuf_AssignDesc_Core_2eproto();
  friend void protobuf_ShutdownFile_Core_2eproto();

  void InitAsDefaultInstance();
  static Echo* default_instance_;
};
// -------------------------------------------------------------------

class FirmwareInfo : public ::google::protobuf::MessageLite {
 public:
  FirmwareInfo();
  virtual ~FirmwareInfo();

  FirmwareInfo(const FirmwareInfo& from);

  inline FirmwareInfo& operator=(const FirmwareInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const FirmwareInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FirmwareInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FirmwareInfo* other);

  // implements Message ----------------------------------------------

  FirmwareInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FirmwareInfo& from);
  void MergeFrom(const FirmwareInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef FirmwareInfo_FirmwareType FirmwareType;
  static const FirmwareType APPLICATION = FirmwareInfo_FirmwareType_APPLICATION;
  static const FirmwareType BOOTLOADER = FirmwareInfo_FirmwareType_BOOTLOADER;
  static inline bool FirmwareType_IsValid(int value) {
    return FirmwareInfo_FirmwareType_IsValid(value);
  }
  static const FirmwareType FirmwareType_MIN =
    FirmwareInfo_FirmwareType_FirmwareType_MIN;
  static const FirmwareType FirmwareType_MAX =
    FirmwareInfo_FirmwareType_FirmwareType_MAX;
  static const int FirmwareType_ARRAYSIZE =
    FirmwareInfo_FirmwareType_FirmwareType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string build_date = 2;
  inline bool has_build_date() const;
  inline void clear_build_date();
  static const int kBuildDateFieldNumber = 2;
  inline const ::std::string& build_date() const;
  inline void set_build_date(const ::std::string& value);
  inline void set_build_date(const char* value);
  inline void set_build_date(const char* value, size_t size);
  inline ::std::string* mutable_build_date();
  inline ::std::string* release_build_date();
  inline void set_allocated_build_date(::std::string* build_date);

  // optional string tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // optional string username = 4;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 4;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional .biorobotics.firmware.protos.FirmwareInfo.FirmwareType type = 10;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 10;
  inline ::biorobotics::firmware::protos::FirmwareInfo_FirmwareType type() const;
  inline void set_type(::biorobotics::firmware::protos::FirmwareInfo_FirmwareType value);

  // @@protoc_insertion_point(class_scope:biorobotics.firmware.protos.FirmwareInfo)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_build_date();
  inline void clear_has_build_date();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_type();
  inline void clear_has_type();

  ::std::string* version_;
  ::std::string* build_date_;
  ::std::string* tag_;
  ::std::string* username_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Core_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Core_2eproto();
  #endif
  friend void protobuf_AssignDesc_Core_2eproto();
  friend void protobuf_ShutdownFile_Core_2eproto();

  void InitAsDefaultInstance();
  static FirmwareInfo* default_instance_;
};
// -------------------------------------------------------------------

class HardwareInfo : public ::google::protobuf::MessageLite {
 public:
  HardwareInfo();
  virtual ~HardwareInfo();

  HardwareInfo(const HardwareInfo& from);

  inline HardwareInfo& operator=(const HardwareInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const HardwareInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HardwareInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HardwareInfo* other);

  // implements Message ----------------------------------------------

  HardwareInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HardwareInfo& from);
  void MergeFrom(const HardwareInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes serial_number = 1;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 1;
  inline const ::std::string& serial_number() const;
  inline void set_serial_number(const ::std::string& value);
  inline void set_serial_number(const char* value);
  inline void set_serial_number(const void* value, size_t size);
  inline ::std::string* mutable_serial_number();
  inline ::std::string* release_serial_number();
  inline void set_allocated_serial_number(::std::string* serial_number);

  // optional string type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string revision = 6;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 6;
  inline const ::std::string& revision() const;
  inline void set_revision(const ::std::string& value);
  inline void set_revision(const char* value);
  inline void set_revision(const char* value, size_t size);
  inline ::std::string* mutable_revision();
  inline ::std::string* release_revision();
  inline void set_allocated_revision(::std::string* revision);

  // optional string processor = 7;
  inline bool has_processor() const;
  inline void clear_processor();
  static const int kProcessorFieldNumber = 7;
  inline const ::std::string& processor() const;
  inline void set_processor(const ::std::string& value);
  inline void set_processor(const char* value);
  inline void set_processor(const char* value, size_t size);
  inline ::std::string* mutable_processor();
  inline ::std::string* release_processor();
  inline void set_allocated_processor(::std::string* processor);

  // @@protoc_insertion_point(class_scope:biorobotics.firmware.protos.HardwareInfo)
 private:
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_processor();
  inline void clear_has_processor();

  ::std::string* serial_number_;
  ::std::string* type_;
  ::std::string* revision_;
  ::std::string* processor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Core_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Core_2eproto();
  #endif
  friend void protobuf_AssignDesc_Core_2eproto();
  friend void protobuf_ShutdownFile_Core_2eproto();

  void InitAsDefaultInstance();
  static HardwareInfo* default_instance_;
};
// -------------------------------------------------------------------

class EthernetInfo : public ::google::protobuf::MessageLite {
 public:
  EthernetInfo();
  virtual ~EthernetInfo();

  EthernetInfo(const EthernetInfo& from);

  inline EthernetInfo& operator=(const EthernetInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const EthernetInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EthernetInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EthernetInfo* other);

  // implements Message ----------------------------------------------

  EthernetInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EthernetInfo& from);
  void MergeFrom(const EthernetInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes mac_address = 10;
  inline bool has_mac_address() const;
  inline void clear_mac_address();
  static const int kMacAddressFieldNumber = 10;
  inline const ::std::string& mac_address() const;
  inline void set_mac_address(const ::std::string& value);
  inline void set_mac_address(const char* value);
  inline void set_mac_address(const void* value, size_t size);
  inline ::std::string* mutable_mac_address();
  inline ::std::string* release_mac_address();
  inline void set_allocated_mac_address(::std::string* mac_address);

  // optional bytes ip_address = 20;
  inline bool has_ip_address() const;
  inline void clear_ip_address();
  static const int kIpAddressFieldNumber = 20;
  inline const ::std::string& ip_address() const;
  inline void set_ip_address(const ::std::string& value);
  inline void set_ip_address(const char* value);
  inline void set_ip_address(const void* value, size_t size);
  inline ::std::string* mutable_ip_address();
  inline ::std::string* release_ip_address();
  inline void set_allocated_ip_address(::std::string* ip_address);

  // optional bytes netmask = 21;
  inline bool has_netmask() const;
  inline void clear_netmask();
  static const int kNetmaskFieldNumber = 21;
  inline const ::std::string& netmask() const;
  inline void set_netmask(const ::std::string& value);
  inline void set_netmask(const char* value);
  inline void set_netmask(const void* value, size_t size);
  inline ::std::string* mutable_netmask();
  inline ::std::string* release_netmask();
  inline void set_allocated_netmask(::std::string* netmask);

  // optional bytes gateway = 22;
  inline bool has_gateway() const;
  inline void clear_gateway();
  static const int kGatewayFieldNumber = 22;
  inline const ::std::string& gateway() const;
  inline void set_gateway(const ::std::string& value);
  inline void set_gateway(const char* value);
  inline void set_gateway(const void* value, size_t size);
  inline ::std::string* mutable_gateway();
  inline ::std::string* release_gateway();
  inline void set_allocated_gateway(::std::string* gateway);

  // optional bytes proximal_ip = 40;
  inline bool has_proximal_ip() const;
  inline void clear_proximal_ip();
  static const int kProximalIpFieldNumber = 40;
  inline const ::std::string& proximal_ip() const;
  inline void set_proximal_ip(const ::std::string& value);
  inline void set_proximal_ip(const char* value);
  inline void set_proximal_ip(const void* value, size_t size);
  inline ::std::string* mutable_proximal_ip();
  inline ::std::string* release_proximal_ip();
  inline void set_allocated_proximal_ip(::std::string* proximal_ip);

  // repeated bytes distal_ips = 42;
  inline int distal_ips_size() const;
  inline void clear_distal_ips();
  static const int kDistalIpsFieldNumber = 42;
  inline const ::std::string& distal_ips(int index) const;
  inline ::std::string* mutable_distal_ips(int index);
  inline void set_distal_ips(int index, const ::std::string& value);
  inline void set_distal_ips(int index, const char* value);
  inline void set_distal_ips(int index, const void* value, size_t size);
  inline ::std::string* add_distal_ips();
  inline void add_distal_ips(const ::std::string& value);
  inline void add_distal_ips(const char* value);
  inline void add_distal_ips(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& distal_ips() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_distal_ips();

  // @@protoc_insertion_point(class_scope:biorobotics.firmware.protos.EthernetInfo)
 private:
  inline void set_has_mac_address();
  inline void clear_has_mac_address();
  inline void set_has_ip_address();
  inline void clear_has_ip_address();
  inline void set_has_netmask();
  inline void clear_has_netmask();
  inline void set_has_gateway();
  inline void clear_has_gateway();
  inline void set_has_proximal_ip();
  inline void clear_has_proximal_ip();

  ::std::string* mac_address_;
  ::std::string* ip_address_;
  ::std::string* netmask_;
  ::std::string* gateway_;
  ::std::string* proximal_ip_;
  ::google::protobuf::RepeatedPtrField< ::std::string> distal_ips_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Core_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Core_2eproto();
  #endif
  friend void protobuf_AssignDesc_Core_2eproto();
  friend void protobuf_ShutdownFile_Core_2eproto();

  void InitAsDefaultInstance();
  static EthernetInfo* default_instance_;
};
// -------------------------------------------------------------------

class DebugMessage : public ::google::protobuf::MessageLite {
 public:
  DebugMessage();
  virtual ~DebugMessage();

  DebugMessage(const DebugMessage& from);

  inline DebugMessage& operator=(const DebugMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const DebugMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DebugMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DebugMessage* other);

  // implements Message ----------------------------------------------

  DebugMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DebugMessage& from);
  void MergeFrom(const DebugMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes bytes_payloads = 1;
  inline int bytes_payloads_size() const;
  inline void clear_bytes_payloads();
  static const int kBytesPayloadsFieldNumber = 1;
  inline const ::std::string& bytes_payloads(int index) const;
  inline ::std::string* mutable_bytes_payloads(int index);
  inline void set_bytes_payloads(int index, const ::std::string& value);
  inline void set_bytes_payloads(int index, const char* value);
  inline void set_bytes_payloads(int index, const void* value, size_t size);
  inline ::std::string* add_bytes_payloads();
  inline void add_bytes_payloads(const ::std::string& value);
  inline void add_bytes_payloads(const char* value);
  inline void add_bytes_payloads(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& bytes_payloads() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_bytes_payloads();

  // repeated float float_payloads = 2;
  inline int float_payloads_size() const;
  inline void clear_float_payloads();
  static const int kFloatPayloadsFieldNumber = 2;
  inline float float_payloads(int index) const;
  inline void set_float_payloads(int index, float value);
  inline void add_float_payloads(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      float_payloads() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_float_payloads();

  // repeated string float_payloads_units = 3;
  inline int float_payloads_units_size() const;
  inline void clear_float_payloads_units();
  static const int kFloatPayloadsUnitsFieldNumber = 3;
  inline const ::std::string& float_payloads_units(int index) const;
  inline ::std::string* mutable_float_payloads_units(int index);
  inline void set_float_payloads_units(int index, const ::std::string& value);
  inline void set_float_payloads_units(int index, const char* value);
  inline void set_float_payloads_units(int index, const char* value, size_t size);
  inline ::std::string* add_float_payloads_units();
  inline void add_float_payloads_units(const ::std::string& value);
  inline void add_float_payloads_units(const char* value);
  inline void add_float_payloads_units(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& float_payloads_units() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_float_payloads_units();

  // @@protoc_insertion_point(class_scope:biorobotics.firmware.protos.DebugMessage)
 private:

  ::google::protobuf::RepeatedPtrField< ::std::string> bytes_payloads_;
  ::google::protobuf::RepeatedField< float > float_payloads_;
  ::google::protobuf::RepeatedPtrField< ::std::string> float_payloads_units_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Core_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Core_2eproto();
  #endif
  friend void protobuf_AssignDesc_Core_2eproto();
  friend void protobuf_ShutdownFile_Core_2eproto();

  void InitAsDefaultInstance();
  static DebugMessage* default_instance_;
};
// -------------------------------------------------------------------

class RootMessage : public ::google::protobuf::MessageLite {
 public:
  RootMessage();
  virtual ~RootMessage();

  RootMessage(const RootMessage& from);

  inline RootMessage& operator=(const RootMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const RootMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RootMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RootMessage* other);

  // implements Message ----------------------------------------------

  RootMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RootMessage& from);
  void MergeFrom(const RootMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .biorobotics.firmware.protos.FirmwareInfo firmware_info = 1010;
  inline bool has_firmware_info() const;
  inline void clear_firmware_info();
  static const int kFirmwareInfoFieldNumber = 1010;
  inline const ::biorobotics::firmware::protos::FirmwareInfo& firmware_info() const;
  inline ::biorobotics::firmware::protos::FirmwareInfo* mutable_firmware_info();
  inline ::biorobotics::firmware::protos::FirmwareInfo* release_firmware_info();
  inline void set_allocated_firmware_info(::biorobotics::firmware::protos::FirmwareInfo* firmware_info);

  // optional bool request_firmware_info = 1011;
  inline bool has_request_firmware_info() const;
  inline void clear_request_firmware_info();
  static const int kRequestFirmwareInfoFieldNumber = 1011;
  inline bool request_firmware_info() const;
  inline void set_request_firmware_info(bool value);

  // optional .biorobotics.firmware.protos.HardwareInfo hardware_info = 1012;
  inline bool has_hardware_info() const;
  inline void clear_hardware_info();
  static const int kHardwareInfoFieldNumber = 1012;
  inline const ::biorobotics::firmware::protos::HardwareInfo& hardware_info() const;
  inline ::biorobotics::firmware::protos::HardwareInfo* mutable_hardware_info();
  inline ::biorobotics::firmware::protos::HardwareInfo* release_hardware_info();
  inline void set_allocated_hardware_info(::biorobotics::firmware::protos::HardwareInfo* hardware_info);

  // optional bool request_hardware_info = 1013;
  inline bool has_request_hardware_info() const;
  inline void clear_request_hardware_info();
  static const int kRequestHardwareInfoFieldNumber = 1013;
  inline bool request_hardware_info() const;
  inline void set_request_hardware_info(bool value);

  // optional .biorobotics.firmware.protos.EthernetInfo ethernet_info = 1015;
  inline bool has_ethernet_info() const;
  inline void clear_ethernet_info();
  static const int kEthernetInfoFieldNumber = 1015;
  inline const ::biorobotics::firmware::protos::EthernetInfo& ethernet_info() const;
  inline ::biorobotics::firmware::protos::EthernetInfo* mutable_ethernet_info();
  inline ::biorobotics::firmware::protos::EthernetInfo* release_ethernet_info();
  inline void set_allocated_ethernet_info(::biorobotics::firmware::protos::EthernetInfo* ethernet_info);

  // optional bool request_ethernet_info = 1016;
  inline bool has_request_ethernet_info() const;
  inline void clear_request_ethernet_info();
  static const int kRequestEthernetInfoFieldNumber = 1016;
  inline bool request_ethernet_info() const;
  inline void set_request_ethernet_info(bool value);

  // optional uint32 rx_time_sec = 3;
  inline bool has_rx_time_sec() const;
  inline void clear_rx_time_sec();
  static const int kRxTimeSecFieldNumber = 3;
  inline ::google::protobuf::uint32 rx_time_sec() const;
  inline void set_rx_time_sec(::google::protobuf::uint32 value);

  // optional uint32 rx_time_usec = 4;
  inline bool has_rx_time_usec() const;
  inline void clear_rx_time_usec();
  static const int kRxTimeUsecFieldNumber = 4;
  inline ::google::protobuf::uint32 rx_time_usec() const;
  inline void set_rx_time_usec(::google::protobuf::uint32 value);

  // optional uint32 tx_time_sec = 5;
  inline bool has_tx_time_sec() const;
  inline void clear_tx_time_sec();
  static const int kTxTimeSecFieldNumber = 5;
  inline ::google::protobuf::uint32 tx_time_sec() const;
  inline void set_tx_time_sec(::google::protobuf::uint32 value);

  // optional uint32 tx_time_usec = 6;
  inline bool has_tx_time_usec() const;
  inline void clear_tx_time_usec();
  static const int kTxTimeUsecFieldNumber = 6;
  inline ::google::protobuf::uint32 tx_time_usec() const;
  inline void set_tx_time_usec(::google::protobuf::uint32 value);

  // optional .biorobotics.firmware.protos.Echo echo = 8;
  inline bool has_echo() const;
  inline void clear_echo();
  static const int kEchoFieldNumber = 8;
  inline const ::biorobotics::firmware::protos::Echo& echo() const;
  inline ::biorobotics::firmware::protos::Echo* mutable_echo();
  inline ::biorobotics::firmware::protos::Echo* release_echo();
  inline void set_allocated_echo(::biorobotics::firmware::protos::Echo* echo);

  // optional .biorobotics.firmware.protos.Command command = 10;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 10;
  inline const ::biorobotics::firmware::protos::Command& command() const;
  inline ::biorobotics::firmware::protos::Command* mutable_command();
  inline ::biorobotics::firmware::protos::Command* release_command();
  inline void set_allocated_command(::biorobotics::firmware::protos::Command* command);

  // optional bool request_command = 13;
  inline bool has_request_command() const;
  inline void clear_request_command();
  static const int kRequestCommandFieldNumber = 13;
  inline bool request_command() const;
  inline void set_request_command(bool value);

  // optional .biorobotics.firmware.protos.Feedback feedback = 11;
  inline bool has_feedback() const;
  inline void clear_feedback();
  static const int kFeedbackFieldNumber = 11;
  inline const ::biorobotics::firmware::protos::Feedback& feedback() const;
  inline ::biorobotics::firmware::protos::Feedback* mutable_feedback();
  inline ::biorobotics::firmware::protos::Feedback* release_feedback();
  inline void set_allocated_feedback(::biorobotics::firmware::protos::Feedback* feedback);

  // optional bool request_feedback = 12;
  inline bool has_request_feedback() const;
  inline void clear_request_feedback();
  static const int kRequestFeedbackFieldNumber = 12;
  inline bool request_feedback() const;
  inline void set_request_feedback(bool value);

  // optional .biorobotics.firmware.protos.settings.Settings settings = 20;
  inline bool has_settings() const;
  inline void clear_settings();
  static const int kSettingsFieldNumber = 20;
  inline const ::biorobotics::firmware::protos::settings::Settings& settings() const;
  inline ::biorobotics::firmware::protos::settings::Settings* mutable_settings();
  inline ::biorobotics::firmware::protos::settings::Settings* release_settings();
  inline void set_allocated_settings(::biorobotics::firmware::protos::settings::Settings* settings);

  // optional bool request_settings = 21;
  inline bool has_request_settings() const;
  inline void clear_request_settings();
  static const int kRequestSettingsFieldNumber = 21;
  inline bool request_settings() const;
  inline void set_request_settings(bool value);

  // optional .biorobotics.firmware.protos.RemoteServices remote_services = 31;
  inline bool has_remote_services() const;
  inline void clear_remote_services();
  static const int kRemoteServicesFieldNumber = 31;
  inline const ::biorobotics::firmware::protos::RemoteServices& remote_services() const;
  inline ::biorobotics::firmware::protos::RemoteServices* mutable_remote_services();
  inline ::biorobotics::firmware::protos::RemoteServices* release_remote_services();
  inline void set_allocated_remote_services(::biorobotics::firmware::protos::RemoteServices* remote_services);

  // optional bool request_remote_services = 32;
  inline bool has_request_remote_services() const;
  inline void clear_request_remote_services();
  static const int kRequestRemoteServicesFieldNumber = 32;
  inline bool request_remote_services() const;
  inline void set_request_remote_services(bool value);

  // optional bool reset = 80;
  inline bool has_reset() const;
  inline void clear_reset();
  static const int kResetFieldNumber = 80;
  inline bool reset() const;
  inline void set_reset(bool value);

  // optional .biorobotics.firmware.protos.DebugMessage debug = 90;
  inline bool has_debug() const;
  inline void clear_debug();
  static const int kDebugFieldNumber = 90;
  inline const ::biorobotics::firmware::protos::DebugMessage& debug() const;
  inline ::biorobotics::firmware::protos::DebugMessage* mutable_debug();
  inline ::biorobotics::firmware::protos::DebugMessage* release_debug();
  inline void set_allocated_debug(::biorobotics::firmware::protos::DebugMessage* debug);

  // @@protoc_insertion_point(class_scope:biorobotics.firmware.protos.RootMessage)
 private:
  inline void set_has_firmware_info();
  inline void clear_has_firmware_info();
  inline void set_has_request_firmware_info();
  inline void clear_has_request_firmware_info();
  inline void set_has_hardware_info();
  inline void clear_has_hardware_info();
  inline void set_has_request_hardware_info();
  inline void clear_has_request_hardware_info();
  inline void set_has_ethernet_info();
  inline void clear_has_ethernet_info();
  inline void set_has_request_ethernet_info();
  inline void clear_has_request_ethernet_info();
  inline void set_has_rx_time_sec();
  inline void clear_has_rx_time_sec();
  inline void set_has_rx_time_usec();
  inline void clear_has_rx_time_usec();
  inline void set_has_tx_time_sec();
  inline void clear_has_tx_time_sec();
  inline void set_has_tx_time_usec();
  inline void clear_has_tx_time_usec();
  inline void set_has_echo();
  inline void clear_has_echo();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_request_command();
  inline void clear_has_request_command();
  inline void set_has_feedback();
  inline void clear_has_feedback();
  inline void set_has_request_feedback();
  inline void clear_has_request_feedback();
  inline void set_has_settings();
  inline void clear_has_settings();
  inline void set_has_request_settings();
  inline void clear_has_request_settings();
  inline void set_has_remote_services();
  inline void clear_has_remote_services();
  inline void set_has_request_remote_services();
  inline void clear_has_request_remote_services();
  inline void set_has_reset();
  inline void clear_has_reset();
  inline void set_has_debug();
  inline void clear_has_debug();

  ::biorobotics::firmware::protos::FirmwareInfo* firmware_info_;
  ::biorobotics::firmware::protos::HardwareInfo* hardware_info_;
  ::biorobotics::firmware::protos::EthernetInfo* ethernet_info_;
  bool request_firmware_info_;
  bool request_hardware_info_;
  bool request_ethernet_info_;
  bool request_command_;
  ::google::protobuf::uint32 rx_time_sec_;
  ::google::protobuf::uint32 rx_time_usec_;
  ::google::protobuf::uint32 tx_time_sec_;
  ::biorobotics::firmware::protos::Echo* echo_;
  ::biorobotics::firmware::protos::Command* command_;
  ::biorobotics::firmware::protos::Feedback* feedback_;
  ::biorobotics::firmware::protos::settings::Settings* settings_;
  ::google::protobuf::uint32 tx_time_usec_;
  bool request_feedback_;
  bool request_settings_;
  bool request_remote_services_;
  bool reset_;
  ::biorobotics::firmware::protos::RemoteServices* remote_services_;
  ::biorobotics::firmware::protos::DebugMessage* debug_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Core_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Core_2eproto();
  #endif
  friend void protobuf_AssignDesc_Core_2eproto();
  friend void protobuf_ShutdownFile_Core_2eproto();

  void InitAsDefaultInstance();
  static RootMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// Echo

// optional bytes payload = 1;
inline bool Echo::has_payload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Echo::set_has_payload() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Echo::clear_has_payload() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Echo::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& Echo::payload() const {
  return *payload_;
}
inline void Echo::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void Echo::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void Echo::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Echo::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* Echo::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Echo::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 tx_time_sec = 2;
inline bool Echo::has_tx_time_sec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Echo::set_has_tx_time_sec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Echo::clear_has_tx_time_sec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Echo::clear_tx_time_sec() {
  tx_time_sec_ = 0u;
  clear_has_tx_time_sec();
}
inline ::google::protobuf::uint32 Echo::tx_time_sec() const {
  return tx_time_sec_;
}
inline void Echo::set_tx_time_sec(::google::protobuf::uint32 value) {
  set_has_tx_time_sec();
  tx_time_sec_ = value;
}

// optional uint32 tx_time_usec = 3;
inline bool Echo::has_tx_time_usec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Echo::set_has_tx_time_usec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Echo::clear_has_tx_time_usec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Echo::clear_tx_time_usec() {
  tx_time_usec_ = 0u;
  clear_has_tx_time_usec();
}
inline ::google::protobuf::uint32 Echo::tx_time_usec() const {
  return tx_time_usec_;
}
inline void Echo::set_tx_time_usec(::google::protobuf::uint32 value) {
  set_has_tx_time_usec();
  tx_time_usec_ = value;
}

// -------------------------------------------------------------------

// FirmwareInfo

// optional string version = 1;
inline bool FirmwareInfo::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FirmwareInfo::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FirmwareInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FirmwareInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& FirmwareInfo::version() const {
  return *version_;
}
inline void FirmwareInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void FirmwareInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void FirmwareInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FirmwareInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* FirmwareInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FirmwareInfo::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string build_date = 2;
inline bool FirmwareInfo::has_build_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FirmwareInfo::set_has_build_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FirmwareInfo::clear_has_build_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FirmwareInfo::clear_build_date() {
  if (build_date_ != &::google::protobuf::internal::kEmptyString) {
    build_date_->clear();
  }
  clear_has_build_date();
}
inline const ::std::string& FirmwareInfo::build_date() const {
  return *build_date_;
}
inline void FirmwareInfo::set_build_date(const ::std::string& value) {
  set_has_build_date();
  if (build_date_ == &::google::protobuf::internal::kEmptyString) {
    build_date_ = new ::std::string;
  }
  build_date_->assign(value);
}
inline void FirmwareInfo::set_build_date(const char* value) {
  set_has_build_date();
  if (build_date_ == &::google::protobuf::internal::kEmptyString) {
    build_date_ = new ::std::string;
  }
  build_date_->assign(value);
}
inline void FirmwareInfo::set_build_date(const char* value, size_t size) {
  set_has_build_date();
  if (build_date_ == &::google::protobuf::internal::kEmptyString) {
    build_date_ = new ::std::string;
  }
  build_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FirmwareInfo::mutable_build_date() {
  set_has_build_date();
  if (build_date_ == &::google::protobuf::internal::kEmptyString) {
    build_date_ = new ::std::string;
  }
  return build_date_;
}
inline ::std::string* FirmwareInfo::release_build_date() {
  clear_has_build_date();
  if (build_date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = build_date_;
    build_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FirmwareInfo::set_allocated_build_date(::std::string* build_date) {
  if (build_date_ != &::google::protobuf::internal::kEmptyString) {
    delete build_date_;
  }
  if (build_date) {
    set_has_build_date();
    build_date_ = build_date;
  } else {
    clear_has_build_date();
    build_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tag = 3;
inline bool FirmwareInfo::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FirmwareInfo::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FirmwareInfo::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FirmwareInfo::clear_tag() {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& FirmwareInfo::tag() const {
  return *tag_;
}
inline void FirmwareInfo::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void FirmwareInfo::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void FirmwareInfo::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FirmwareInfo::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  return tag_;
}
inline ::std::string* FirmwareInfo::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FirmwareInfo::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string username = 4;
inline bool FirmwareInfo::has_username() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FirmwareInfo::set_has_username() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FirmwareInfo::clear_has_username() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FirmwareInfo::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& FirmwareInfo::username() const {
  return *username_;
}
inline void FirmwareInfo::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void FirmwareInfo::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void FirmwareInfo::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FirmwareInfo::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* FirmwareInfo::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FirmwareInfo::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .biorobotics.firmware.protos.FirmwareInfo.FirmwareType type = 10;
inline bool FirmwareInfo::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FirmwareInfo::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FirmwareInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FirmwareInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::biorobotics::firmware::protos::FirmwareInfo_FirmwareType FirmwareInfo::type() const {
  return static_cast< ::biorobotics::firmware::protos::FirmwareInfo_FirmwareType >(type_);
}
inline void FirmwareInfo::set_type(::biorobotics::firmware::protos::FirmwareInfo_FirmwareType value) {
  assert(::biorobotics::firmware::protos::FirmwareInfo_FirmwareType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// HardwareInfo

// optional bytes serial_number = 1;
inline bool HardwareInfo::has_serial_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HardwareInfo::set_has_serial_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HardwareInfo::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HardwareInfo::clear_serial_number() {
  if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
    serial_number_->clear();
  }
  clear_has_serial_number();
}
inline const ::std::string& HardwareInfo::serial_number() const {
  return *serial_number_;
}
inline void HardwareInfo::set_serial_number(const ::std::string& value) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(value);
}
inline void HardwareInfo::set_serial_number(const char* value) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(value);
}
inline void HardwareInfo::set_serial_number(const void* value, size_t size) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HardwareInfo::mutable_serial_number() {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  return serial_number_;
}
inline ::std::string* HardwareInfo::release_serial_number() {
  clear_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serial_number_;
    serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HardwareInfo::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
    delete serial_number_;
  }
  if (serial_number) {
    set_has_serial_number();
    serial_number_ = serial_number;
  } else {
    clear_has_serial_number();
    serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string type = 5;
inline bool HardwareInfo::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HardwareInfo::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HardwareInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HardwareInfo::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& HardwareInfo::type() const {
  return *type_;
}
inline void HardwareInfo::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void HardwareInfo::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void HardwareInfo::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HardwareInfo::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* HardwareInfo::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HardwareInfo::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string revision = 6;
inline bool HardwareInfo::has_revision() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HardwareInfo::set_has_revision() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HardwareInfo::clear_has_revision() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HardwareInfo::clear_revision() {
  if (revision_ != &::google::protobuf::internal::kEmptyString) {
    revision_->clear();
  }
  clear_has_revision();
}
inline const ::std::string& HardwareInfo::revision() const {
  return *revision_;
}
inline void HardwareInfo::set_revision(const ::std::string& value) {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::kEmptyString) {
    revision_ = new ::std::string;
  }
  revision_->assign(value);
}
inline void HardwareInfo::set_revision(const char* value) {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::kEmptyString) {
    revision_ = new ::std::string;
  }
  revision_->assign(value);
}
inline void HardwareInfo::set_revision(const char* value, size_t size) {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::kEmptyString) {
    revision_ = new ::std::string;
  }
  revision_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HardwareInfo::mutable_revision() {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::kEmptyString) {
    revision_ = new ::std::string;
  }
  return revision_;
}
inline ::std::string* HardwareInfo::release_revision() {
  clear_has_revision();
  if (revision_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = revision_;
    revision_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HardwareInfo::set_allocated_revision(::std::string* revision) {
  if (revision_ != &::google::protobuf::internal::kEmptyString) {
    delete revision_;
  }
  if (revision) {
    set_has_revision();
    revision_ = revision;
  } else {
    clear_has_revision();
    revision_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string processor = 7;
inline bool HardwareInfo::has_processor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HardwareInfo::set_has_processor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HardwareInfo::clear_has_processor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HardwareInfo::clear_processor() {
  if (processor_ != &::google::protobuf::internal::kEmptyString) {
    processor_->clear();
  }
  clear_has_processor();
}
inline const ::std::string& HardwareInfo::processor() const {
  return *processor_;
}
inline void HardwareInfo::set_processor(const ::std::string& value) {
  set_has_processor();
  if (processor_ == &::google::protobuf::internal::kEmptyString) {
    processor_ = new ::std::string;
  }
  processor_->assign(value);
}
inline void HardwareInfo::set_processor(const char* value) {
  set_has_processor();
  if (processor_ == &::google::protobuf::internal::kEmptyString) {
    processor_ = new ::std::string;
  }
  processor_->assign(value);
}
inline void HardwareInfo::set_processor(const char* value, size_t size) {
  set_has_processor();
  if (processor_ == &::google::protobuf::internal::kEmptyString) {
    processor_ = new ::std::string;
  }
  processor_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HardwareInfo::mutable_processor() {
  set_has_processor();
  if (processor_ == &::google::protobuf::internal::kEmptyString) {
    processor_ = new ::std::string;
  }
  return processor_;
}
inline ::std::string* HardwareInfo::release_processor() {
  clear_has_processor();
  if (processor_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = processor_;
    processor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HardwareInfo::set_allocated_processor(::std::string* processor) {
  if (processor_ != &::google::protobuf::internal::kEmptyString) {
    delete processor_;
  }
  if (processor) {
    set_has_processor();
    processor_ = processor;
  } else {
    clear_has_processor();
    processor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EthernetInfo

// optional bytes mac_address = 10;
inline bool EthernetInfo::has_mac_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EthernetInfo::set_has_mac_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EthernetInfo::clear_has_mac_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EthernetInfo::clear_mac_address() {
  if (mac_address_ != &::google::protobuf::internal::kEmptyString) {
    mac_address_->clear();
  }
  clear_has_mac_address();
}
inline const ::std::string& EthernetInfo::mac_address() const {
  return *mac_address_;
}
inline void EthernetInfo::set_mac_address(const ::std::string& value) {
  set_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    mac_address_ = new ::std::string;
  }
  mac_address_->assign(value);
}
inline void EthernetInfo::set_mac_address(const char* value) {
  set_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    mac_address_ = new ::std::string;
  }
  mac_address_->assign(value);
}
inline void EthernetInfo::set_mac_address(const void* value, size_t size) {
  set_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    mac_address_ = new ::std::string;
  }
  mac_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EthernetInfo::mutable_mac_address() {
  set_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    mac_address_ = new ::std::string;
  }
  return mac_address_;
}
inline ::std::string* EthernetInfo::release_mac_address() {
  clear_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mac_address_;
    mac_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EthernetInfo::set_allocated_mac_address(::std::string* mac_address) {
  if (mac_address_ != &::google::protobuf::internal::kEmptyString) {
    delete mac_address_;
  }
  if (mac_address) {
    set_has_mac_address();
    mac_address_ = mac_address;
  } else {
    clear_has_mac_address();
    mac_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes ip_address = 20;
inline bool EthernetInfo::has_ip_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EthernetInfo::set_has_ip_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EthernetInfo::clear_has_ip_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EthernetInfo::clear_ip_address() {
  if (ip_address_ != &::google::protobuf::internal::kEmptyString) {
    ip_address_->clear();
  }
  clear_has_ip_address();
}
inline const ::std::string& EthernetInfo::ip_address() const {
  return *ip_address_;
}
inline void EthernetInfo::set_ip_address(const ::std::string& value) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::kEmptyString) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(value);
}
inline void EthernetInfo::set_ip_address(const char* value) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::kEmptyString) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(value);
}
inline void EthernetInfo::set_ip_address(const void* value, size_t size) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::kEmptyString) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EthernetInfo::mutable_ip_address() {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::kEmptyString) {
    ip_address_ = new ::std::string;
  }
  return ip_address_;
}
inline ::std::string* EthernetInfo::release_ip_address() {
  clear_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_address_;
    ip_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EthernetInfo::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_address_;
  }
  if (ip_address) {
    set_has_ip_address();
    ip_address_ = ip_address;
  } else {
    clear_has_ip_address();
    ip_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes netmask = 21;
inline bool EthernetInfo::has_netmask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EthernetInfo::set_has_netmask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EthernetInfo::clear_has_netmask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EthernetInfo::clear_netmask() {
  if (netmask_ != &::google::protobuf::internal::kEmptyString) {
    netmask_->clear();
  }
  clear_has_netmask();
}
inline const ::std::string& EthernetInfo::netmask() const {
  return *netmask_;
}
inline void EthernetInfo::set_netmask(const ::std::string& value) {
  set_has_netmask();
  if (netmask_ == &::google::protobuf::internal::kEmptyString) {
    netmask_ = new ::std::string;
  }
  netmask_->assign(value);
}
inline void EthernetInfo::set_netmask(const char* value) {
  set_has_netmask();
  if (netmask_ == &::google::protobuf::internal::kEmptyString) {
    netmask_ = new ::std::string;
  }
  netmask_->assign(value);
}
inline void EthernetInfo::set_netmask(const void* value, size_t size) {
  set_has_netmask();
  if (netmask_ == &::google::protobuf::internal::kEmptyString) {
    netmask_ = new ::std::string;
  }
  netmask_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EthernetInfo::mutable_netmask() {
  set_has_netmask();
  if (netmask_ == &::google::protobuf::internal::kEmptyString) {
    netmask_ = new ::std::string;
  }
  return netmask_;
}
inline ::std::string* EthernetInfo::release_netmask() {
  clear_has_netmask();
  if (netmask_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = netmask_;
    netmask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EthernetInfo::set_allocated_netmask(::std::string* netmask) {
  if (netmask_ != &::google::protobuf::internal::kEmptyString) {
    delete netmask_;
  }
  if (netmask) {
    set_has_netmask();
    netmask_ = netmask;
  } else {
    clear_has_netmask();
    netmask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gateway = 22;
inline bool EthernetInfo::has_gateway() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EthernetInfo::set_has_gateway() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EthernetInfo::clear_has_gateway() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EthernetInfo::clear_gateway() {
  if (gateway_ != &::google::protobuf::internal::kEmptyString) {
    gateway_->clear();
  }
  clear_has_gateway();
}
inline const ::std::string& EthernetInfo::gateway() const {
  return *gateway_;
}
inline void EthernetInfo::set_gateway(const ::std::string& value) {
  set_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    gateway_ = new ::std::string;
  }
  gateway_->assign(value);
}
inline void EthernetInfo::set_gateway(const char* value) {
  set_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    gateway_ = new ::std::string;
  }
  gateway_->assign(value);
}
inline void EthernetInfo::set_gateway(const void* value, size_t size) {
  set_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    gateway_ = new ::std::string;
  }
  gateway_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EthernetInfo::mutable_gateway() {
  set_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    gateway_ = new ::std::string;
  }
  return gateway_;
}
inline ::std::string* EthernetInfo::release_gateway() {
  clear_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gateway_;
    gateway_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EthernetInfo::set_allocated_gateway(::std::string* gateway) {
  if (gateway_ != &::google::protobuf::internal::kEmptyString) {
    delete gateway_;
  }
  if (gateway) {
    set_has_gateway();
    gateway_ = gateway;
  } else {
    clear_has_gateway();
    gateway_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes proximal_ip = 40;
inline bool EthernetInfo::has_proximal_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EthernetInfo::set_has_proximal_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EthernetInfo::clear_has_proximal_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EthernetInfo::clear_proximal_ip() {
  if (proximal_ip_ != &::google::protobuf::internal::kEmptyString) {
    proximal_ip_->clear();
  }
  clear_has_proximal_ip();
}
inline const ::std::string& EthernetInfo::proximal_ip() const {
  return *proximal_ip_;
}
inline void EthernetInfo::set_proximal_ip(const ::std::string& value) {
  set_has_proximal_ip();
  if (proximal_ip_ == &::google::protobuf::internal::kEmptyString) {
    proximal_ip_ = new ::std::string;
  }
  proximal_ip_->assign(value);
}
inline void EthernetInfo::set_proximal_ip(const char* value) {
  set_has_proximal_ip();
  if (proximal_ip_ == &::google::protobuf::internal::kEmptyString) {
    proximal_ip_ = new ::std::string;
  }
  proximal_ip_->assign(value);
}
inline void EthernetInfo::set_proximal_ip(const void* value, size_t size) {
  set_has_proximal_ip();
  if (proximal_ip_ == &::google::protobuf::internal::kEmptyString) {
    proximal_ip_ = new ::std::string;
  }
  proximal_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EthernetInfo::mutable_proximal_ip() {
  set_has_proximal_ip();
  if (proximal_ip_ == &::google::protobuf::internal::kEmptyString) {
    proximal_ip_ = new ::std::string;
  }
  return proximal_ip_;
}
inline ::std::string* EthernetInfo::release_proximal_ip() {
  clear_has_proximal_ip();
  if (proximal_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proximal_ip_;
    proximal_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EthernetInfo::set_allocated_proximal_ip(::std::string* proximal_ip) {
  if (proximal_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete proximal_ip_;
  }
  if (proximal_ip) {
    set_has_proximal_ip();
    proximal_ip_ = proximal_ip;
  } else {
    clear_has_proximal_ip();
    proximal_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated bytes distal_ips = 42;
inline int EthernetInfo::distal_ips_size() const {
  return distal_ips_.size();
}
inline void EthernetInfo::clear_distal_ips() {
  distal_ips_.Clear();
}
inline const ::std::string& EthernetInfo::distal_ips(int index) const {
  return distal_ips_.Get(index);
}
inline ::std::string* EthernetInfo::mutable_distal_ips(int index) {
  return distal_ips_.Mutable(index);
}
inline void EthernetInfo::set_distal_ips(int index, const ::std::string& value) {
  distal_ips_.Mutable(index)->assign(value);
}
inline void EthernetInfo::set_distal_ips(int index, const char* value) {
  distal_ips_.Mutable(index)->assign(value);
}
inline void EthernetInfo::set_distal_ips(int index, const void* value, size_t size) {
  distal_ips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EthernetInfo::add_distal_ips() {
  return distal_ips_.Add();
}
inline void EthernetInfo::add_distal_ips(const ::std::string& value) {
  distal_ips_.Add()->assign(value);
}
inline void EthernetInfo::add_distal_ips(const char* value) {
  distal_ips_.Add()->assign(value);
}
inline void EthernetInfo::add_distal_ips(const void* value, size_t size) {
  distal_ips_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
EthernetInfo::distal_ips() const {
  return distal_ips_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
EthernetInfo::mutable_distal_ips() {
  return &distal_ips_;
}

// -------------------------------------------------------------------

// DebugMessage

// repeated bytes bytes_payloads = 1;
inline int DebugMessage::bytes_payloads_size() const {
  return bytes_payloads_.size();
}
inline void DebugMessage::clear_bytes_payloads() {
  bytes_payloads_.Clear();
}
inline const ::std::string& DebugMessage::bytes_payloads(int index) const {
  return bytes_payloads_.Get(index);
}
inline ::std::string* DebugMessage::mutable_bytes_payloads(int index) {
  return bytes_payloads_.Mutable(index);
}
inline void DebugMessage::set_bytes_payloads(int index, const ::std::string& value) {
  bytes_payloads_.Mutable(index)->assign(value);
}
inline void DebugMessage::set_bytes_payloads(int index, const char* value) {
  bytes_payloads_.Mutable(index)->assign(value);
}
inline void DebugMessage::set_bytes_payloads(int index, const void* value, size_t size) {
  bytes_payloads_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DebugMessage::add_bytes_payloads() {
  return bytes_payloads_.Add();
}
inline void DebugMessage::add_bytes_payloads(const ::std::string& value) {
  bytes_payloads_.Add()->assign(value);
}
inline void DebugMessage::add_bytes_payloads(const char* value) {
  bytes_payloads_.Add()->assign(value);
}
inline void DebugMessage::add_bytes_payloads(const void* value, size_t size) {
  bytes_payloads_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DebugMessage::bytes_payloads() const {
  return bytes_payloads_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DebugMessage::mutable_bytes_payloads() {
  return &bytes_payloads_;
}

// repeated float float_payloads = 2;
inline int DebugMessage::float_payloads_size() const {
  return float_payloads_.size();
}
inline void DebugMessage::clear_float_payloads() {
  float_payloads_.Clear();
}
inline float DebugMessage::float_payloads(int index) const {
  return float_payloads_.Get(index);
}
inline void DebugMessage::set_float_payloads(int index, float value) {
  float_payloads_.Set(index, value);
}
inline void DebugMessage::add_float_payloads(float value) {
  float_payloads_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
DebugMessage::float_payloads() const {
  return float_payloads_;
}
inline ::google::protobuf::RepeatedField< float >*
DebugMessage::mutable_float_payloads() {
  return &float_payloads_;
}

// repeated string float_payloads_units = 3;
inline int DebugMessage::float_payloads_units_size() const {
  return float_payloads_units_.size();
}
inline void DebugMessage::clear_float_payloads_units() {
  float_payloads_units_.Clear();
}
inline const ::std::string& DebugMessage::float_payloads_units(int index) const {
  return float_payloads_units_.Get(index);
}
inline ::std::string* DebugMessage::mutable_float_payloads_units(int index) {
  return float_payloads_units_.Mutable(index);
}
inline void DebugMessage::set_float_payloads_units(int index, const ::std::string& value) {
  float_payloads_units_.Mutable(index)->assign(value);
}
inline void DebugMessage::set_float_payloads_units(int index, const char* value) {
  float_payloads_units_.Mutable(index)->assign(value);
}
inline void DebugMessage::set_float_payloads_units(int index, const char* value, size_t size) {
  float_payloads_units_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DebugMessage::add_float_payloads_units() {
  return float_payloads_units_.Add();
}
inline void DebugMessage::add_float_payloads_units(const ::std::string& value) {
  float_payloads_units_.Add()->assign(value);
}
inline void DebugMessage::add_float_payloads_units(const char* value) {
  float_payloads_units_.Add()->assign(value);
}
inline void DebugMessage::add_float_payloads_units(const char* value, size_t size) {
  float_payloads_units_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DebugMessage::float_payloads_units() const {
  return float_payloads_units_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DebugMessage::mutable_float_payloads_units() {
  return &float_payloads_units_;
}

// -------------------------------------------------------------------

// RootMessage

// optional .biorobotics.firmware.protos.FirmwareInfo firmware_info = 1010;
inline bool RootMessage::has_firmware_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RootMessage::set_has_firmware_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RootMessage::clear_has_firmware_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RootMessage::clear_firmware_info() {
  if (firmware_info_ != NULL) firmware_info_->::biorobotics::firmware::protos::FirmwareInfo::Clear();
  clear_has_firmware_info();
}
inline const ::biorobotics::firmware::protos::FirmwareInfo& RootMessage::firmware_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return firmware_info_ != NULL ? *firmware_info_ : *default_instance().firmware_info_;
#else
  return firmware_info_ != NULL ? *firmware_info_ : *default_instance_->firmware_info_;
#endif
}
inline ::biorobotics::firmware::protos::FirmwareInfo* RootMessage::mutable_firmware_info() {
  set_has_firmware_info();
  if (firmware_info_ == NULL) firmware_info_ = new ::biorobotics::firmware::protos::FirmwareInfo;
  return firmware_info_;
}
inline ::biorobotics::firmware::protos::FirmwareInfo* RootMessage::release_firmware_info() {
  clear_has_firmware_info();
  ::biorobotics::firmware::protos::FirmwareInfo* temp = firmware_info_;
  firmware_info_ = NULL;
  return temp;
}
inline void RootMessage::set_allocated_firmware_info(::biorobotics::firmware::protos::FirmwareInfo* firmware_info) {
  delete firmware_info_;
  firmware_info_ = firmware_info;
  if (firmware_info) {
    set_has_firmware_info();
  } else {
    clear_has_firmware_info();
  }
}

// optional bool request_firmware_info = 1011;
inline bool RootMessage::has_request_firmware_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RootMessage::set_has_request_firmware_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RootMessage::clear_has_request_firmware_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RootMessage::clear_request_firmware_info() {
  request_firmware_info_ = false;
  clear_has_request_firmware_info();
}
inline bool RootMessage::request_firmware_info() const {
  return request_firmware_info_;
}
inline void RootMessage::set_request_firmware_info(bool value) {
  set_has_request_firmware_info();
  request_firmware_info_ = value;
}

// optional .biorobotics.firmware.protos.HardwareInfo hardware_info = 1012;
inline bool RootMessage::has_hardware_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RootMessage::set_has_hardware_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RootMessage::clear_has_hardware_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RootMessage::clear_hardware_info() {
  if (hardware_info_ != NULL) hardware_info_->::biorobotics::firmware::protos::HardwareInfo::Clear();
  clear_has_hardware_info();
}
inline const ::biorobotics::firmware::protos::HardwareInfo& RootMessage::hardware_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return hardware_info_ != NULL ? *hardware_info_ : *default_instance().hardware_info_;
#else
  return hardware_info_ != NULL ? *hardware_info_ : *default_instance_->hardware_info_;
#endif
}
inline ::biorobotics::firmware::protos::HardwareInfo* RootMessage::mutable_hardware_info() {
  set_has_hardware_info();
  if (hardware_info_ == NULL) hardware_info_ = new ::biorobotics::firmware::protos::HardwareInfo;
  return hardware_info_;
}
inline ::biorobotics::firmware::protos::HardwareInfo* RootMessage::release_hardware_info() {
  clear_has_hardware_info();
  ::biorobotics::firmware::protos::HardwareInfo* temp = hardware_info_;
  hardware_info_ = NULL;
  return temp;
}
inline void RootMessage::set_allocated_hardware_info(::biorobotics::firmware::protos::HardwareInfo* hardware_info) {
  delete hardware_info_;
  hardware_info_ = hardware_info;
  if (hardware_info) {
    set_has_hardware_info();
  } else {
    clear_has_hardware_info();
  }
}

// optional bool request_hardware_info = 1013;
inline bool RootMessage::has_request_hardware_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RootMessage::set_has_request_hardware_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RootMessage::clear_has_request_hardware_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RootMessage::clear_request_hardware_info() {
  request_hardware_info_ = false;
  clear_has_request_hardware_info();
}
inline bool RootMessage::request_hardware_info() const {
  return request_hardware_info_;
}
inline void RootMessage::set_request_hardware_info(bool value) {
  set_has_request_hardware_info();
  request_hardware_info_ = value;
}

// optional .biorobotics.firmware.protos.EthernetInfo ethernet_info = 1015;
inline bool RootMessage::has_ethernet_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RootMessage::set_has_ethernet_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RootMessage::clear_has_ethernet_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RootMessage::clear_ethernet_info() {
  if (ethernet_info_ != NULL) ethernet_info_->::biorobotics::firmware::protos::EthernetInfo::Clear();
  clear_has_ethernet_info();
}
inline const ::biorobotics::firmware::protos::EthernetInfo& RootMessage::ethernet_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ethernet_info_ != NULL ? *ethernet_info_ : *default_instance().ethernet_info_;
#else
  return ethernet_info_ != NULL ? *ethernet_info_ : *default_instance_->ethernet_info_;
#endif
}
inline ::biorobotics::firmware::protos::EthernetInfo* RootMessage::mutable_ethernet_info() {
  set_has_ethernet_info();
  if (ethernet_info_ == NULL) ethernet_info_ = new ::biorobotics::firmware::protos::EthernetInfo;
  return ethernet_info_;
}
inline ::biorobotics::firmware::protos::EthernetInfo* RootMessage::release_ethernet_info() {
  clear_has_ethernet_info();
  ::biorobotics::firmware::protos::EthernetInfo* temp = ethernet_info_;
  ethernet_info_ = NULL;
  return temp;
}
inline void RootMessage::set_allocated_ethernet_info(::biorobotics::firmware::protos::EthernetInfo* ethernet_info) {
  delete ethernet_info_;
  ethernet_info_ = ethernet_info;
  if (ethernet_info) {
    set_has_ethernet_info();
  } else {
    clear_has_ethernet_info();
  }
}

// optional bool request_ethernet_info = 1016;
inline bool RootMessage::has_request_ethernet_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RootMessage::set_has_request_ethernet_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RootMessage::clear_has_request_ethernet_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RootMessage::clear_request_ethernet_info() {
  request_ethernet_info_ = false;
  clear_has_request_ethernet_info();
}
inline bool RootMessage::request_ethernet_info() const {
  return request_ethernet_info_;
}
inline void RootMessage::set_request_ethernet_info(bool value) {
  set_has_request_ethernet_info();
  request_ethernet_info_ = value;
}

// optional uint32 rx_time_sec = 3;
inline bool RootMessage::has_rx_time_sec() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RootMessage::set_has_rx_time_sec() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RootMessage::clear_has_rx_time_sec() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RootMessage::clear_rx_time_sec() {
  rx_time_sec_ = 0u;
  clear_has_rx_time_sec();
}
inline ::google::protobuf::uint32 RootMessage::rx_time_sec() const {
  return rx_time_sec_;
}
inline void RootMessage::set_rx_time_sec(::google::protobuf::uint32 value) {
  set_has_rx_time_sec();
  rx_time_sec_ = value;
}

// optional uint32 rx_time_usec = 4;
inline bool RootMessage::has_rx_time_usec() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RootMessage::set_has_rx_time_usec() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RootMessage::clear_has_rx_time_usec() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RootMessage::clear_rx_time_usec() {
  rx_time_usec_ = 0u;
  clear_has_rx_time_usec();
}
inline ::google::protobuf::uint32 RootMessage::rx_time_usec() const {
  return rx_time_usec_;
}
inline void RootMessage::set_rx_time_usec(::google::protobuf::uint32 value) {
  set_has_rx_time_usec();
  rx_time_usec_ = value;
}

// optional uint32 tx_time_sec = 5;
inline bool RootMessage::has_tx_time_sec() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RootMessage::set_has_tx_time_sec() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RootMessage::clear_has_tx_time_sec() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RootMessage::clear_tx_time_sec() {
  tx_time_sec_ = 0u;
  clear_has_tx_time_sec();
}
inline ::google::protobuf::uint32 RootMessage::tx_time_sec() const {
  return tx_time_sec_;
}
inline void RootMessage::set_tx_time_sec(::google::protobuf::uint32 value) {
  set_has_tx_time_sec();
  tx_time_sec_ = value;
}

// optional uint32 tx_time_usec = 6;
inline bool RootMessage::has_tx_time_usec() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RootMessage::set_has_tx_time_usec() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RootMessage::clear_has_tx_time_usec() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RootMessage::clear_tx_time_usec() {
  tx_time_usec_ = 0u;
  clear_has_tx_time_usec();
}
inline ::google::protobuf::uint32 RootMessage::tx_time_usec() const {
  return tx_time_usec_;
}
inline void RootMessage::set_tx_time_usec(::google::protobuf::uint32 value) {
  set_has_tx_time_usec();
  tx_time_usec_ = value;
}

// optional .biorobotics.firmware.protos.Echo echo = 8;
inline bool RootMessage::has_echo() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RootMessage::set_has_echo() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RootMessage::clear_has_echo() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RootMessage::clear_echo() {
  if (echo_ != NULL) echo_->::biorobotics::firmware::protos::Echo::Clear();
  clear_has_echo();
}
inline const ::biorobotics::firmware::protos::Echo& RootMessage::echo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return echo_ != NULL ? *echo_ : *default_instance().echo_;
#else
  return echo_ != NULL ? *echo_ : *default_instance_->echo_;
#endif
}
inline ::biorobotics::firmware::protos::Echo* RootMessage::mutable_echo() {
  set_has_echo();
  if (echo_ == NULL) echo_ = new ::biorobotics::firmware::protos::Echo;
  return echo_;
}
inline ::biorobotics::firmware::protos::Echo* RootMessage::release_echo() {
  clear_has_echo();
  ::biorobotics::firmware::protos::Echo* temp = echo_;
  echo_ = NULL;
  return temp;
}
inline void RootMessage::set_allocated_echo(::biorobotics::firmware::protos::Echo* echo) {
  delete echo_;
  echo_ = echo;
  if (echo) {
    set_has_echo();
  } else {
    clear_has_echo();
  }
}

// optional .biorobotics.firmware.protos.Command command = 10;
inline bool RootMessage::has_command() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RootMessage::set_has_command() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RootMessage::clear_has_command() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RootMessage::clear_command() {
  if (command_ != NULL) command_->::biorobotics::firmware::protos::Command::Clear();
  clear_has_command();
}
inline const ::biorobotics::firmware::protos::Command& RootMessage::command() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return command_ != NULL ? *command_ : *default_instance().command_;
#else
  return command_ != NULL ? *command_ : *default_instance_->command_;
#endif
}
inline ::biorobotics::firmware::protos::Command* RootMessage::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::biorobotics::firmware::protos::Command;
  return command_;
}
inline ::biorobotics::firmware::protos::Command* RootMessage::release_command() {
  clear_has_command();
  ::biorobotics::firmware::protos::Command* temp = command_;
  command_ = NULL;
  return temp;
}
inline void RootMessage::set_allocated_command(::biorobotics::firmware::protos::Command* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
}

// optional bool request_command = 13;
inline bool RootMessage::has_request_command() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RootMessage::set_has_request_command() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RootMessage::clear_has_request_command() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RootMessage::clear_request_command() {
  request_command_ = false;
  clear_has_request_command();
}
inline bool RootMessage::request_command() const {
  return request_command_;
}
inline void RootMessage::set_request_command(bool value) {
  set_has_request_command();
  request_command_ = value;
}

// optional .biorobotics.firmware.protos.Feedback feedback = 11;
inline bool RootMessage::has_feedback() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RootMessage::set_has_feedback() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RootMessage::clear_has_feedback() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RootMessage::clear_feedback() {
  if (feedback_ != NULL) feedback_->::biorobotics::firmware::protos::Feedback::Clear();
  clear_has_feedback();
}
inline const ::biorobotics::firmware::protos::Feedback& RootMessage::feedback() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return feedback_ != NULL ? *feedback_ : *default_instance().feedback_;
#else
  return feedback_ != NULL ? *feedback_ : *default_instance_->feedback_;
#endif
}
inline ::biorobotics::firmware::protos::Feedback* RootMessage::mutable_feedback() {
  set_has_feedback();
  if (feedback_ == NULL) feedback_ = new ::biorobotics::firmware::protos::Feedback;
  return feedback_;
}
inline ::biorobotics::firmware::protos::Feedback* RootMessage::release_feedback() {
  clear_has_feedback();
  ::biorobotics::firmware::protos::Feedback* temp = feedback_;
  feedback_ = NULL;
  return temp;
}
inline void RootMessage::set_allocated_feedback(::biorobotics::firmware::protos::Feedback* feedback) {
  delete feedback_;
  feedback_ = feedback;
  if (feedback) {
    set_has_feedback();
  } else {
    clear_has_feedback();
  }
}

// optional bool request_feedback = 12;
inline bool RootMessage::has_request_feedback() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RootMessage::set_has_request_feedback() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RootMessage::clear_has_request_feedback() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RootMessage::clear_request_feedback() {
  request_feedback_ = false;
  clear_has_request_feedback();
}
inline bool RootMessage::request_feedback() const {
  return request_feedback_;
}
inline void RootMessage::set_request_feedback(bool value) {
  set_has_request_feedback();
  request_feedback_ = value;
}

// optional .biorobotics.firmware.protos.settings.Settings settings = 20;
inline bool RootMessage::has_settings() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RootMessage::set_has_settings() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RootMessage::clear_has_settings() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RootMessage::clear_settings() {
  if (settings_ != NULL) settings_->::biorobotics::firmware::protos::settings::Settings::Clear();
  clear_has_settings();
}
inline const ::biorobotics::firmware::protos::settings::Settings& RootMessage::settings() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return settings_ != NULL ? *settings_ : *default_instance().settings_;
#else
  return settings_ != NULL ? *settings_ : *default_instance_->settings_;
#endif
}
inline ::biorobotics::firmware::protos::settings::Settings* RootMessage::mutable_settings() {
  set_has_settings();
  if (settings_ == NULL) settings_ = new ::biorobotics::firmware::protos::settings::Settings;
  return settings_;
}
inline ::biorobotics::firmware::protos::settings::Settings* RootMessage::release_settings() {
  clear_has_settings();
  ::biorobotics::firmware::protos::settings::Settings* temp = settings_;
  settings_ = NULL;
  return temp;
}
inline void RootMessage::set_allocated_settings(::biorobotics::firmware::protos::settings::Settings* settings) {
  delete settings_;
  settings_ = settings;
  if (settings) {
    set_has_settings();
  } else {
    clear_has_settings();
  }
}

// optional bool request_settings = 21;
inline bool RootMessage::has_request_settings() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RootMessage::set_has_request_settings() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RootMessage::clear_has_request_settings() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RootMessage::clear_request_settings() {
  request_settings_ = false;
  clear_has_request_settings();
}
inline bool RootMessage::request_settings() const {
  return request_settings_;
}
inline void RootMessage::set_request_settings(bool value) {
  set_has_request_settings();
  request_settings_ = value;
}

// optional .biorobotics.firmware.protos.RemoteServices remote_services = 31;
inline bool RootMessage::has_remote_services() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RootMessage::set_has_remote_services() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RootMessage::clear_has_remote_services() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RootMessage::clear_remote_services() {
  if (remote_services_ != NULL) remote_services_->::biorobotics::firmware::protos::RemoteServices::Clear();
  clear_has_remote_services();
}
inline const ::biorobotics::firmware::protos::RemoteServices& RootMessage::remote_services() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return remote_services_ != NULL ? *remote_services_ : *default_instance().remote_services_;
#else
  return remote_services_ != NULL ? *remote_services_ : *default_instance_->remote_services_;
#endif
}
inline ::biorobotics::firmware::protos::RemoteServices* RootMessage::mutable_remote_services() {
  set_has_remote_services();
  if (remote_services_ == NULL) remote_services_ = new ::biorobotics::firmware::protos::RemoteServices;
  return remote_services_;
}
inline ::biorobotics::firmware::protos::RemoteServices* RootMessage::release_remote_services() {
  clear_has_remote_services();
  ::biorobotics::firmware::protos::RemoteServices* temp = remote_services_;
  remote_services_ = NULL;
  return temp;
}
inline void RootMessage::set_allocated_remote_services(::biorobotics::firmware::protos::RemoteServices* remote_services) {
  delete remote_services_;
  remote_services_ = remote_services;
  if (remote_services) {
    set_has_remote_services();
  } else {
    clear_has_remote_services();
  }
}

// optional bool request_remote_services = 32;
inline bool RootMessage::has_request_remote_services() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RootMessage::set_has_request_remote_services() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RootMessage::clear_has_request_remote_services() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RootMessage::clear_request_remote_services() {
  request_remote_services_ = false;
  clear_has_request_remote_services();
}
inline bool RootMessage::request_remote_services() const {
  return request_remote_services_;
}
inline void RootMessage::set_request_remote_services(bool value) {
  set_has_request_remote_services();
  request_remote_services_ = value;
}

// optional bool reset = 80;
inline bool RootMessage::has_reset() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RootMessage::set_has_reset() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RootMessage::clear_has_reset() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RootMessage::clear_reset() {
  reset_ = false;
  clear_has_reset();
}
inline bool RootMessage::reset() const {
  return reset_;
}
inline void RootMessage::set_reset(bool value) {
  set_has_reset();
  reset_ = value;
}

// optional .biorobotics.firmware.protos.DebugMessage debug = 90;
inline bool RootMessage::has_debug() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void RootMessage::set_has_debug() {
  _has_bits_[0] |= 0x00100000u;
}
inline void RootMessage::clear_has_debug() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void RootMessage::clear_debug() {
  if (debug_ != NULL) debug_->::biorobotics::firmware::protos::DebugMessage::Clear();
  clear_has_debug();
}
inline const ::biorobotics::firmware::protos::DebugMessage& RootMessage::debug() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return debug_ != NULL ? *debug_ : *default_instance().debug_;
#else
  return debug_ != NULL ? *debug_ : *default_instance_->debug_;
#endif
}
inline ::biorobotics::firmware::protos::DebugMessage* RootMessage::mutable_debug() {
  set_has_debug();
  if (debug_ == NULL) debug_ = new ::biorobotics::firmware::protos::DebugMessage;
  return debug_;
}
inline ::biorobotics::firmware::protos::DebugMessage* RootMessage::release_debug() {
  clear_has_debug();
  ::biorobotics::firmware::protos::DebugMessage* temp = debug_;
  debug_ = NULL;
  return temp;
}
inline void RootMessage::set_allocated_debug(::biorobotics::firmware::protos::DebugMessage* debug) {
  delete debug_;
  debug_ = debug;
  if (debug) {
    set_has_debug();
  } else {
    clear_has_debug();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace firmware
}  // namespace biorobotics

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Core_2eproto__INCLUDED
