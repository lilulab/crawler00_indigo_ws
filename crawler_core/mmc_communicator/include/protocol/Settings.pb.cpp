// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Settings.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Settings.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace biorobotics {
namespace firmware {
namespace protos {
namespace settings {

void protobuf_ShutdownFile_Settings_2eproto() {
  delete Pid::default_instance_;
  delete Controller::default_instance_;
  delete Imu::default_instance_;
  delete EncoderFilter::default_instance_;
  delete SpringModel::default_instance_;
  delete ThermalModel::default_instance_;
  delete SafetyLimits::default_instance_;
  delete Name::default_instance_;
  delete Settings::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_Settings_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_Settings_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  Pid::default_instance_ = new Pid();
  Controller::default_instance_ = new Controller();
  Imu::default_instance_ = new Imu();
  EncoderFilter::default_instance_ = new EncoderFilter();
  SpringModel::default_instance_ = new SpringModel();
  ThermalModel::default_instance_ = new ThermalModel();
  SafetyLimits::default_instance_ = new SafetyLimits();
  Name::default_instance_ = new Name();
  Settings::default_instance_ = new Settings();
  Pid::default_instance_->InitAsDefaultInstance();
  Controller::default_instance_->InitAsDefaultInstance();
  Imu::default_instance_->InitAsDefaultInstance();
  EncoderFilter::default_instance_->InitAsDefaultInstance();
  SpringModel::default_instance_->InitAsDefaultInstance();
  ThermalModel::default_instance_->InitAsDefaultInstance();
  SafetyLimits::default_instance_->InitAsDefaultInstance();
  Name::default_instance_->InitAsDefaultInstance();
  Settings::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Settings_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_Settings_2eproto_once_);
void protobuf_AddDesc_Settings_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_Settings_2eproto_once_,
                 &protobuf_AddDesc_Settings_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Settings_2eproto {
  StaticDescriptorInitializer_Settings_2eproto() {
    protobuf_AddDesc_Settings_2eproto();
  }
} static_descriptor_initializer_Settings_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int Pid::kKpFieldNumber;
const int Pid::kKiFieldNumber;
const int Pid::kKdFieldNumber;
const int Pid::kFfFieldNumber;
const int Pid::kDeadZoneFieldNumber;
const int Pid::kIClampFieldNumber;
const int Pid::kEnabledFieldNumber;
const int Pid::kPunchFieldNumber;
const int Pid::kDWindowSizeFieldNumber;
const int Pid::kMinTargetValueFieldNumber;
const int Pid::kMaxTargetValueFieldNumber;
const int Pid::kMinOutputValueFieldNumber;
const int Pid::kMaxOutputValueFieldNumber;
const int Pid::kTargetLowpassGainFieldNumber;
const int Pid::kOutputLowpassGainFieldNumber;
const int Pid::kDOnErrorFieldNumber;
#endif  // !_MSC_VER

Pid::Pid()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Pid::InitAsDefaultInstance() {
}

Pid::Pid(const Pid& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Pid::SharedCtor() {
  _cached_size_ = 0;
  kp_ = 0;
  ki_ = 0;
  kd_ = 0;
  ff_ = 0;
  dead_zone_ = 0;
  i_clamp_ = 0;
  enabled_ = false;
  punch_ = 0;
  d_window_size_ = 0;
  min_target_value_ = 0;
  max_target_value_ = 0;
  min_output_value_ = 0;
  max_output_value_ = 0;
  target_lowpass_gain_ = 0;
  output_lowpass_gain_ = 0;
  d_on_error_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Pid::~Pid() {
  SharedDtor();
}

void Pid::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Pid::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Pid& Pid::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Settings_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Settings_2eproto();
#endif
  return *default_instance_;
}

Pid* Pid::default_instance_ = NULL;

Pid* Pid::New() const {
  return new Pid;
}

void Pid::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    kp_ = 0;
    ki_ = 0;
    kd_ = 0;
    ff_ = 0;
    dead_zone_ = 0;
    i_clamp_ = 0;
    enabled_ = false;
    punch_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    d_window_size_ = 0;
    min_target_value_ = 0;
    max_target_value_ = 0;
    min_output_value_ = 0;
    max_output_value_ = 0;
    target_lowpass_gain_ = 0;
    output_lowpass_gain_ = 0;
    d_on_error_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Pid::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float kp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &kp_)));
          set_has_kp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_ki;
        break;
      }

      // optional float ki = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_ki:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &ki_)));
          set_has_ki();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_kd;
        break;
      }

      // optional float kd = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_kd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &kd_)));
          set_has_kd();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_ff;
        break;
      }

      // optional float ff = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_ff:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &ff_)));
          set_has_ff();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_dead_zone;
        break;
      }

      // optional float dead_zone = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_dead_zone:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &dead_zone_)));
          set_has_dead_zone();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_i_clamp;
        break;
      }

      // optional float i_clamp = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_i_clamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &i_clamp_)));
          set_has_i_clamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_enabled;
        break;
      }

      // optional bool enabled = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enabled_)));
          set_has_enabled();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_punch;
        break;
      }

      // optional float punch = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_punch:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &punch_)));
          set_has_punch();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(77)) goto parse_d_window_size;
        break;
      }

      // optional float d_window_size = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_d_window_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &d_window_size_)));
          set_has_d_window_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(85)) goto parse_max_target_value;
        break;
      }

      // optional float max_target_value = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_max_target_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_target_value_)));
          set_has_max_target_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(93)) goto parse_max_output_value;
        break;
      }

      // optional float max_output_value = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_max_output_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_output_value_)));
          set_has_max_output_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(101)) goto parse_target_lowpass_gain;
        break;
      }

      // optional float target_lowpass_gain = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_target_lowpass_gain:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &target_lowpass_gain_)));
          set_has_target_lowpass_gain();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(109)) goto parse_output_lowpass_gain;
        break;
      }

      // optional float output_lowpass_gain = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_output_lowpass_gain:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &output_lowpass_gain_)));
          set_has_output_lowpass_gain();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_d_on_error;
        break;
      }

      // optional bool d_on_error = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_d_on_error:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &d_on_error_)));
          set_has_d_on_error();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(125)) goto parse_min_target_value;
        break;
      }

      // optional float min_target_value = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_min_target_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &min_target_value_)));
          set_has_min_target_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(133)) goto parse_min_output_value;
        break;
      }

      // optional float min_output_value = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_min_output_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &min_output_value_)));
          set_has_min_output_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Pid::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float kp = 1;
  if (has_kp()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->kp(), output);
  }

  // optional float ki = 2;
  if (has_ki()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->ki(), output);
  }

  // optional float kd = 3;
  if (has_kd()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->kd(), output);
  }

  // optional float ff = 4;
  if (has_ff()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->ff(), output);
  }

  // optional float dead_zone = 5;
  if (has_dead_zone()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->dead_zone(), output);
  }

  // optional float i_clamp = 6;
  if (has_i_clamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->i_clamp(), output);
  }

  // optional bool enabled = 7;
  if (has_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->enabled(), output);
  }

  // optional float punch = 8;
  if (has_punch()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->punch(), output);
  }

  // optional float d_window_size = 9;
  if (has_d_window_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->d_window_size(), output);
  }

  // optional float max_target_value = 10;
  if (has_max_target_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->max_target_value(), output);
  }

  // optional float max_output_value = 11;
  if (has_max_output_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->max_output_value(), output);
  }

  // optional float target_lowpass_gain = 12;
  if (has_target_lowpass_gain()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(12, this->target_lowpass_gain(), output);
  }

  // optional float output_lowpass_gain = 13;
  if (has_output_lowpass_gain()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(13, this->output_lowpass_gain(), output);
  }

  // optional bool d_on_error = 14;
  if (has_d_on_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(14, this->d_on_error(), output);
  }

  // optional float min_target_value = 15;
  if (has_min_target_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(15, this->min_target_value(), output);
  }

  // optional float min_output_value = 16;
  if (has_min_output_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(16, this->min_output_value(), output);
  }

}

int Pid::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float kp = 1;
    if (has_kp()) {
      total_size += 1 + 4;
    }

    // optional float ki = 2;
    if (has_ki()) {
      total_size += 1 + 4;
    }

    // optional float kd = 3;
    if (has_kd()) {
      total_size += 1 + 4;
    }

    // optional float ff = 4;
    if (has_ff()) {
      total_size += 1 + 4;
    }

    // optional float dead_zone = 5;
    if (has_dead_zone()) {
      total_size += 1 + 4;
    }

    // optional float i_clamp = 6;
    if (has_i_clamp()) {
      total_size += 1 + 4;
    }

    // optional bool enabled = 7;
    if (has_enabled()) {
      total_size += 1 + 1;
    }

    // optional float punch = 8;
    if (has_punch()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float d_window_size = 9;
    if (has_d_window_size()) {
      total_size += 1 + 4;
    }

    // optional float min_target_value = 15;
    if (has_min_target_value()) {
      total_size += 1 + 4;
    }

    // optional float max_target_value = 10;
    if (has_max_target_value()) {
      total_size += 1 + 4;
    }

    // optional float min_output_value = 16;
    if (has_min_output_value()) {
      total_size += 2 + 4;
    }

    // optional float max_output_value = 11;
    if (has_max_output_value()) {
      total_size += 1 + 4;
    }

    // optional float target_lowpass_gain = 12;
    if (has_target_lowpass_gain()) {
      total_size += 1 + 4;
    }

    // optional float output_lowpass_gain = 13;
    if (has_output_lowpass_gain()) {
      total_size += 1 + 4;
    }

    // optional bool d_on_error = 14;
    if (has_d_on_error()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Pid::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Pid*>(&from));
}

void Pid::MergeFrom(const Pid& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kp()) {
      set_kp(from.kp());
    }
    if (from.has_ki()) {
      set_ki(from.ki());
    }
    if (from.has_kd()) {
      set_kd(from.kd());
    }
    if (from.has_ff()) {
      set_ff(from.ff());
    }
    if (from.has_dead_zone()) {
      set_dead_zone(from.dead_zone());
    }
    if (from.has_i_clamp()) {
      set_i_clamp(from.i_clamp());
    }
    if (from.has_enabled()) {
      set_enabled(from.enabled());
    }
    if (from.has_punch()) {
      set_punch(from.punch());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_d_window_size()) {
      set_d_window_size(from.d_window_size());
    }
    if (from.has_min_target_value()) {
      set_min_target_value(from.min_target_value());
    }
    if (from.has_max_target_value()) {
      set_max_target_value(from.max_target_value());
    }
    if (from.has_min_output_value()) {
      set_min_output_value(from.min_output_value());
    }
    if (from.has_max_output_value()) {
      set_max_output_value(from.max_output_value());
    }
    if (from.has_target_lowpass_gain()) {
      set_target_lowpass_gain(from.target_lowpass_gain());
    }
    if (from.has_output_lowpass_gain()) {
      set_output_lowpass_gain(from.output_lowpass_gain());
    }
    if (from.has_d_on_error()) {
      set_d_on_error(from.d_on_error());
    }
  }
}

void Pid::CopyFrom(const Pid& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pid::IsInitialized() const {

  return true;
}

void Pid::Swap(Pid* other) {
  if (other != this) {
    std::swap(kp_, other->kp_);
    std::swap(ki_, other->ki_);
    std::swap(kd_, other->kd_);
    std::swap(ff_, other->ff_);
    std::swap(dead_zone_, other->dead_zone_);
    std::swap(i_clamp_, other->i_clamp_);
    std::swap(enabled_, other->enabled_);
    std::swap(punch_, other->punch_);
    std::swap(d_window_size_, other->d_window_size_);
    std::swap(min_target_value_, other->min_target_value_);
    std::swap(max_target_value_, other->max_target_value_);
    std::swap(min_output_value_, other->min_output_value_);
    std::swap(max_output_value_, other->max_output_value_);
    std::swap(target_lowpass_gain_, other->target_lowpass_gain_);
    std::swap(output_lowpass_gain_, other->output_lowpass_gain_);
    std::swap(d_on_error_, other->d_on_error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Pid::GetTypeName() const {
  return "biorobotics.firmware.protos.settings.Pid";
}


// ===================================================================

bool Controller_ControlStrategy_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Controller_ControlStrategy Controller::OFF;
const Controller_ControlStrategy Controller::CASCADED_INNER_TORQUE;
const Controller_ControlStrategy Controller::CASCADED_OUTER_TORQUE;
const Controller_ControlStrategy Controller::DIRECT_PWM;
const Controller_ControlStrategy Controller::ControlStrategy_MIN;
const Controller_ControlStrategy Controller::ControlStrategy_MAX;
const int Controller::ControlStrategy_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Controller::kStrategyFieldNumber;
const int Controller::kPeriodMsecFieldNumber;
const int Controller::kPositionPidFieldNumber;
const int Controller::kVelocityPidFieldNumber;
const int Controller::kTorquePidFieldNumber;
#endif  // !_MSC_VER

Controller::Controller()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Controller::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  position_pid_ = const_cast< ::biorobotics::firmware::protos::settings::Pid*>(
      ::biorobotics::firmware::protos::settings::Pid::internal_default_instance());
#else
  position_pid_ = const_cast< ::biorobotics::firmware::protos::settings::Pid*>(&::biorobotics::firmware::protos::settings::Pid::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  velocity_pid_ = const_cast< ::biorobotics::firmware::protos::settings::Pid*>(
      ::biorobotics::firmware::protos::settings::Pid::internal_default_instance());
#else
  velocity_pid_ = const_cast< ::biorobotics::firmware::protos::settings::Pid*>(&::biorobotics::firmware::protos::settings::Pid::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  torque_pid_ = const_cast< ::biorobotics::firmware::protos::settings::Pid*>(
      ::biorobotics::firmware::protos::settings::Pid::internal_default_instance());
#else
  torque_pid_ = const_cast< ::biorobotics::firmware::protos::settings::Pid*>(&::biorobotics::firmware::protos::settings::Pid::default_instance());
#endif
}

Controller::Controller(const Controller& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Controller::SharedCtor() {
  _cached_size_ = 0;
  strategy_ = 1;
  period_msec_ = 0u;
  position_pid_ = NULL;
  velocity_pid_ = NULL;
  torque_pid_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Controller::~Controller() {
  SharedDtor();
}

void Controller::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete position_pid_;
    delete velocity_pid_;
    delete torque_pid_;
  }
}

void Controller::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Controller& Controller::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Settings_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Settings_2eproto();
#endif
  return *default_instance_;
}

Controller* Controller::default_instance_ = NULL;

Controller* Controller::New() const {
  return new Controller;
}

void Controller::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    strategy_ = 1;
    period_msec_ = 0u;
    if (has_position_pid()) {
      if (position_pid_ != NULL) position_pid_->::biorobotics::firmware::protos::settings::Pid::Clear();
    }
    if (has_velocity_pid()) {
      if (velocity_pid_ != NULL) velocity_pid_->::biorobotics::firmware::protos::settings::Pid::Clear();
    }
    if (has_torque_pid()) {
      if (torque_pid_ != NULL) torque_pid_->::biorobotics::firmware::protos::settings::Pid::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Controller::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .biorobotics.firmware.protos.settings.Controller.ControlStrategy strategy = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::biorobotics::firmware::protos::settings::Controller_ControlStrategy_IsValid(value)) {
            set_strategy(static_cast< ::biorobotics::firmware::protos::settings::Controller_ControlStrategy >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_period_msec;
        break;
      }

      // optional uint32 period_msec = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_period_msec:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &period_msec_)));
          set_has_period_msec();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_position_pid;
        break;
      }

      // optional .biorobotics.firmware.protos.settings.Pid position_pid = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_position_pid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position_pid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_velocity_pid;
        break;
      }

      // optional .biorobotics.firmware.protos.settings.Pid velocity_pid = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_velocity_pid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_velocity_pid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_torque_pid;
        break;
      }

      // optional .biorobotics.firmware.protos.settings.Pid torque_pid = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_torque_pid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_torque_pid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Controller::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .biorobotics.firmware.protos.settings.Controller.ControlStrategy strategy = 3;
  if (has_strategy()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->strategy(), output);
  }

  // optional uint32 period_msec = 5;
  if (has_period_msec()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->period_msec(), output);
  }

  // optional .biorobotics.firmware.protos.settings.Pid position_pid = 6;
  if (has_position_pid()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->position_pid(), output);
  }

  // optional .biorobotics.firmware.protos.settings.Pid velocity_pid = 7;
  if (has_velocity_pid()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->velocity_pid(), output);
  }

  // optional .biorobotics.firmware.protos.settings.Pid torque_pid = 8;
  if (has_torque_pid()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->torque_pid(), output);
  }

}

int Controller::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .biorobotics.firmware.protos.settings.Controller.ControlStrategy strategy = 3;
    if (has_strategy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->strategy());
    }

    // optional uint32 period_msec = 5;
    if (has_period_msec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->period_msec());
    }

    // optional .biorobotics.firmware.protos.settings.Pid position_pid = 6;
    if (has_position_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->position_pid());
    }

    // optional .biorobotics.firmware.protos.settings.Pid velocity_pid = 7;
    if (has_velocity_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->velocity_pid());
    }

    // optional .biorobotics.firmware.protos.settings.Pid torque_pid = 8;
    if (has_torque_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->torque_pid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Controller::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Controller*>(&from));
}

void Controller::MergeFrom(const Controller& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_strategy()) {
      set_strategy(from.strategy());
    }
    if (from.has_period_msec()) {
      set_period_msec(from.period_msec());
    }
    if (from.has_position_pid()) {
      mutable_position_pid()->::biorobotics::firmware::protos::settings::Pid::MergeFrom(from.position_pid());
    }
    if (from.has_velocity_pid()) {
      mutable_velocity_pid()->::biorobotics::firmware::protos::settings::Pid::MergeFrom(from.velocity_pid());
    }
    if (from.has_torque_pid()) {
      mutable_torque_pid()->::biorobotics::firmware::protos::settings::Pid::MergeFrom(from.torque_pid());
    }
  }
}

void Controller::CopyFrom(const Controller& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Controller::IsInitialized() const {

  return true;
}

void Controller::Swap(Controller* other) {
  if (other != this) {
    std::swap(strategy_, other->strategy_);
    std::swap(period_msec_, other->period_msec_);
    std::swap(position_pid_, other->position_pid_);
    std::swap(velocity_pid_, other->velocity_pid_);
    std::swap(torque_pid_, other->torque_pid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Controller::GetTypeName() const {
  return "biorobotics.firmware.protos.settings.Controller";
}


// ===================================================================

bool Imu_AccelScale_IsValid(int value) {
  switch(value) {
    case 2:
    case 4:
    case 8:
    case 16:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Imu_AccelScale Imu::G_2;
const Imu_AccelScale Imu::G_4;
const Imu_AccelScale Imu::G_8;
const Imu_AccelScale Imu::G_16;
const Imu_AccelScale Imu::AccelScale_MIN;
const Imu_AccelScale Imu::AccelScale_MAX;
const int Imu::AccelScale_ARRAYSIZE;
#endif  // _MSC_VER
bool Imu_AccelCutoff_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Imu_AccelCutoff Imu::Hz_260;
const Imu_AccelCutoff Imu::Hz_184;
const Imu_AccelCutoff Imu::Hz_94;
const Imu_AccelCutoff Imu::Hz_44;
const Imu_AccelCutoff Imu::Hz_21;
const Imu_AccelCutoff Imu::Hz_10;
const Imu_AccelCutoff Imu::Hz_5;
const Imu_AccelCutoff Imu::AccelCutoff_MIN;
const Imu_AccelCutoff Imu::AccelCutoff_MAX;
const int Imu::AccelCutoff_ARRAYSIZE;
#endif  // _MSC_VER
bool Imu_GyroScale_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Imu_GyroScale Imu::DEG_PER_S_250;
const Imu_GyroScale Imu::DEG_PER_S_500;
const Imu_GyroScale Imu::DEG_PER_S_1000;
const Imu_GyroScale Imu::DEG_PER_S_2000;
const Imu_GyroScale Imu::GyroScale_MIN;
const Imu_GyroScale Imu::GyroScale_MAX;
const int Imu::GyroScale_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Imu::kAccelScaleFieldNumber;
const int Imu::kAccelCutoffFieldNumber;
const int Imu::kGyroScaleFieldNumber;
#endif  // !_MSC_VER

Imu::Imu()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Imu::InitAsDefaultInstance() {
}

Imu::Imu(const Imu& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Imu::SharedCtor() {
  _cached_size_ = 0;
  accel_scale_ = 2;
  accel_cutoff_ = 1;
  gyro_scale_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Imu::~Imu() {
  SharedDtor();
}

void Imu::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Imu::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Imu& Imu::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Settings_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Settings_2eproto();
#endif
  return *default_instance_;
}

Imu* Imu::default_instance_ = NULL;

Imu* Imu::New() const {
  return new Imu;
}

void Imu::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    accel_scale_ = 2;
    accel_cutoff_ = 1;
    gyro_scale_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Imu::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .biorobotics.firmware.protos.settings.Imu.AccelScale accel_scale = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::biorobotics::firmware::protos::settings::Imu_AccelScale_IsValid(value)) {
            set_accel_scale(static_cast< ::biorobotics::firmware::protos::settings::Imu_AccelScale >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_accel_cutoff;
        break;
      }

      // optional .biorobotics.firmware.protos.settings.Imu.AccelCutoff accel_cutoff = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_accel_cutoff:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::biorobotics::firmware::protos::settings::Imu_AccelCutoff_IsValid(value)) {
            set_accel_cutoff(static_cast< ::biorobotics::firmware::protos::settings::Imu_AccelCutoff >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(160)) goto parse_gyro_scale;
        break;
      }

      // optional .biorobotics.firmware.protos.settings.Imu.GyroScale gyro_scale = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gyro_scale:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::biorobotics::firmware::protos::settings::Imu_GyroScale_IsValid(value)) {
            set_gyro_scale(static_cast< ::biorobotics::firmware::protos::settings::Imu_GyroScale >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Imu::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .biorobotics.firmware.protos.settings.Imu.AccelScale accel_scale = 10;
  if (has_accel_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->accel_scale(), output);
  }

  // optional .biorobotics.firmware.protos.settings.Imu.AccelCutoff accel_cutoff = 11;
  if (has_accel_cutoff()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      11, this->accel_cutoff(), output);
  }

  // optional .biorobotics.firmware.protos.settings.Imu.GyroScale gyro_scale = 20;
  if (has_gyro_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      20, this->gyro_scale(), output);
  }

}

int Imu::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .biorobotics.firmware.protos.settings.Imu.AccelScale accel_scale = 10;
    if (has_accel_scale()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->accel_scale());
    }

    // optional .biorobotics.firmware.protos.settings.Imu.AccelCutoff accel_cutoff = 11;
    if (has_accel_cutoff()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->accel_cutoff());
    }

    // optional .biorobotics.firmware.protos.settings.Imu.GyroScale gyro_scale = 20;
    if (has_gyro_scale()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->gyro_scale());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Imu::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Imu*>(&from));
}

void Imu::MergeFrom(const Imu& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_accel_scale()) {
      set_accel_scale(from.accel_scale());
    }
    if (from.has_accel_cutoff()) {
      set_accel_cutoff(from.accel_cutoff());
    }
    if (from.has_gyro_scale()) {
      set_gyro_scale(from.gyro_scale());
    }
  }
}

void Imu::CopyFrom(const Imu& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Imu::IsInitialized() const {

  return true;
}

void Imu::Swap(Imu* other) {
  if (other != this) {
    std::swap(accel_scale_, other->accel_scale_);
    std::swap(accel_cutoff_, other->accel_cutoff_);
    std::swap(gyro_scale_, other->gyro_scale_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Imu::GetTypeName() const {
  return "biorobotics.firmware.protos.settings.Imu";
}


// ===================================================================

#ifndef _MSC_VER
const int EncoderFilter::kInnerEncoderKalmanGainsFieldNumber;
const int EncoderFilter::kInnerEncoderAccelDampFieldNumber;
const int EncoderFilter::kOuterEncoderKalmanGainsFieldNumber;
const int EncoderFilter::kOuterEncoderAccelDampFieldNumber;
#endif  // !_MSC_VER

EncoderFilter::EncoderFilter()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EncoderFilter::InitAsDefaultInstance() {
}

EncoderFilter::EncoderFilter(const EncoderFilter& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EncoderFilter::SharedCtor() {
  _cached_size_ = 0;
  inner_encoder_accel_damp_ = 0;
  outer_encoder_accel_damp_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EncoderFilter::~EncoderFilter() {
  SharedDtor();
}

void EncoderFilter::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EncoderFilter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EncoderFilter& EncoderFilter::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Settings_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Settings_2eproto();
#endif
  return *default_instance_;
}

EncoderFilter* EncoderFilter::default_instance_ = NULL;

EncoderFilter* EncoderFilter::New() const {
  return new EncoderFilter;
}

void EncoderFilter::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    inner_encoder_accel_damp_ = 0;
    outer_encoder_accel_damp_ = 0;
  }
  inner_encoder_kalman_gains_.Clear();
  outer_encoder_kalman_gains_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EncoderFilter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated float inner_encoder_kalman_gains = 5 [packed = true];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_inner_encoder_kalman_gains())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 42, input, this->mutable_inner_encoder_kalman_gains())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_inner_encoder_accel_damp;
        break;
      }

      // optional float inner_encoder_accel_damp = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_inner_encoder_accel_damp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &inner_encoder_accel_damp_)));
          set_has_inner_encoder_accel_damp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_outer_encoder_kalman_gains;
        break;
      }

      // repeated float outer_encoder_kalman_gains = 8 [packed = true];
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_outer_encoder_kalman_gains:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_outer_encoder_kalman_gains())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 66, input, this->mutable_outer_encoder_kalman_gains())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(77)) goto parse_outer_encoder_accel_damp;
        break;
      }

      // optional float outer_encoder_accel_damp = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_outer_encoder_accel_damp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &outer_encoder_accel_damp_)));
          set_has_outer_encoder_accel_damp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EncoderFilter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated float inner_encoder_kalman_gains = 5 [packed = true];
  if (this->inner_encoder_kalman_gains_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(5, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_inner_encoder_kalman_gains_cached_byte_size_);
  }
  for (int i = 0; i < this->inner_encoder_kalman_gains_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloatNoTag(
      this->inner_encoder_kalman_gains(i), output);
  }

  // optional float inner_encoder_accel_damp = 6;
  if (has_inner_encoder_accel_damp()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->inner_encoder_accel_damp(), output);
  }

  // repeated float outer_encoder_kalman_gains = 8 [packed = true];
  if (this->outer_encoder_kalman_gains_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(8, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_outer_encoder_kalman_gains_cached_byte_size_);
  }
  for (int i = 0; i < this->outer_encoder_kalman_gains_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloatNoTag(
      this->outer_encoder_kalman_gains(i), output);
  }

  // optional float outer_encoder_accel_damp = 9;
  if (has_outer_encoder_accel_damp()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->outer_encoder_accel_damp(), output);
  }

}

int EncoderFilter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional float inner_encoder_accel_damp = 6;
    if (has_inner_encoder_accel_damp()) {
      total_size += 1 + 4;
    }

    // optional float outer_encoder_accel_damp = 9;
    if (has_outer_encoder_accel_damp()) {
      total_size += 1 + 4;
    }

  }
  // repeated float inner_encoder_kalman_gains = 5 [packed = true];
  {
    int data_size = 0;
    data_size = 4 * this->inner_encoder_kalman_gains_size();
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _inner_encoder_kalman_gains_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated float outer_encoder_kalman_gains = 8 [packed = true];
  {
    int data_size = 0;
    data_size = 4 * this->outer_encoder_kalman_gains_size();
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _outer_encoder_kalman_gains_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EncoderFilter::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EncoderFilter*>(&from));
}

void EncoderFilter::MergeFrom(const EncoderFilter& from) {
  GOOGLE_CHECK_NE(&from, this);
  inner_encoder_kalman_gains_.MergeFrom(from.inner_encoder_kalman_gains_);
  outer_encoder_kalman_gains_.MergeFrom(from.outer_encoder_kalman_gains_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_inner_encoder_accel_damp()) {
      set_inner_encoder_accel_damp(from.inner_encoder_accel_damp());
    }
    if (from.has_outer_encoder_accel_damp()) {
      set_outer_encoder_accel_damp(from.outer_encoder_accel_damp());
    }
  }
}

void EncoderFilter::CopyFrom(const EncoderFilter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EncoderFilter::IsInitialized() const {

  return true;
}

void EncoderFilter::Swap(EncoderFilter* other) {
  if (other != this) {
    inner_encoder_kalman_gains_.Swap(&other->inner_encoder_kalman_gains_);
    std::swap(inner_encoder_accel_damp_, other->inner_encoder_accel_damp_);
    outer_encoder_kalman_gains_.Swap(&other->outer_encoder_kalman_gains_);
    std::swap(outer_encoder_accel_damp_, other->outer_encoder_accel_damp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EncoderFilter::GetTypeName() const {
  return "biorobotics.firmware.protos.settings.EncoderFilter";
}


// ===================================================================

#ifndef _MSC_VER
const int SpringModel::kSpringConstantFieldNumber;
#endif  // !_MSC_VER

SpringModel::SpringModel()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SpringModel::InitAsDefaultInstance() {
}

SpringModel::SpringModel(const SpringModel& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SpringModel::SharedCtor() {
  _cached_size_ = 0;
  spring_constant_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SpringModel::~SpringModel() {
  SharedDtor();
}

void SpringModel::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SpringModel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SpringModel& SpringModel::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Settings_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Settings_2eproto();
#endif
  return *default_instance_;
}

SpringModel* SpringModel::default_instance_ = NULL;

SpringModel* SpringModel::New() const {
  return new SpringModel;
}

void SpringModel::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    spring_constant_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SpringModel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float spring_constant = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &spring_constant_)));
          set_has_spring_constant();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SpringModel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float spring_constant = 5;
  if (has_spring_constant()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->spring_constant(), output);
  }

}

int SpringModel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float spring_constant = 5;
    if (has_spring_constant()) {
      total_size += 1 + 4;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SpringModel::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SpringModel*>(&from));
}

void SpringModel::MergeFrom(const SpringModel& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_spring_constant()) {
      set_spring_constant(from.spring_constant());
    }
  }
}

void SpringModel::CopyFrom(const SpringModel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpringModel::IsInitialized() const {

  return true;
}

void SpringModel::Swap(SpringModel* other) {
  if (other != this) {
    std::swap(spring_constant_, other->spring_constant_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SpringModel::GetTypeName() const {
  return "biorobotics.firmware.protos.settings.SpringModel";
}


// ===================================================================

#ifndef _MSC_VER
const int ThermalModel::kMotorHousingThermalResistanceFieldNumber;
#endif  // !_MSC_VER

ThermalModel::ThermalModel()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ThermalModel::InitAsDefaultInstance() {
}

ThermalModel::ThermalModel(const ThermalModel& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ThermalModel::SharedCtor() {
  _cached_size_ = 0;
  motor_housing_thermal_resistance_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ThermalModel::~ThermalModel() {
  SharedDtor();
}

void ThermalModel::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ThermalModel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ThermalModel& ThermalModel::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Settings_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Settings_2eproto();
#endif
  return *default_instance_;
}

ThermalModel* ThermalModel::default_instance_ = NULL;

ThermalModel* ThermalModel::New() const {
  return new ThermalModel;
}

void ThermalModel::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    motor_housing_thermal_resistance_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ThermalModel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float motor_housing_thermal_resistance = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &motor_housing_thermal_resistance_)));
          set_has_motor_housing_thermal_resistance();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ThermalModel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float motor_housing_thermal_resistance = 5;
  if (has_motor_housing_thermal_resistance()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->motor_housing_thermal_resistance(), output);
  }

}

int ThermalModel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float motor_housing_thermal_resistance = 5;
    if (has_motor_housing_thermal_resistance()) {
      total_size += 1 + 4;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ThermalModel::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ThermalModel*>(&from));
}

void ThermalModel::MergeFrom(const ThermalModel& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_motor_housing_thermal_resistance()) {
      set_motor_housing_thermal_resistance(from.motor_housing_thermal_resistance());
    }
  }
}

void ThermalModel::CopyFrom(const ThermalModel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThermalModel::IsInitialized() const {

  return true;
}

void ThermalModel::Swap(ThermalModel* other) {
  if (other != this) {
    std::swap(motor_housing_thermal_resistance_, other->motor_housing_thermal_resistance_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ThermalModel::GetTypeName() const {
  return "biorobotics.firmware.protos.settings.ThermalModel";
}


// ===================================================================

#ifndef _MSC_VER
const int SafetyLimits::kMotorCurrentLimitFieldNumber;
#endif  // !_MSC_VER

SafetyLimits::SafetyLimits()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SafetyLimits::InitAsDefaultInstance() {
}

SafetyLimits::SafetyLimits(const SafetyLimits& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SafetyLimits::SharedCtor() {
  _cached_size_ = 0;
  motor_current_limit_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SafetyLimits::~SafetyLimits() {
  SharedDtor();
}

void SafetyLimits::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SafetyLimits::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SafetyLimits& SafetyLimits::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Settings_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Settings_2eproto();
#endif
  return *default_instance_;
}

SafetyLimits* SafetyLimits::default_instance_ = NULL;

SafetyLimits* SafetyLimits::New() const {
  return new SafetyLimits;
}

void SafetyLimits::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    motor_current_limit_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SafetyLimits::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float motor_current_limit = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &motor_current_limit_)));
          set_has_motor_current_limit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SafetyLimits::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float motor_current_limit = 5;
  if (has_motor_current_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->motor_current_limit(), output);
  }

}

int SafetyLimits::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float motor_current_limit = 5;
    if (has_motor_current_limit()) {
      total_size += 1 + 4;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SafetyLimits::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SafetyLimits*>(&from));
}

void SafetyLimits::MergeFrom(const SafetyLimits& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_motor_current_limit()) {
      set_motor_current_limit(from.motor_current_limit());
    }
  }
}

void SafetyLimits::CopyFrom(const SafetyLimits& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SafetyLimits::IsInitialized() const {

  return true;
}

void SafetyLimits::Swap(SafetyLimits* other) {
  if (other != this) {
    std::swap(motor_current_limit_, other->motor_current_limit_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SafetyLimits::GetTypeName() const {
  return "biorobotics.firmware.protos.settings.SafetyLimits";
}


// ===================================================================

#ifndef _MSC_VER
const int Name::kNameFieldNumber;
const int Name::kGroupNameFieldNumber;
#endif  // !_MSC_VER

Name::Name()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Name::InitAsDefaultInstance() {
}

Name::Name(const Name& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Name::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Name::~Name() {
  SharedDtor();
}

void Name::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    delete group_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Name::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Name& Name::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Settings_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Settings_2eproto();
#endif
  return *default_instance_;
}

Name* Name::default_instance_ = NULL;

Name* Name::New() const {
  return new Name;
}

void Name::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_group_name()) {
      if (group_name_ != &::google::protobuf::internal::kEmptyString) {
        group_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Name::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_group_name;
        break;
      }

      // optional string group_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_group_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_group_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Name::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // optional string group_name = 2;
  if (has_group_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->group_name(), output);
  }

}

int Name::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string group_name = 2;
    if (has_group_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->group_name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Name::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Name*>(&from));
}

void Name::MergeFrom(const Name& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_group_name()) {
      set_group_name(from.group_name());
    }
  }
}

void Name::CopyFrom(const Name& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Name::IsInitialized() const {

  return true;
}

void Name::Swap(Name* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(group_name_, other->group_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Name::GetTypeName() const {
  return "biorobotics.firmware.protos.settings.Name";
}


// ===================================================================

#ifndef _MSC_VER
const int Settings::kControllerFieldNumber;
const int Settings::kImuFieldNumber;
const int Settings::kEncoderFilterFieldNumber;
const int Settings::kSpringModelFieldNumber;
const int Settings::kThermalModelFieldNumber;
const int Settings::kSafetyLimitsFieldNumber;
const int Settings::kNameFieldNumber;
const int Settings::kPersistAllFieldNumber;
#endif  // !_MSC_VER

Settings::Settings()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Settings::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  controller_ = const_cast< ::biorobotics::firmware::protos::settings::Controller*>(
      ::biorobotics::firmware::protos::settings::Controller::internal_default_instance());
#else
  controller_ = const_cast< ::biorobotics::firmware::protos::settings::Controller*>(&::biorobotics::firmware::protos::settings::Controller::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  imu_ = const_cast< ::biorobotics::firmware::protos::settings::Imu*>(
      ::biorobotics::firmware::protos::settings::Imu::internal_default_instance());
#else
  imu_ = const_cast< ::biorobotics::firmware::protos::settings::Imu*>(&::biorobotics::firmware::protos::settings::Imu::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  encoder_filter_ = const_cast< ::biorobotics::firmware::protos::settings::EncoderFilter*>(
      ::biorobotics::firmware::protos::settings::EncoderFilter::internal_default_instance());
#else
  encoder_filter_ = const_cast< ::biorobotics::firmware::protos::settings::EncoderFilter*>(&::biorobotics::firmware::protos::settings::EncoderFilter::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  spring_model_ = const_cast< ::biorobotics::firmware::protos::settings::SpringModel*>(
      ::biorobotics::firmware::protos::settings::SpringModel::internal_default_instance());
#else
  spring_model_ = const_cast< ::biorobotics::firmware::protos::settings::SpringModel*>(&::biorobotics::firmware::protos::settings::SpringModel::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  thermal_model_ = const_cast< ::biorobotics::firmware::protos::settings::ThermalModel*>(
      ::biorobotics::firmware::protos::settings::ThermalModel::internal_default_instance());
#else
  thermal_model_ = const_cast< ::biorobotics::firmware::protos::settings::ThermalModel*>(&::biorobotics::firmware::protos::settings::ThermalModel::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  safety_limits_ = const_cast< ::biorobotics::firmware::protos::settings::SafetyLimits*>(
      ::biorobotics::firmware::protos::settings::SafetyLimits::internal_default_instance());
#else
  safety_limits_ = const_cast< ::biorobotics::firmware::protos::settings::SafetyLimits*>(&::biorobotics::firmware::protos::settings::SafetyLimits::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  name_ = const_cast< ::biorobotics::firmware::protos::settings::Name*>(
      ::biorobotics::firmware::protos::settings::Name::internal_default_instance());
#else
  name_ = const_cast< ::biorobotics::firmware::protos::settings::Name*>(&::biorobotics::firmware::protos::settings::Name::default_instance());
#endif
}

Settings::Settings(const Settings& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Settings::SharedCtor() {
  _cached_size_ = 0;
  controller_ = NULL;
  imu_ = NULL;
  encoder_filter_ = NULL;
  spring_model_ = NULL;
  thermal_model_ = NULL;
  safety_limits_ = NULL;
  name_ = NULL;
  persist_all_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Settings::~Settings() {
  SharedDtor();
}

void Settings::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete controller_;
    delete imu_;
    delete encoder_filter_;
    delete spring_model_;
    delete thermal_model_;
    delete safety_limits_;
    delete name_;
  }
}

void Settings::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Settings& Settings::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Settings_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Settings_2eproto();
#endif
  return *default_instance_;
}

Settings* Settings::default_instance_ = NULL;

Settings* Settings::New() const {
  return new Settings;
}

void Settings::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_controller()) {
      if (controller_ != NULL) controller_->::biorobotics::firmware::protos::settings::Controller::Clear();
    }
    if (has_imu()) {
      if (imu_ != NULL) imu_->::biorobotics::firmware::protos::settings::Imu::Clear();
    }
    if (has_encoder_filter()) {
      if (encoder_filter_ != NULL) encoder_filter_->::biorobotics::firmware::protos::settings::EncoderFilter::Clear();
    }
    if (has_spring_model()) {
      if (spring_model_ != NULL) spring_model_->::biorobotics::firmware::protos::settings::SpringModel::Clear();
    }
    if (has_thermal_model()) {
      if (thermal_model_ != NULL) thermal_model_->::biorobotics::firmware::protos::settings::ThermalModel::Clear();
    }
    if (has_safety_limits()) {
      if (safety_limits_ != NULL) safety_limits_->::biorobotics::firmware::protos::settings::SafetyLimits::Clear();
    }
    if (has_name()) {
      if (name_ != NULL) name_->::biorobotics::firmware::protos::settings::Name::Clear();
    }
    persist_all_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Settings::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .biorobotics.firmware.protos.settings.Controller controller = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_controller()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_imu;
        break;
      }

      // optional .biorobotics.firmware.protos.settings.Imu imu = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_imu:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_imu()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_encoder_filter;
        break;
      }

      // optional .biorobotics.firmware.protos.settings.EncoderFilter encoder_filter = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_encoder_filter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_encoder_filter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_spring_model;
        break;
      }

      // optional .biorobotics.firmware.protos.settings.SpringModel spring_model = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_spring_model:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_spring_model()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_thermal_model;
        break;
      }

      // optional .biorobotics.firmware.protos.settings.ThermalModel thermal_model = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_thermal_model:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_thermal_model()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_safety_limits;
        break;
      }

      // optional .biorobotics.firmware.protos.settings.SafetyLimits safety_limits = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_safety_limits:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_safety_limits()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_name;
        break;
      }

      // optional .biorobotics.firmware.protos.settings.Name name = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8008)) goto parse_persist_all;
        break;
      }

      // optional bool persist_all = 1001;
      case 1001: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_persist_all:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &persist_all_)));
          set_has_persist_all();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Settings::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .biorobotics.firmware.protos.settings.Controller controller = 2;
  if (has_controller()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->controller(), output);
  }

  // optional .biorobotics.firmware.protos.settings.Imu imu = 3;
  if (has_imu()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->imu(), output);
  }

  // optional .biorobotics.firmware.protos.settings.EncoderFilter encoder_filter = 4;
  if (has_encoder_filter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->encoder_filter(), output);
  }

  // optional .biorobotics.firmware.protos.settings.SpringModel spring_model = 5;
  if (has_spring_model()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->spring_model(), output);
  }

  // optional .biorobotics.firmware.protos.settings.ThermalModel thermal_model = 6;
  if (has_thermal_model()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->thermal_model(), output);
  }

  // optional .biorobotics.firmware.protos.settings.SafetyLimits safety_limits = 7;
  if (has_safety_limits()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->safety_limits(), output);
  }

  // optional .biorobotics.firmware.protos.settings.Name name = 8;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->name(), output);
  }

  // optional bool persist_all = 1001;
  if (has_persist_all()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1001, this->persist_all(), output);
  }

}

int Settings::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .biorobotics.firmware.protos.settings.Controller controller = 2;
    if (has_controller()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->controller());
    }

    // optional .biorobotics.firmware.protos.settings.Imu imu = 3;
    if (has_imu()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->imu());
    }

    // optional .biorobotics.firmware.protos.settings.EncoderFilter encoder_filter = 4;
    if (has_encoder_filter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->encoder_filter());
    }

    // optional .biorobotics.firmware.protos.settings.SpringModel spring_model = 5;
    if (has_spring_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->spring_model());
    }

    // optional .biorobotics.firmware.protos.settings.ThermalModel thermal_model = 6;
    if (has_thermal_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->thermal_model());
    }

    // optional .biorobotics.firmware.protos.settings.SafetyLimits safety_limits = 7;
    if (has_safety_limits()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->safety_limits());
    }

    // optional .biorobotics.firmware.protos.settings.Name name = 8;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->name());
    }

    // optional bool persist_all = 1001;
    if (has_persist_all()) {
      total_size += 2 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Settings::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Settings*>(&from));
}

void Settings::MergeFrom(const Settings& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_controller()) {
      mutable_controller()->::biorobotics::firmware::protos::settings::Controller::MergeFrom(from.controller());
    }
    if (from.has_imu()) {
      mutable_imu()->::biorobotics::firmware::protos::settings::Imu::MergeFrom(from.imu());
    }
    if (from.has_encoder_filter()) {
      mutable_encoder_filter()->::biorobotics::firmware::protos::settings::EncoderFilter::MergeFrom(from.encoder_filter());
    }
    if (from.has_spring_model()) {
      mutable_spring_model()->::biorobotics::firmware::protos::settings::SpringModel::MergeFrom(from.spring_model());
    }
    if (from.has_thermal_model()) {
      mutable_thermal_model()->::biorobotics::firmware::protos::settings::ThermalModel::MergeFrom(from.thermal_model());
    }
    if (from.has_safety_limits()) {
      mutable_safety_limits()->::biorobotics::firmware::protos::settings::SafetyLimits::MergeFrom(from.safety_limits());
    }
    if (from.has_name()) {
      mutable_name()->::biorobotics::firmware::protos::settings::Name::MergeFrom(from.name());
    }
    if (from.has_persist_all()) {
      set_persist_all(from.persist_all());
    }
  }
}

void Settings::CopyFrom(const Settings& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Settings::IsInitialized() const {

  return true;
}

void Settings::Swap(Settings* other) {
  if (other != this) {
    std::swap(controller_, other->controller_);
    std::swap(imu_, other->imu_);
    std::swap(encoder_filter_, other->encoder_filter_);
    std::swap(spring_model_, other->spring_model_);
    std::swap(thermal_model_, other->thermal_model_);
    std::swap(safety_limits_, other->safety_limits_);
    std::swap(name_, other->name_);
    std::swap(persist_all_, other->persist_all_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Settings::GetTypeName() const {
  return "biorobotics.firmware.protos.settings.Settings";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace settings
}  // namespace protos
}  // namespace firmware
}  // namespace biorobotics

// @@protoc_insertion_point(global_scope)
