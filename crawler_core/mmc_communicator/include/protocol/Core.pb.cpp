// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Core.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Core.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace biorobotics {
namespace firmware {
namespace protos {

void protobuf_ShutdownFile_Core_2eproto() {
  delete Echo::default_instance_;
  delete FirmwareInfo::default_instance_;
  delete HardwareInfo::default_instance_;
  delete EthernetInfo::default_instance_;
  delete DebugMessage::default_instance_;
  delete RootMessage::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_Core_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_Core_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::biorobotics::firmware::protos::settings::protobuf_AddDesc_Settings_2eproto();
  ::biorobotics::firmware::protos::protobuf_AddDesc_RemoteServices_2eproto();
  ::biorobotics::firmware::protos::protobuf_AddDesc_Control_2eproto();
  Echo::default_instance_ = new Echo();
  FirmwareInfo::default_instance_ = new FirmwareInfo();
  HardwareInfo::default_instance_ = new HardwareInfo();
  EthernetInfo::default_instance_ = new EthernetInfo();
  DebugMessage::default_instance_ = new DebugMessage();
  RootMessage::default_instance_ = new RootMessage();
  Echo::default_instance_->InitAsDefaultInstance();
  FirmwareInfo::default_instance_->InitAsDefaultInstance();
  HardwareInfo::default_instance_->InitAsDefaultInstance();
  EthernetInfo::default_instance_->InitAsDefaultInstance();
  DebugMessage::default_instance_->InitAsDefaultInstance();
  RootMessage::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Core_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_Core_2eproto_once_);
void protobuf_AddDesc_Core_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_Core_2eproto_once_,
                 &protobuf_AddDesc_Core_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Core_2eproto {
  StaticDescriptorInitializer_Core_2eproto() {
    protobuf_AddDesc_Core_2eproto();
  }
} static_descriptor_initializer_Core_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int Echo::kPayloadFieldNumber;
const int Echo::kTxTimeSecFieldNumber;
const int Echo::kTxTimeUsecFieldNumber;
#endif  // !_MSC_VER

Echo::Echo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Echo::InitAsDefaultInstance() {
}

Echo::Echo(const Echo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Echo::SharedCtor() {
  _cached_size_ = 0;
  payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  tx_time_sec_ = 0u;
  tx_time_usec_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Echo::~Echo() {
  SharedDtor();
}

void Echo::SharedDtor() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Echo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Echo& Echo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Core_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Core_2eproto();
#endif
  return *default_instance_;
}

Echo* Echo::default_instance_ = NULL;

Echo* Echo::New() const {
  return new Echo;
}

void Echo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_payload()) {
      if (payload_ != &::google::protobuf::internal::kEmptyString) {
        payload_->clear();
      }
    }
    tx_time_sec_ = 0u;
    tx_time_usec_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Echo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes payload = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_tx_time_sec;
        break;
      }

      // optional uint32 tx_time_sec = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tx_time_sec:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tx_time_sec_)));
          set_has_tx_time_sec();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_tx_time_usec;
        break;
      }

      // optional uint32 tx_time_usec = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tx_time_usec:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tx_time_usec_)));
          set_has_tx_time_usec();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Echo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes payload = 1;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->payload(), output);
  }

  // optional uint32 tx_time_sec = 2;
  if (has_tx_time_sec()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->tx_time_sec(), output);
  }

  // optional uint32 tx_time_usec = 3;
  if (has_tx_time_usec()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->tx_time_usec(), output);
  }

}

int Echo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes payload = 1;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->payload());
    }

    // optional uint32 tx_time_sec = 2;
    if (has_tx_time_sec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tx_time_sec());
    }

    // optional uint32 tx_time_usec = 3;
    if (has_tx_time_usec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tx_time_usec());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Echo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Echo*>(&from));
}

void Echo::MergeFrom(const Echo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_payload()) {
      set_payload(from.payload());
    }
    if (from.has_tx_time_sec()) {
      set_tx_time_sec(from.tx_time_sec());
    }
    if (from.has_tx_time_usec()) {
      set_tx_time_usec(from.tx_time_usec());
    }
  }
}

void Echo::CopyFrom(const Echo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Echo::IsInitialized() const {

  return true;
}

void Echo::Swap(Echo* other) {
  if (other != this) {
    std::swap(payload_, other->payload_);
    std::swap(tx_time_sec_, other->tx_time_sec_);
    std::swap(tx_time_usec_, other->tx_time_usec_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Echo::GetTypeName() const {
  return "biorobotics.firmware.protos.Echo";
}


// ===================================================================

bool FirmwareInfo_FirmwareType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const FirmwareInfo_FirmwareType FirmwareInfo::APPLICATION;
const FirmwareInfo_FirmwareType FirmwareInfo::BOOTLOADER;
const FirmwareInfo_FirmwareType FirmwareInfo::FirmwareType_MIN;
const FirmwareInfo_FirmwareType FirmwareInfo::FirmwareType_MAX;
const int FirmwareInfo::FirmwareType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int FirmwareInfo::kVersionFieldNumber;
const int FirmwareInfo::kBuildDateFieldNumber;
const int FirmwareInfo::kTagFieldNumber;
const int FirmwareInfo::kUsernameFieldNumber;
const int FirmwareInfo::kTypeFieldNumber;
#endif  // !_MSC_VER

FirmwareInfo::FirmwareInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FirmwareInfo::InitAsDefaultInstance() {
}

FirmwareInfo::FirmwareInfo(const FirmwareInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FirmwareInfo::SharedCtor() {
  _cached_size_ = 0;
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  build_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FirmwareInfo::~FirmwareInfo() {
  SharedDtor();
}

void FirmwareInfo::SharedDtor() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (build_date_ != &::google::protobuf::internal::kEmptyString) {
    delete build_date_;
  }
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    delete tag_;
  }
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FirmwareInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FirmwareInfo& FirmwareInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Core_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Core_2eproto();
#endif
  return *default_instance_;
}

FirmwareInfo* FirmwareInfo::default_instance_ = NULL;

FirmwareInfo* FirmwareInfo::New() const {
  return new FirmwareInfo;
}

void FirmwareInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
    if (has_build_date()) {
      if (build_date_ != &::google::protobuf::internal::kEmptyString) {
        build_date_->clear();
      }
    }
    if (has_tag()) {
      if (tag_ != &::google::protobuf::internal::kEmptyString) {
        tag_->clear();
      }
    }
    if (has_username()) {
      if (username_ != &::google::protobuf::internal::kEmptyString) {
        username_->clear();
      }
    }
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FirmwareInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_build_date;
        break;
      }

      // optional string build_date = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_build_date:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_build_date()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_tag;
        break;
      }

      // optional string tag = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tag:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_tag()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_username;
        break;
      }

      // optional string username = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_username:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_username()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_type;
        break;
      }

      // optional .biorobotics.firmware.protos.FirmwareInfo.FirmwareType type = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::biorobotics::firmware::protos::FirmwareInfo_FirmwareType_IsValid(value)) {
            set_type(static_cast< ::biorobotics::firmware::protos::FirmwareInfo_FirmwareType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FirmwareInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->version(), output);
  }

  // optional string build_date = 2;
  if (has_build_date()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->build_date(), output);
  }

  // optional string tag = 3;
  if (has_tag()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->tag(), output);
  }

  // optional string username = 4;
  if (has_username()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->username(), output);
  }

  // optional .biorobotics.firmware.protos.FirmwareInfo.FirmwareType type = 10;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->type(), output);
  }

}

int FirmwareInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional string build_date = 2;
    if (has_build_date()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->build_date());
    }

    // optional string tag = 3;
    if (has_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->tag());
    }

    // optional string username = 4;
    if (has_username()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->username());
    }

    // optional .biorobotics.firmware.protos.FirmwareInfo.FirmwareType type = 10;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FirmwareInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FirmwareInfo*>(&from));
}

void FirmwareInfo::MergeFrom(const FirmwareInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_build_date()) {
      set_build_date(from.build_date());
    }
    if (from.has_tag()) {
      set_tag(from.tag());
    }
    if (from.has_username()) {
      set_username(from.username());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void FirmwareInfo::CopyFrom(const FirmwareInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FirmwareInfo::IsInitialized() const {

  return true;
}

void FirmwareInfo::Swap(FirmwareInfo* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(build_date_, other->build_date_);
    std::swap(tag_, other->tag_);
    std::swap(username_, other->username_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FirmwareInfo::GetTypeName() const {
  return "biorobotics.firmware.protos.FirmwareInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int HardwareInfo::kSerialNumberFieldNumber;
const int HardwareInfo::kTypeFieldNumber;
const int HardwareInfo::kRevisionFieldNumber;
const int HardwareInfo::kProcessorFieldNumber;
#endif  // !_MSC_VER

HardwareInfo::HardwareInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void HardwareInfo::InitAsDefaultInstance() {
}

HardwareInfo::HardwareInfo(const HardwareInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void HardwareInfo::SharedCtor() {
  _cached_size_ = 0;
  serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  revision_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  processor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HardwareInfo::~HardwareInfo() {
  SharedDtor();
}

void HardwareInfo::SharedDtor() {
  if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
    delete serial_number_;
  }
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (revision_ != &::google::protobuf::internal::kEmptyString) {
    delete revision_;
  }
  if (processor_ != &::google::protobuf::internal::kEmptyString) {
    delete processor_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void HardwareInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HardwareInfo& HardwareInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Core_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Core_2eproto();
#endif
  return *default_instance_;
}

HardwareInfo* HardwareInfo::default_instance_ = NULL;

HardwareInfo* HardwareInfo::New() const {
  return new HardwareInfo;
}

void HardwareInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_serial_number()) {
      if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
        serial_number_->clear();
      }
    }
    if (has_type()) {
      if (type_ != &::google::protobuf::internal::kEmptyString) {
        type_->clear();
      }
    }
    if (has_revision()) {
      if (revision_ != &::google::protobuf::internal::kEmptyString) {
        revision_->clear();
      }
    }
    if (has_processor()) {
      if (processor_ != &::google::protobuf::internal::kEmptyString) {
        processor_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool HardwareInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes serial_number = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serial_number()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_type;
        break;
      }

      // optional string type = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_revision;
        break;
      }

      // optional string revision = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_revision:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_revision()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_processor;
        break;
      }

      // optional string processor = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_processor:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_processor()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HardwareInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes serial_number = 1;
  if (has_serial_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->serial_number(), output);
  }

  // optional string type = 5;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->type(), output);
  }

  // optional string revision = 6;
  if (has_revision()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->revision(), output);
  }

  // optional string processor = 7;
  if (has_processor()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->processor(), output);
  }

}

int HardwareInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes serial_number = 1;
    if (has_serial_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serial_number());
    }

    // optional string type = 5;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->type());
    }

    // optional string revision = 6;
    if (has_revision()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->revision());
    }

    // optional string processor = 7;
    if (has_processor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->processor());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HardwareInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HardwareInfo*>(&from));
}

void HardwareInfo::MergeFrom(const HardwareInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serial_number()) {
      set_serial_number(from.serial_number());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_revision()) {
      set_revision(from.revision());
    }
    if (from.has_processor()) {
      set_processor(from.processor());
    }
  }
}

void HardwareInfo::CopyFrom(const HardwareInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HardwareInfo::IsInitialized() const {

  return true;
}

void HardwareInfo::Swap(HardwareInfo* other) {
  if (other != this) {
    std::swap(serial_number_, other->serial_number_);
    std::swap(type_, other->type_);
    std::swap(revision_, other->revision_);
    std::swap(processor_, other->processor_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string HardwareInfo::GetTypeName() const {
  return "biorobotics.firmware.protos.HardwareInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int EthernetInfo::kMacAddressFieldNumber;
const int EthernetInfo::kIpAddressFieldNumber;
const int EthernetInfo::kNetmaskFieldNumber;
const int EthernetInfo::kGatewayFieldNumber;
const int EthernetInfo::kProximalIpFieldNumber;
const int EthernetInfo::kDistalIpsFieldNumber;
#endif  // !_MSC_VER

EthernetInfo::EthernetInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EthernetInfo::InitAsDefaultInstance() {
}

EthernetInfo::EthernetInfo(const EthernetInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EthernetInfo::SharedCtor() {
  _cached_size_ = 0;
  mac_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ip_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  netmask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  gateway_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  proximal_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EthernetInfo::~EthernetInfo() {
  SharedDtor();
}

void EthernetInfo::SharedDtor() {
  if (mac_address_ != &::google::protobuf::internal::kEmptyString) {
    delete mac_address_;
  }
  if (ip_address_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_address_;
  }
  if (netmask_ != &::google::protobuf::internal::kEmptyString) {
    delete netmask_;
  }
  if (gateway_ != &::google::protobuf::internal::kEmptyString) {
    delete gateway_;
  }
  if (proximal_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete proximal_ip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EthernetInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EthernetInfo& EthernetInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Core_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Core_2eproto();
#endif
  return *default_instance_;
}

EthernetInfo* EthernetInfo::default_instance_ = NULL;

EthernetInfo* EthernetInfo::New() const {
  return new EthernetInfo;
}

void EthernetInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_mac_address()) {
      if (mac_address_ != &::google::protobuf::internal::kEmptyString) {
        mac_address_->clear();
      }
    }
    if (has_ip_address()) {
      if (ip_address_ != &::google::protobuf::internal::kEmptyString) {
        ip_address_->clear();
      }
    }
    if (has_netmask()) {
      if (netmask_ != &::google::protobuf::internal::kEmptyString) {
        netmask_->clear();
      }
    }
    if (has_gateway()) {
      if (gateway_ != &::google::protobuf::internal::kEmptyString) {
        gateway_->clear();
      }
    }
    if (has_proximal_ip()) {
      if (proximal_ip_ != &::google::protobuf::internal::kEmptyString) {
        proximal_ip_->clear();
      }
    }
  }
  distal_ips_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EthernetInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes mac_address = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_mac_address()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_ip_address;
        break;
      }

      // optional bytes ip_address = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ip_address()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(170)) goto parse_netmask;
        break;
      }

      // optional bytes netmask = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_netmask:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_netmask()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(178)) goto parse_gateway;
        break;
      }

      // optional bytes gateway = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gateway:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_gateway()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(322)) goto parse_proximal_ip;
        break;
      }

      // optional bytes proximal_ip = 40;
      case 40: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_proximal_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_proximal_ip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(338)) goto parse_distal_ips;
        break;
      }

      // repeated bytes distal_ips = 42;
      case 42: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_distal_ips:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_distal_ips()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(338)) goto parse_distal_ips;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EthernetInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes mac_address = 10;
  if (has_mac_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      10, this->mac_address(), output);
  }

  // optional bytes ip_address = 20;
  if (has_ip_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      20, this->ip_address(), output);
  }

  // optional bytes netmask = 21;
  if (has_netmask()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      21, this->netmask(), output);
  }

  // optional bytes gateway = 22;
  if (has_gateway()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      22, this->gateway(), output);
  }

  // optional bytes proximal_ip = 40;
  if (has_proximal_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      40, this->proximal_ip(), output);
  }

  // repeated bytes distal_ips = 42;
  for (int i = 0; i < this->distal_ips_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      42, this->distal_ips(i), output);
  }

}

int EthernetInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes mac_address = 10;
    if (has_mac_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->mac_address());
    }

    // optional bytes ip_address = 20;
    if (has_ip_address()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ip_address());
    }

    // optional bytes netmask = 21;
    if (has_netmask()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->netmask());
    }

    // optional bytes gateway = 22;
    if (has_gateway()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->gateway());
    }

    // optional bytes proximal_ip = 40;
    if (has_proximal_ip()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->proximal_ip());
    }

  }
  // repeated bytes distal_ips = 42;
  total_size += 2 * this->distal_ips_size();
  for (int i = 0; i < this->distal_ips_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->distal_ips(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EthernetInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EthernetInfo*>(&from));
}

void EthernetInfo::MergeFrom(const EthernetInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  distal_ips_.MergeFrom(from.distal_ips_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mac_address()) {
      set_mac_address(from.mac_address());
    }
    if (from.has_ip_address()) {
      set_ip_address(from.ip_address());
    }
    if (from.has_netmask()) {
      set_netmask(from.netmask());
    }
    if (from.has_gateway()) {
      set_gateway(from.gateway());
    }
    if (from.has_proximal_ip()) {
      set_proximal_ip(from.proximal_ip());
    }
  }
}

void EthernetInfo::CopyFrom(const EthernetInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthernetInfo::IsInitialized() const {

  return true;
}

void EthernetInfo::Swap(EthernetInfo* other) {
  if (other != this) {
    std::swap(mac_address_, other->mac_address_);
    std::swap(ip_address_, other->ip_address_);
    std::swap(netmask_, other->netmask_);
    std::swap(gateway_, other->gateway_);
    std::swap(proximal_ip_, other->proximal_ip_);
    distal_ips_.Swap(&other->distal_ips_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EthernetInfo::GetTypeName() const {
  return "biorobotics.firmware.protos.EthernetInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int DebugMessage::kBytesPayloadsFieldNumber;
const int DebugMessage::kFloatPayloadsFieldNumber;
const int DebugMessage::kFloatPayloadsUnitsFieldNumber;
#endif  // !_MSC_VER

DebugMessage::DebugMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DebugMessage::InitAsDefaultInstance() {
}

DebugMessage::DebugMessage(const DebugMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DebugMessage::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DebugMessage::~DebugMessage() {
  SharedDtor();
}

void DebugMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DebugMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DebugMessage& DebugMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Core_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Core_2eproto();
#endif
  return *default_instance_;
}

DebugMessage* DebugMessage::default_instance_ = NULL;

DebugMessage* DebugMessage::New() const {
  return new DebugMessage;
}

void DebugMessage::Clear() {
  bytes_payloads_.Clear();
  float_payloads_.Clear();
  float_payloads_units_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DebugMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bytes bytes_payloads = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bytes_payloads:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_bytes_payloads()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_bytes_payloads;
        if (input->ExpectTag(21)) goto parse_float_payloads;
        break;
      }

      // repeated float float_payloads = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_float_payloads:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 21, input, this->mutable_float_payloads())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_float_payloads())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_float_payloads;
        if (input->ExpectTag(26)) goto parse_float_payloads_units;
        break;
      }

      // repeated string float_payloads_units = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_float_payloads_units:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_float_payloads_units()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_float_payloads_units;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DebugMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated bytes bytes_payloads = 1;
  for (int i = 0; i < this->bytes_payloads_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->bytes_payloads(i), output);
  }

  // repeated float float_payloads = 2;
  for (int i = 0; i < this->float_payloads_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      2, this->float_payloads(i), output);
  }

  // repeated string float_payloads_units = 3;
  for (int i = 0; i < this->float_payloads_units_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->float_payloads_units(i), output);
  }

}

int DebugMessage::ByteSize() const {
  int total_size = 0;

  // repeated bytes bytes_payloads = 1;
  total_size += 1 * this->bytes_payloads_size();
  for (int i = 0; i < this->bytes_payloads_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->bytes_payloads(i));
  }

  // repeated float float_payloads = 2;
  {
    int data_size = 0;
    data_size = 4 * this->float_payloads_size();
    total_size += 1 * this->float_payloads_size() + data_size;
  }

  // repeated string float_payloads_units = 3;
  total_size += 1 * this->float_payloads_units_size();
  for (int i = 0; i < this->float_payloads_units_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->float_payloads_units(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DebugMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DebugMessage*>(&from));
}

void DebugMessage::MergeFrom(const DebugMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  bytes_payloads_.MergeFrom(from.bytes_payloads_);
  float_payloads_.MergeFrom(from.float_payloads_);
  float_payloads_units_.MergeFrom(from.float_payloads_units_);
}

void DebugMessage::CopyFrom(const DebugMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugMessage::IsInitialized() const {

  return true;
}

void DebugMessage::Swap(DebugMessage* other) {
  if (other != this) {
    bytes_payloads_.Swap(&other->bytes_payloads_);
    float_payloads_.Swap(&other->float_payloads_);
    float_payloads_units_.Swap(&other->float_payloads_units_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DebugMessage::GetTypeName() const {
  return "biorobotics.firmware.protos.DebugMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int RootMessage::kFirmwareInfoFieldNumber;
const int RootMessage::kRequestFirmwareInfoFieldNumber;
const int RootMessage::kHardwareInfoFieldNumber;
const int RootMessage::kRequestHardwareInfoFieldNumber;
const int RootMessage::kEthernetInfoFieldNumber;
const int RootMessage::kRequestEthernetInfoFieldNumber;
const int RootMessage::kRxTimeSecFieldNumber;
const int RootMessage::kRxTimeUsecFieldNumber;
const int RootMessage::kTxTimeSecFieldNumber;
const int RootMessage::kTxTimeUsecFieldNumber;
const int RootMessage::kEchoFieldNumber;
const int RootMessage::kCommandFieldNumber;
const int RootMessage::kRequestCommandFieldNumber;
const int RootMessage::kFeedbackFieldNumber;
const int RootMessage::kRequestFeedbackFieldNumber;
const int RootMessage::kSettingsFieldNumber;
const int RootMessage::kRequestSettingsFieldNumber;
const int RootMessage::kRemoteServicesFieldNumber;
const int RootMessage::kRequestRemoteServicesFieldNumber;
const int RootMessage::kResetFieldNumber;
const int RootMessage::kDebugFieldNumber;
#endif  // !_MSC_VER

RootMessage::RootMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RootMessage::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  firmware_info_ = const_cast< ::biorobotics::firmware::protos::FirmwareInfo*>(
      ::biorobotics::firmware::protos::FirmwareInfo::internal_default_instance());
#else
  firmware_info_ = const_cast< ::biorobotics::firmware::protos::FirmwareInfo*>(&::biorobotics::firmware::protos::FirmwareInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  hardware_info_ = const_cast< ::biorobotics::firmware::protos::HardwareInfo*>(
      ::biorobotics::firmware::protos::HardwareInfo::internal_default_instance());
#else
  hardware_info_ = const_cast< ::biorobotics::firmware::protos::HardwareInfo*>(&::biorobotics::firmware::protos::HardwareInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  ethernet_info_ = const_cast< ::biorobotics::firmware::protos::EthernetInfo*>(
      ::biorobotics::firmware::protos::EthernetInfo::internal_default_instance());
#else
  ethernet_info_ = const_cast< ::biorobotics::firmware::protos::EthernetInfo*>(&::biorobotics::firmware::protos::EthernetInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  echo_ = const_cast< ::biorobotics::firmware::protos::Echo*>(
      ::biorobotics::firmware::protos::Echo::internal_default_instance());
#else
  echo_ = const_cast< ::biorobotics::firmware::protos::Echo*>(&::biorobotics::firmware::protos::Echo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  command_ = const_cast< ::biorobotics::firmware::protos::Command*>(
      ::biorobotics::firmware::protos::Command::internal_default_instance());
#else
  command_ = const_cast< ::biorobotics::firmware::protos::Command*>(&::biorobotics::firmware::protos::Command::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  feedback_ = const_cast< ::biorobotics::firmware::protos::Feedback*>(
      ::biorobotics::firmware::protos::Feedback::internal_default_instance());
#else
  feedback_ = const_cast< ::biorobotics::firmware::protos::Feedback*>(&::biorobotics::firmware::protos::Feedback::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  settings_ = const_cast< ::biorobotics::firmware::protos::settings::Settings*>(
      ::biorobotics::firmware::protos::settings::Settings::internal_default_instance());
#else
  settings_ = const_cast< ::biorobotics::firmware::protos::settings::Settings*>(&::biorobotics::firmware::protos::settings::Settings::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  remote_services_ = const_cast< ::biorobotics::firmware::protos::RemoteServices*>(
      ::biorobotics::firmware::protos::RemoteServices::internal_default_instance());
#else
  remote_services_ = const_cast< ::biorobotics::firmware::protos::RemoteServices*>(&::biorobotics::firmware::protos::RemoteServices::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  debug_ = const_cast< ::biorobotics::firmware::protos::DebugMessage*>(
      ::biorobotics::firmware::protos::DebugMessage::internal_default_instance());
#else
  debug_ = const_cast< ::biorobotics::firmware::protos::DebugMessage*>(&::biorobotics::firmware::protos::DebugMessage::default_instance());
#endif
}

RootMessage::RootMessage(const RootMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RootMessage::SharedCtor() {
  _cached_size_ = 0;
  firmware_info_ = NULL;
  request_firmware_info_ = false;
  hardware_info_ = NULL;
  request_hardware_info_ = false;
  ethernet_info_ = NULL;
  request_ethernet_info_ = false;
  rx_time_sec_ = 0u;
  rx_time_usec_ = 0u;
  tx_time_sec_ = 0u;
  tx_time_usec_ = 0u;
  echo_ = NULL;
  command_ = NULL;
  request_command_ = false;
  feedback_ = NULL;
  request_feedback_ = false;
  settings_ = NULL;
  request_settings_ = false;
  remote_services_ = NULL;
  request_remote_services_ = false;
  reset_ = false;
  debug_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RootMessage::~RootMessage() {
  SharedDtor();
}

void RootMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete firmware_info_;
    delete hardware_info_;
    delete ethernet_info_;
    delete echo_;
    delete command_;
    delete feedback_;
    delete settings_;
    delete remote_services_;
    delete debug_;
  }
}

void RootMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RootMessage& RootMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Core_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Core_2eproto();
#endif
  return *default_instance_;
}

RootMessage* RootMessage::default_instance_ = NULL;

RootMessage* RootMessage::New() const {
  return new RootMessage;
}

void RootMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_firmware_info()) {
      if (firmware_info_ != NULL) firmware_info_->::biorobotics::firmware::protos::FirmwareInfo::Clear();
    }
    request_firmware_info_ = false;
    if (has_hardware_info()) {
      if (hardware_info_ != NULL) hardware_info_->::biorobotics::firmware::protos::HardwareInfo::Clear();
    }
    request_hardware_info_ = false;
    if (has_ethernet_info()) {
      if (ethernet_info_ != NULL) ethernet_info_->::biorobotics::firmware::protos::EthernetInfo::Clear();
    }
    request_ethernet_info_ = false;
    rx_time_sec_ = 0u;
    rx_time_usec_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    tx_time_sec_ = 0u;
    tx_time_usec_ = 0u;
    if (has_echo()) {
      if (echo_ != NULL) echo_->::biorobotics::firmware::protos::Echo::Clear();
    }
    if (has_command()) {
      if (command_ != NULL) command_->::biorobotics::firmware::protos::Command::Clear();
    }
    request_command_ = false;
    if (has_feedback()) {
      if (feedback_ != NULL) feedback_->::biorobotics::firmware::protos::Feedback::Clear();
    }
    request_feedback_ = false;
    if (has_settings()) {
      if (settings_ != NULL) settings_->::biorobotics::firmware::protos::settings::Settings::Clear();
    }
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    request_settings_ = false;
    if (has_remote_services()) {
      if (remote_services_ != NULL) remote_services_->::biorobotics::firmware::protos::RemoteServices::Clear();
    }
    request_remote_services_ = false;
    reset_ = false;
    if (has_debug()) {
      if (debug_ != NULL) debug_->::biorobotics::firmware::protos::DebugMessage::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RootMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 rx_time_sec = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rx_time_sec_)));
          set_has_rx_time_sec();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_rx_time_usec;
        break;
      }

      // optional uint32 rx_time_usec = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rx_time_usec:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rx_time_usec_)));
          set_has_rx_time_usec();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_tx_time_sec;
        break;
      }

      // optional uint32 tx_time_sec = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tx_time_sec:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tx_time_sec_)));
          set_has_tx_time_sec();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_tx_time_usec;
        break;
      }

      // optional uint32 tx_time_usec = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tx_time_usec:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tx_time_usec_)));
          set_has_tx_time_usec();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_echo;
        break;
      }

      // optional .biorobotics.firmware.protos.Echo echo = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_echo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_echo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_command;
        break;
      }

      // optional .biorobotics.firmware.protos.Command command = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_command:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_command()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_feedback;
        break;
      }

      // optional .biorobotics.firmware.protos.Feedback feedback = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_feedback:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_feedback()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_request_feedback;
        break;
      }

      // optional bool request_feedback = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_request_feedback:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &request_feedback_)));
          set_has_request_feedback();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_request_command;
        break;
      }

      // optional bool request_command = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_request_command:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &request_command_)));
          set_has_request_command();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_settings;
        break;
      }

      // optional .biorobotics.firmware.protos.settings.Settings settings = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_settings:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_settings()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(168)) goto parse_request_settings;
        break;
      }

      // optional bool request_settings = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_request_settings:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &request_settings_)));
          set_has_request_settings();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(250)) goto parse_remote_services;
        break;
      }

      // optional .biorobotics.firmware.protos.RemoteServices remote_services = 31;
      case 31: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_remote_services:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_remote_services()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(256)) goto parse_request_remote_services;
        break;
      }

      // optional bool request_remote_services = 32;
      case 32: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_request_remote_services:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &request_remote_services_)));
          set_has_request_remote_services();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(640)) goto parse_reset;
        break;
      }

      // optional bool reset = 80;
      case 80: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_reset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &reset_)));
          set_has_reset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(722)) goto parse_debug;
        break;
      }

      // optional .biorobotics.firmware.protos.DebugMessage debug = 90;
      case 90: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_debug:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_debug()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8082)) goto parse_firmware_info;
        break;
      }

      // optional .biorobotics.firmware.protos.FirmwareInfo firmware_info = 1010;
      case 1010: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_firmware_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_firmware_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8088)) goto parse_request_firmware_info;
        break;
      }

      // optional bool request_firmware_info = 1011;
      case 1011: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_request_firmware_info:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &request_firmware_info_)));
          set_has_request_firmware_info();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8098)) goto parse_hardware_info;
        break;
      }

      // optional .biorobotics.firmware.protos.HardwareInfo hardware_info = 1012;
      case 1012: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hardware_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_hardware_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8104)) goto parse_request_hardware_info;
        break;
      }

      // optional bool request_hardware_info = 1013;
      case 1013: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_request_hardware_info:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &request_hardware_info_)));
          set_has_request_hardware_info();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8122)) goto parse_ethernet_info;
        break;
      }

      // optional .biorobotics.firmware.protos.EthernetInfo ethernet_info = 1015;
      case 1015: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ethernet_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ethernet_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8128)) goto parse_request_ethernet_info;
        break;
      }

      // optional bool request_ethernet_info = 1016;
      case 1016: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_request_ethernet_info:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &request_ethernet_info_)));
          set_has_request_ethernet_info();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RootMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 rx_time_sec = 3;
  if (has_rx_time_sec()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->rx_time_sec(), output);
  }

  // optional uint32 rx_time_usec = 4;
  if (has_rx_time_usec()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->rx_time_usec(), output);
  }

  // optional uint32 tx_time_sec = 5;
  if (has_tx_time_sec()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->tx_time_sec(), output);
  }

  // optional uint32 tx_time_usec = 6;
  if (has_tx_time_usec()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->tx_time_usec(), output);
  }

  // optional .biorobotics.firmware.protos.Echo echo = 8;
  if (has_echo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->echo(), output);
  }

  // optional .biorobotics.firmware.protos.Command command = 10;
  if (has_command()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, this->command(), output);
  }

  // optional .biorobotics.firmware.protos.Feedback feedback = 11;
  if (has_feedback()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, this->feedback(), output);
  }

  // optional bool request_feedback = 12;
  if (has_request_feedback()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->request_feedback(), output);
  }

  // optional bool request_command = 13;
  if (has_request_command()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->request_command(), output);
  }

  // optional .biorobotics.firmware.protos.settings.Settings settings = 20;
  if (has_settings()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      20, this->settings(), output);
  }

  // optional bool request_settings = 21;
  if (has_request_settings()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(21, this->request_settings(), output);
  }

  // optional .biorobotics.firmware.protos.RemoteServices remote_services = 31;
  if (has_remote_services()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      31, this->remote_services(), output);
  }

  // optional bool request_remote_services = 32;
  if (has_request_remote_services()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(32, this->request_remote_services(), output);
  }

  // optional bool reset = 80;
  if (has_reset()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(80, this->reset(), output);
  }

  // optional .biorobotics.firmware.protos.DebugMessage debug = 90;
  if (has_debug()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      90, this->debug(), output);
  }

  // optional .biorobotics.firmware.protos.FirmwareInfo firmware_info = 1010;
  if (has_firmware_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1010, this->firmware_info(), output);
  }

  // optional bool request_firmware_info = 1011;
  if (has_request_firmware_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1011, this->request_firmware_info(), output);
  }

  // optional .biorobotics.firmware.protos.HardwareInfo hardware_info = 1012;
  if (has_hardware_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1012, this->hardware_info(), output);
  }

  // optional bool request_hardware_info = 1013;
  if (has_request_hardware_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1013, this->request_hardware_info(), output);
  }

  // optional .biorobotics.firmware.protos.EthernetInfo ethernet_info = 1015;
  if (has_ethernet_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1015, this->ethernet_info(), output);
  }

  // optional bool request_ethernet_info = 1016;
  if (has_request_ethernet_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1016, this->request_ethernet_info(), output);
  }

}

int RootMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .biorobotics.firmware.protos.FirmwareInfo firmware_info = 1010;
    if (has_firmware_info()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->firmware_info());
    }

    // optional bool request_firmware_info = 1011;
    if (has_request_firmware_info()) {
      total_size += 2 + 1;
    }

    // optional .biorobotics.firmware.protos.HardwareInfo hardware_info = 1012;
    if (has_hardware_info()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->hardware_info());
    }

    // optional bool request_hardware_info = 1013;
    if (has_request_hardware_info()) {
      total_size += 2 + 1;
    }

    // optional .biorobotics.firmware.protos.EthernetInfo ethernet_info = 1015;
    if (has_ethernet_info()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ethernet_info());
    }

    // optional bool request_ethernet_info = 1016;
    if (has_request_ethernet_info()) {
      total_size += 2 + 1;
    }

    // optional uint32 rx_time_sec = 3;
    if (has_rx_time_sec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rx_time_sec());
    }

    // optional uint32 rx_time_usec = 4;
    if (has_rx_time_usec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rx_time_usec());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 tx_time_sec = 5;
    if (has_tx_time_sec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tx_time_sec());
    }

    // optional uint32 tx_time_usec = 6;
    if (has_tx_time_usec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tx_time_usec());
    }

    // optional .biorobotics.firmware.protos.Echo echo = 8;
    if (has_echo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->echo());
    }

    // optional .biorobotics.firmware.protos.Command command = 10;
    if (has_command()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->command());
    }

    // optional bool request_command = 13;
    if (has_request_command()) {
      total_size += 1 + 1;
    }

    // optional .biorobotics.firmware.protos.Feedback feedback = 11;
    if (has_feedback()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->feedback());
    }

    // optional bool request_feedback = 12;
    if (has_request_feedback()) {
      total_size += 1 + 1;
    }

    // optional .biorobotics.firmware.protos.settings.Settings settings = 20;
    if (has_settings()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->settings());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional bool request_settings = 21;
    if (has_request_settings()) {
      total_size += 2 + 1;
    }

    // optional .biorobotics.firmware.protos.RemoteServices remote_services = 31;
    if (has_remote_services()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->remote_services());
    }

    // optional bool request_remote_services = 32;
    if (has_request_remote_services()) {
      total_size += 2 + 1;
    }

    // optional bool reset = 80;
    if (has_reset()) {
      total_size += 2 + 1;
    }

    // optional .biorobotics.firmware.protos.DebugMessage debug = 90;
    if (has_debug()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->debug());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RootMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RootMessage*>(&from));
}

void RootMessage::MergeFrom(const RootMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_firmware_info()) {
      mutable_firmware_info()->::biorobotics::firmware::protos::FirmwareInfo::MergeFrom(from.firmware_info());
    }
    if (from.has_request_firmware_info()) {
      set_request_firmware_info(from.request_firmware_info());
    }
    if (from.has_hardware_info()) {
      mutable_hardware_info()->::biorobotics::firmware::protos::HardwareInfo::MergeFrom(from.hardware_info());
    }
    if (from.has_request_hardware_info()) {
      set_request_hardware_info(from.request_hardware_info());
    }
    if (from.has_ethernet_info()) {
      mutable_ethernet_info()->::biorobotics::firmware::protos::EthernetInfo::MergeFrom(from.ethernet_info());
    }
    if (from.has_request_ethernet_info()) {
      set_request_ethernet_info(from.request_ethernet_info());
    }
    if (from.has_rx_time_sec()) {
      set_rx_time_sec(from.rx_time_sec());
    }
    if (from.has_rx_time_usec()) {
      set_rx_time_usec(from.rx_time_usec());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_tx_time_sec()) {
      set_tx_time_sec(from.tx_time_sec());
    }
    if (from.has_tx_time_usec()) {
      set_tx_time_usec(from.tx_time_usec());
    }
    if (from.has_echo()) {
      mutable_echo()->::biorobotics::firmware::protos::Echo::MergeFrom(from.echo());
    }
    if (from.has_command()) {
      mutable_command()->::biorobotics::firmware::protos::Command::MergeFrom(from.command());
    }
    if (from.has_request_command()) {
      set_request_command(from.request_command());
    }
    if (from.has_feedback()) {
      mutable_feedback()->::biorobotics::firmware::protos::Feedback::MergeFrom(from.feedback());
    }
    if (from.has_request_feedback()) {
      set_request_feedback(from.request_feedback());
    }
    if (from.has_settings()) {
      mutable_settings()->::biorobotics::firmware::protos::settings::Settings::MergeFrom(from.settings());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_request_settings()) {
      set_request_settings(from.request_settings());
    }
    if (from.has_remote_services()) {
      mutable_remote_services()->::biorobotics::firmware::protos::RemoteServices::MergeFrom(from.remote_services());
    }
    if (from.has_request_remote_services()) {
      set_request_remote_services(from.request_remote_services());
    }
    if (from.has_reset()) {
      set_reset(from.reset());
    }
    if (from.has_debug()) {
      mutable_debug()->::biorobotics::firmware::protos::DebugMessage::MergeFrom(from.debug());
    }
  }
}

void RootMessage::CopyFrom(const RootMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RootMessage::IsInitialized() const {

  return true;
}

void RootMessage::Swap(RootMessage* other) {
  if (other != this) {
    std::swap(firmware_info_, other->firmware_info_);
    std::swap(request_firmware_info_, other->request_firmware_info_);
    std::swap(hardware_info_, other->hardware_info_);
    std::swap(request_hardware_info_, other->request_hardware_info_);
    std::swap(ethernet_info_, other->ethernet_info_);
    std::swap(request_ethernet_info_, other->request_ethernet_info_);
    std::swap(rx_time_sec_, other->rx_time_sec_);
    std::swap(rx_time_usec_, other->rx_time_usec_);
    std::swap(tx_time_sec_, other->tx_time_sec_);
    std::swap(tx_time_usec_, other->tx_time_usec_);
    std::swap(echo_, other->echo_);
    std::swap(command_, other->command_);
    std::swap(request_command_, other->request_command_);
    std::swap(feedback_, other->feedback_);
    std::swap(request_feedback_, other->request_feedback_);
    std::swap(settings_, other->settings_);
    std::swap(request_settings_, other->request_settings_);
    std::swap(remote_services_, other->remote_services_);
    std::swap(request_remote_services_, other->request_remote_services_);
    std::swap(reset_, other->reset_);
    std::swap(debug_, other->debug_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RootMessage::GetTypeName() const {
  return "biorobotics.firmware.protos.RootMessage";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace firmware
}  // namespace biorobotics

// @@protoc_insertion_point(global_scope)
