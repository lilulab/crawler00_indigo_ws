// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Bootloader.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Bootloader.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace protos {
namespace bootloader {

void protobuf_ShutdownFile_Bootloader_2eproto() {
  delete Read::default_instance_;
  delete Write::default_instance_;
  delete Erase::default_instance_;
  delete BootloaderMessage::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_Bootloader_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_Bootloader_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  Read::default_instance_ = new Read();
  Write::default_instance_ = new Write();
  Erase::default_instance_ = new Erase();
  BootloaderMessage::default_instance_ = new BootloaderMessage();
  Read::default_instance_->InitAsDefaultInstance();
  Write::default_instance_->InitAsDefaultInstance();
  Erase::default_instance_->InitAsDefaultInstance();
  BootloaderMessage::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Bootloader_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_Bootloader_2eproto_once_);
void protobuf_AddDesc_Bootloader_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_Bootloader_2eproto_once_,
                 &protobuf_AddDesc_Bootloader_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Bootloader_2eproto {
  StaticDescriptorInitializer_Bootloader_2eproto() {
    protobuf_AddDesc_Bootloader_2eproto();
  }
} static_descriptor_initializer_Bootloader_2eproto_;
#endif
bool Status_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool Partition_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int Read::kPartitionFieldNumber;
const int Read::kOffsetFieldNumber;
const int Read::kLengthFieldNumber;
const int Read::kDataFieldNumber;
const int Read::kStatusFieldNumber;
const int Read::kDebugFieldNumber;
#endif  // !_MSC_VER

Read::Read()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Read::InitAsDefaultInstance() {
}

Read::Read(const Read& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Read::SharedCtor() {
  _cached_size_ = 0;
  partition_ = 0;
  offset_ = 0u;
  length_ = 0u;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_ = 0;
  debug_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Read::~Read() {
  SharedDtor();
}

void Read::SharedDtor() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (debug_ != &::google::protobuf::internal::kEmptyString) {
    delete debug_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Read::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Read& Read::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Bootloader_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Bootloader_2eproto();
#endif
  return *default_instance_;
}

Read* Read::default_instance_ = NULL;

Read* Read::New() const {
  return new Read;
}

void Read::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    partition_ = 0;
    offset_ = 0u;
    length_ = 0u;
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::kEmptyString) {
        data_->clear();
      }
    }
    status_ = 0;
    if (has_debug()) {
      if (debug_ != &::google::protobuf::internal::kEmptyString) {
        debug_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Read::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .protos.bootloader.Partition partition = 1 [default = PARTITION_NONE];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protos::bootloader::Partition_IsValid(value)) {
            set_partition(static_cast< ::protos::bootloader::Partition >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_offset;
        break;
      }

      // optional uint32 offset = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_length;
        break;
      }

      // optional uint32 length = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &length_)));
          set_has_length();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_data;
        break;
      }

      // optional bytes data = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_status;
        break;
      }

      // optional .protos.bootloader.Status status = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protos::bootloader::Status_IsValid(value)) {
            set_status(static_cast< ::protos::bootloader::Status >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_debug;
        break;
      }

      // optional string debug = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_debug:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_debug()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Read::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .protos.bootloader.Partition partition = 1 [default = PARTITION_NONE];
  if (has_partition()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->partition(), output);
  }

  // optional uint32 offset = 2;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->offset(), output);
  }

  // optional uint32 length = 3;
  if (has_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->length(), output);
  }

  // optional bytes data = 8;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      8, this->data(), output);
  }

  // optional .protos.bootloader.Status status = 10;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->status(), output);
  }

  // optional string debug = 11;
  if (has_debug()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      11, this->debug(), output);
  }

}

int Read::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .protos.bootloader.Partition partition = 1 [default = PARTITION_NONE];
    if (has_partition()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->partition());
    }

    // optional uint32 offset = 2;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->offset());
    }

    // optional uint32 length = 3;
    if (has_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->length());
    }

    // optional bytes data = 8;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

    // optional .protos.bootloader.Status status = 10;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // optional string debug = 11;
    if (has_debug()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->debug());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Read::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Read*>(&from));
}

void Read::MergeFrom(const Read& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_partition()) {
      set_partition(from.partition());
    }
    if (from.has_offset()) {
      set_offset(from.offset());
    }
    if (from.has_length()) {
      set_length(from.length());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_debug()) {
      set_debug(from.debug());
    }
  }
}

void Read::CopyFrom(const Read& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Read::IsInitialized() const {

  return true;
}

void Read::Swap(Read* other) {
  if (other != this) {
    std::swap(partition_, other->partition_);
    std::swap(offset_, other->offset_);
    std::swap(length_, other->length_);
    std::swap(data_, other->data_);
    std::swap(status_, other->status_);
    std::swap(debug_, other->debug_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Read::GetTypeName() const {
  return "protos.bootloader.Read";
}


// ===================================================================

#ifndef _MSC_VER
const int Write::kSequenceNumberFieldNumber;
const int Write::kOffsetFieldNumber;
const int Write::kLengthFieldNumber;
const int Write::kIsLastPacketFieldNumber;
const int Write::kDataFieldNumber;
const int Write::kStatusFieldNumber;
const int Write::kDebugFieldNumber;
#endif  // !_MSC_VER

Write::Write()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Write::InitAsDefaultInstance() {
}

Write::Write(const Write& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Write::SharedCtor() {
  _cached_size_ = 0;
  sequence_number_ = 0u;
  offset_ = 0u;
  length_ = 0u;
  is_last_packet_ = false;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_ = 0;
  debug_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Write::~Write() {
  SharedDtor();
}

void Write::SharedDtor() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (debug_ != &::google::protobuf::internal::kEmptyString) {
    delete debug_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Write::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Write& Write::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Bootloader_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Bootloader_2eproto();
#endif
  return *default_instance_;
}

Write* Write::default_instance_ = NULL;

Write* Write::New() const {
  return new Write;
}

void Write::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    sequence_number_ = 0u;
    offset_ = 0u;
    length_ = 0u;
    is_last_packet_ = false;
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::kEmptyString) {
        data_->clear();
      }
    }
    status_ = 0;
    if (has_debug()) {
      if (debug_ != &::google::protobuf::internal::kEmptyString) {
        debug_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Write::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 sequence_number = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sequence_number_)));
          set_has_sequence_number();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_offset;
        break;
      }

      // optional uint32 offset = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_length;
        break;
      }

      // optional uint32 length = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &length_)));
          set_has_length();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_is_last_packet;
        break;
      }

      // optional bool is_last_packet = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_last_packet:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_last_packet_)));
          set_has_is_last_packet();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_data;
        break;
      }

      // optional bytes data = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_status;
        break;
      }

      // optional .protos.bootloader.Status status = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protos::bootloader::Status_IsValid(value)) {
            set_status(static_cast< ::protos::bootloader::Status >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_debug;
        break;
      }

      // optional string debug = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_debug:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_debug()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Write::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 sequence_number = 1;
  if (has_sequence_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sequence_number(), output);
  }

  // optional uint32 offset = 2;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->offset(), output);
  }

  // optional uint32 length = 3;
  if (has_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->length(), output);
  }

  // optional bool is_last_packet = 4;
  if (has_is_last_packet()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->is_last_packet(), output);
  }

  // optional bytes data = 8;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      8, this->data(), output);
  }

  // optional .protos.bootloader.Status status = 10;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->status(), output);
  }

  // optional string debug = 11;
  if (has_debug()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      11, this->debug(), output);
  }

}

int Write::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 sequence_number = 1;
    if (has_sequence_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sequence_number());
    }

    // optional uint32 offset = 2;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->offset());
    }

    // optional uint32 length = 3;
    if (has_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->length());
    }

    // optional bool is_last_packet = 4;
    if (has_is_last_packet()) {
      total_size += 1 + 1;
    }

    // optional bytes data = 8;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

    // optional .protos.bootloader.Status status = 10;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // optional string debug = 11;
    if (has_debug()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->debug());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Write::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Write*>(&from));
}

void Write::MergeFrom(const Write& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sequence_number()) {
      set_sequence_number(from.sequence_number());
    }
    if (from.has_offset()) {
      set_offset(from.offset());
    }
    if (from.has_length()) {
      set_length(from.length());
    }
    if (from.has_is_last_packet()) {
      set_is_last_packet(from.is_last_packet());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_debug()) {
      set_debug(from.debug());
    }
  }
}

void Write::CopyFrom(const Write& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Write::IsInitialized() const {

  return true;
}

void Write::Swap(Write* other) {
  if (other != this) {
    std::swap(sequence_number_, other->sequence_number_);
    std::swap(offset_, other->offset_);
    std::swap(length_, other->length_);
    std::swap(is_last_packet_, other->is_last_packet_);
    std::swap(data_, other->data_);
    std::swap(status_, other->status_);
    std::swap(debug_, other->debug_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Write::GetTypeName() const {
  return "protos.bootloader.Write";
}


// ===================================================================

#ifndef _MSC_VER
const int Erase::kPartitionFieldNumber;
const int Erase::kStatusFieldNumber;
const int Erase::kDebugFieldNumber;
#endif  // !_MSC_VER

Erase::Erase()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Erase::InitAsDefaultInstance() {
}

Erase::Erase(const Erase& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Erase::SharedCtor() {
  _cached_size_ = 0;
  partition_ = 0;
  status_ = 0;
  debug_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Erase::~Erase() {
  SharedDtor();
}

void Erase::SharedDtor() {
  if (debug_ != &::google::protobuf::internal::kEmptyString) {
    delete debug_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Erase::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Erase& Erase::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Bootloader_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Bootloader_2eproto();
#endif
  return *default_instance_;
}

Erase* Erase::default_instance_ = NULL;

Erase* Erase::New() const {
  return new Erase;
}

void Erase::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    partition_ = 0;
    status_ = 0;
    if (has_debug()) {
      if (debug_ != &::google::protobuf::internal::kEmptyString) {
        debug_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Erase::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .protos.bootloader.Partition partition = 1 [default = PARTITION_NONE];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protos::bootloader::Partition_IsValid(value)) {
            set_partition(static_cast< ::protos::bootloader::Partition >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_status;
        break;
      }

      // optional .protos.bootloader.Status status = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protos::bootloader::Status_IsValid(value)) {
            set_status(static_cast< ::protos::bootloader::Status >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_debug;
        break;
      }

      // optional string debug = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_debug:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_debug()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Erase::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .protos.bootloader.Partition partition = 1 [default = PARTITION_NONE];
  if (has_partition()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->partition(), output);
  }

  // optional .protos.bootloader.Status status = 10;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->status(), output);
  }

  // optional string debug = 11;
  if (has_debug()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      11, this->debug(), output);
  }

}

int Erase::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .protos.bootloader.Partition partition = 1 [default = PARTITION_NONE];
    if (has_partition()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->partition());
    }

    // optional .protos.bootloader.Status status = 10;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // optional string debug = 11;
    if (has_debug()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->debug());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Erase::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Erase*>(&from));
}

void Erase::MergeFrom(const Erase& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_partition()) {
      set_partition(from.partition());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_debug()) {
      set_debug(from.debug());
    }
  }
}

void Erase::CopyFrom(const Erase& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Erase::IsInitialized() const {

  return true;
}

void Erase::Swap(Erase* other) {
  if (other != this) {
    std::swap(partition_, other->partition_);
    std::swap(status_, other->status_);
    std::swap(debug_, other->debug_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Erase::GetTypeName() const {
  return "protos.bootloader.Erase";
}


// ===================================================================

#ifndef _MSC_VER
const int BootloaderMessage::kReadFieldNumber;
const int BootloaderMessage::kWriteFieldNumber;
const int BootloaderMessage::kEraseFieldNumber;
const int BootloaderMessage::kBootRequestFieldNumber;
#endif  // !_MSC_VER

BootloaderMessage::BootloaderMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BootloaderMessage::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  read_ = const_cast< ::protos::bootloader::Read*>(
      ::protos::bootloader::Read::internal_default_instance());
#else
  read_ = const_cast< ::protos::bootloader::Read*>(&::protos::bootloader::Read::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  write_ = const_cast< ::protos::bootloader::Write*>(
      ::protos::bootloader::Write::internal_default_instance());
#else
  write_ = const_cast< ::protos::bootloader::Write*>(&::protos::bootloader::Write::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  erase_ = const_cast< ::protos::bootloader::Erase*>(
      ::protos::bootloader::Erase::internal_default_instance());
#else
  erase_ = const_cast< ::protos::bootloader::Erase*>(&::protos::bootloader::Erase::default_instance());
#endif
}

BootloaderMessage::BootloaderMessage(const BootloaderMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BootloaderMessage::SharedCtor() {
  _cached_size_ = 0;
  read_ = NULL;
  write_ = NULL;
  erase_ = NULL;
  boot_request_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BootloaderMessage::~BootloaderMessage() {
  SharedDtor();
}

void BootloaderMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete read_;
    delete write_;
    delete erase_;
  }
}

void BootloaderMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BootloaderMessage& BootloaderMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Bootloader_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Bootloader_2eproto();
#endif
  return *default_instance_;
}

BootloaderMessage* BootloaderMessage::default_instance_ = NULL;

BootloaderMessage* BootloaderMessage::New() const {
  return new BootloaderMessage;
}

void BootloaderMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_read()) {
      if (read_ != NULL) read_->::protos::bootloader::Read::Clear();
    }
    if (has_write()) {
      if (write_ != NULL) write_->::protos::bootloader::Write::Clear();
    }
    if (has_erase()) {
      if (erase_ != NULL) erase_->::protos::bootloader::Erase::Clear();
    }
    boot_request_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BootloaderMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .protos.bootloader.Read read = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_read()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_write;
        break;
      }

      // optional .protos.bootloader.Write write = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_write:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_write()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_erase;
        break;
      }

      // optional .protos.bootloader.Erase erase = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_erase:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_erase()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_boot_request;
        break;
      }

      // optional bool boot_request = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_boot_request:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &boot_request_)));
          set_has_boot_request();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BootloaderMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .protos.bootloader.Read read = 1;
  if (has_read()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->read(), output);
  }

  // optional .protos.bootloader.Write write = 2;
  if (has_write()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->write(), output);
  }

  // optional .protos.bootloader.Erase erase = 3;
  if (has_erase()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->erase(), output);
  }

  // optional bool boot_request = 10;
  if (has_boot_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->boot_request(), output);
  }

}

int BootloaderMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .protos.bootloader.Read read = 1;
    if (has_read()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->read());
    }

    // optional .protos.bootloader.Write write = 2;
    if (has_write()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->write());
    }

    // optional .protos.bootloader.Erase erase = 3;
    if (has_erase()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->erase());
    }

    // optional bool boot_request = 10;
    if (has_boot_request()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BootloaderMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BootloaderMessage*>(&from));
}

void BootloaderMessage::MergeFrom(const BootloaderMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_read()) {
      mutable_read()->::protos::bootloader::Read::MergeFrom(from.read());
    }
    if (from.has_write()) {
      mutable_write()->::protos::bootloader::Write::MergeFrom(from.write());
    }
    if (from.has_erase()) {
      mutable_erase()->::protos::bootloader::Erase::MergeFrom(from.erase());
    }
    if (from.has_boot_request()) {
      set_boot_request(from.boot_request());
    }
  }
}

void BootloaderMessage::CopyFrom(const BootloaderMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BootloaderMessage::IsInitialized() const {

  return true;
}

void BootloaderMessage::Swap(BootloaderMessage* other) {
  if (other != this) {
    std::swap(read_, other->read_);
    std::swap(write_, other->write_);
    std::swap(erase_, other->erase_);
    std::swap(boot_request_, other->boot_request_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BootloaderMessage::GetTypeName() const {
  return "protos.bootloader.BootloaderMessage";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace bootloader
}  // namespace protos

// @@protoc_insertion_point(global_scope)
