// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MetaInfo.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "MetaInfo.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace protos {

void protobuf_ShutdownFile_MetaInfo_2eproto() {
  delete Ping::default_instance_;
  delete FirmwareInfo::default_instance_;
  delete EthernetInfo::default_instance_;
  delete HeaderMessage::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_MetaInfo_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_MetaInfo_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::protos::bootloader::protobuf_AddDesc_Bootloader_2eproto();
  ::protos::protobuf_AddDesc_ModuleControl_2eproto();
  ::protos::protobuf_AddDesc_ModuleParameters_2eproto();
  ::protos::protobuf_AddDesc_RemoteService_2eproto();
  Ping::default_instance_ = new Ping();
  FirmwareInfo::default_instance_ = new FirmwareInfo();
  EthernetInfo::default_instance_ = new EthernetInfo();
  HeaderMessage::default_instance_ = new HeaderMessage();
  Ping::default_instance_->InitAsDefaultInstance();
  FirmwareInfo::default_instance_->InitAsDefaultInstance();
  EthernetInfo::default_instance_->InitAsDefaultInstance();
  HeaderMessage::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_MetaInfo_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_MetaInfo_2eproto_once_);
void protobuf_AddDesc_MetaInfo_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_MetaInfo_2eproto_once_,
                 &protobuf_AddDesc_MetaInfo_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_MetaInfo_2eproto {
  StaticDescriptorInitializer_MetaInfo_2eproto() {
    protobuf_AddDesc_MetaInfo_2eproto();
  }
} static_descriptor_initializer_MetaInfo_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int Ping::kPayloadFieldNumber;
#endif  // !_MSC_VER

Ping::Ping()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Ping::InitAsDefaultInstance() {
}

Ping::Ping(const Ping& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Ping::SharedCtor() {
  _cached_size_ = 0;
  payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Ping::~Ping() {
  SharedDtor();
}

void Ping::SharedDtor() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Ping::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Ping& Ping::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_MetaInfo_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_MetaInfo_2eproto();
#endif
  return *default_instance_;
}

Ping* Ping::default_instance_ = NULL;

Ping* Ping::New() const {
  return new Ping;
}

void Ping::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_payload()) {
      if (payload_ != &::google::protobuf::internal::kEmptyString) {
        payload_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Ping::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes payload = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Ping::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes payload = 1;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->payload(), output);
  }

}

int Ping::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes payload = 1;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->payload());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Ping::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Ping*>(&from));
}

void Ping::MergeFrom(const Ping& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_payload()) {
      set_payload(from.payload());
    }
  }
}

void Ping::CopyFrom(const Ping& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ping::IsInitialized() const {

  return true;
}

void Ping::Swap(Ping* other) {
  if (other != this) {
    std::swap(payload_, other->payload_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Ping::GetTypeName() const {
  return "protos.Ping";
}


// ===================================================================

#ifndef _MSC_VER
const int FirmwareInfo::kVersionFieldNumber;
const int FirmwareInfo::kBuildDateFieldNumber;
const int FirmwareInfo::kTagFieldNumber;
const int FirmwareInfo::kUsernameFieldNumber;
const int FirmwareInfo::kTypeFieldNumber;
#endif  // !_MSC_VER

FirmwareInfo::FirmwareInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FirmwareInfo::InitAsDefaultInstance() {
}

FirmwareInfo::FirmwareInfo(const FirmwareInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FirmwareInfo::SharedCtor() {
  _cached_size_ = 0;
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  build_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FirmwareInfo::~FirmwareInfo() {
  SharedDtor();
}

void FirmwareInfo::SharedDtor() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (build_date_ != &::google::protobuf::internal::kEmptyString) {
    delete build_date_;
  }
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    delete tag_;
  }
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FirmwareInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FirmwareInfo& FirmwareInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_MetaInfo_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_MetaInfo_2eproto();
#endif
  return *default_instance_;
}

FirmwareInfo* FirmwareInfo::default_instance_ = NULL;

FirmwareInfo* FirmwareInfo::New() const {
  return new FirmwareInfo;
}

void FirmwareInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
    if (has_build_date()) {
      if (build_date_ != &::google::protobuf::internal::kEmptyString) {
        build_date_->clear();
      }
    }
    if (has_tag()) {
      if (tag_ != &::google::protobuf::internal::kEmptyString) {
        tag_->clear();
      }
    }
    if (has_username()) {
      if (username_ != &::google::protobuf::internal::kEmptyString) {
        username_->clear();
      }
    }
    if (has_type()) {
      if (type_ != &::google::protobuf::internal::kEmptyString) {
        type_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FirmwareInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_build_date;
        break;
      }

      // optional string build_date = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_build_date:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_build_date()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_tag;
        break;
      }

      // optional string tag = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tag:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_tag()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_username;
        break;
      }

      // optional string username = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_username:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_username()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_type;
        break;
      }

      // optional string type = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FirmwareInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->version(), output);
  }

  // optional string build_date = 2;
  if (has_build_date()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->build_date(), output);
  }

  // optional string tag = 3;
  if (has_tag()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->tag(), output);
  }

  // optional string username = 4;
  if (has_username()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->username(), output);
  }

  // optional string type = 5;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->type(), output);
  }

}

int FirmwareInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional string build_date = 2;
    if (has_build_date()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->build_date());
    }

    // optional string tag = 3;
    if (has_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->tag());
    }

    // optional string username = 4;
    if (has_username()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->username());
    }

    // optional string type = 5;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FirmwareInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FirmwareInfo*>(&from));
}

void FirmwareInfo::MergeFrom(const FirmwareInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_build_date()) {
      set_build_date(from.build_date());
    }
    if (from.has_tag()) {
      set_tag(from.tag());
    }
    if (from.has_username()) {
      set_username(from.username());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void FirmwareInfo::CopyFrom(const FirmwareInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FirmwareInfo::IsInitialized() const {

  return true;
}

void FirmwareInfo::Swap(FirmwareInfo* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(build_date_, other->build_date_);
    std::swap(tag_, other->tag_);
    std::swap(username_, other->username_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FirmwareInfo::GetTypeName() const {
  return "protos.FirmwareInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int EthernetInfo::kMacAddressFieldNumber;
const int EthernetInfo::kAddressFieldNumber;
const int EthernetInfo::kNetmaskFieldNumber;
const int EthernetInfo::kGatewayFieldNumber;
const int EthernetInfo::kProximalIpFieldNumber;
const int EthernetInfo::kDistalIpFieldNumber;
const int EthernetInfo::kSerialNumberFieldNumber;
#endif  // !_MSC_VER

EthernetInfo::EthernetInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EthernetInfo::InitAsDefaultInstance() {
}

EthernetInfo::EthernetInfo(const EthernetInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EthernetInfo::SharedCtor() {
  _cached_size_ = 0;
  mac_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  netmask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  gateway_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  proximal_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  distal_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EthernetInfo::~EthernetInfo() {
  SharedDtor();
}

void EthernetInfo::SharedDtor() {
  if (mac_address_ != &::google::protobuf::internal::kEmptyString) {
    delete mac_address_;
  }
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (netmask_ != &::google::protobuf::internal::kEmptyString) {
    delete netmask_;
  }
  if (gateway_ != &::google::protobuf::internal::kEmptyString) {
    delete gateway_;
  }
  if (proximal_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete proximal_ip_;
  }
  if (distal_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete distal_ip_;
  }
  if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
    delete serial_number_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EthernetInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EthernetInfo& EthernetInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_MetaInfo_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_MetaInfo_2eproto();
#endif
  return *default_instance_;
}

EthernetInfo* EthernetInfo::default_instance_ = NULL;

EthernetInfo* EthernetInfo::New() const {
  return new EthernetInfo;
}

void EthernetInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_mac_address()) {
      if (mac_address_ != &::google::protobuf::internal::kEmptyString) {
        mac_address_->clear();
      }
    }
    if (has_address()) {
      if (address_ != &::google::protobuf::internal::kEmptyString) {
        address_->clear();
      }
    }
    if (has_netmask()) {
      if (netmask_ != &::google::protobuf::internal::kEmptyString) {
        netmask_->clear();
      }
    }
    if (has_gateway()) {
      if (gateway_ != &::google::protobuf::internal::kEmptyString) {
        gateway_->clear();
      }
    }
    if (has_proximal_ip()) {
      if (proximal_ip_ != &::google::protobuf::internal::kEmptyString) {
        proximal_ip_->clear();
      }
    }
    if (has_distal_ip()) {
      if (distal_ip_ != &::google::protobuf::internal::kEmptyString) {
        distal_ip_->clear();
      }
    }
    if (has_serial_number()) {
      if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
        serial_number_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EthernetInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes mac_address = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_mac_address()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_address;
        break;
      }

      // optional bytes address = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_address()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(170)) goto parse_netmask;
        break;
      }

      // optional bytes netmask = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_netmask:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_netmask()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(178)) goto parse_gateway;
        break;
      }

      // optional bytes gateway = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gateway:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_gateway()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(322)) goto parse_proximal_ip;
        break;
      }

      // optional bytes proximal_ip = 40;
      case 40: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_proximal_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_proximal_ip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(330)) goto parse_distal_ip;
        break;
      }

      // optional bytes distal_ip = 41;
      case 41: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_distal_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_distal_ip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(810)) goto parse_serial_number;
        break;
      }

      // optional bytes serial_number = 101;
      case 101: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serial_number:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serial_number()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EthernetInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes mac_address = 10;
  if (has_mac_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      10, this->mac_address(), output);
  }

  // optional bytes address = 20;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      20, this->address(), output);
  }

  // optional bytes netmask = 21;
  if (has_netmask()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      21, this->netmask(), output);
  }

  // optional bytes gateway = 22;
  if (has_gateway()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      22, this->gateway(), output);
  }

  // optional bytes proximal_ip = 40;
  if (has_proximal_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      40, this->proximal_ip(), output);
  }

  // optional bytes distal_ip = 41;
  if (has_distal_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      41, this->distal_ip(), output);
  }

  // optional bytes serial_number = 101;
  if (has_serial_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      101, this->serial_number(), output);
  }

}

int EthernetInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes mac_address = 10;
    if (has_mac_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->mac_address());
    }

    // optional bytes address = 20;
    if (has_address()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->address());
    }

    // optional bytes netmask = 21;
    if (has_netmask()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->netmask());
    }

    // optional bytes gateway = 22;
    if (has_gateway()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->gateway());
    }

    // optional bytes proximal_ip = 40;
    if (has_proximal_ip()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->proximal_ip());
    }

    // optional bytes distal_ip = 41;
    if (has_distal_ip()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->distal_ip());
    }

    // optional bytes serial_number = 101;
    if (has_serial_number()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serial_number());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EthernetInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EthernetInfo*>(&from));
}

void EthernetInfo::MergeFrom(const EthernetInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mac_address()) {
      set_mac_address(from.mac_address());
    }
    if (from.has_address()) {
      set_address(from.address());
    }
    if (from.has_netmask()) {
      set_netmask(from.netmask());
    }
    if (from.has_gateway()) {
      set_gateway(from.gateway());
    }
    if (from.has_proximal_ip()) {
      set_proximal_ip(from.proximal_ip());
    }
    if (from.has_distal_ip()) {
      set_distal_ip(from.distal_ip());
    }
    if (from.has_serial_number()) {
      set_serial_number(from.serial_number());
    }
  }
}

void EthernetInfo::CopyFrom(const EthernetInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthernetInfo::IsInitialized() const {

  return true;
}

void EthernetInfo::Swap(EthernetInfo* other) {
  if (other != this) {
    std::swap(mac_address_, other->mac_address_);
    std::swap(address_, other->address_);
    std::swap(netmask_, other->netmask_);
    std::swap(gateway_, other->gateway_);
    std::swap(proximal_ip_, other->proximal_ip_);
    std::swap(distal_ip_, other->distal_ip_);
    std::swap(serial_number_, other->serial_number_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EthernetInfo::GetTypeName() const {
  return "protos.EthernetInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int HeaderMessage::kPingFieldNumber;
const int HeaderMessage::kFirmwareInfoFieldNumber;
const int HeaderMessage::kRequestFirmwareInfoFieldNumber;
const int HeaderMessage::kEthernetInfoFieldNumber;
const int HeaderMessage::kRequestEthernetInfoFieldNumber;
const int HeaderMessage::kBootloaderFieldNumber;
const int HeaderMessage::kTvSecFieldNumber;
const int HeaderMessage::kTvUsecFieldNumber;
const int HeaderMessage::kModuleCommandFieldNumber;
const int HeaderMessage::kModuleFeedbackFieldNumber;
const int HeaderMessage::kParameterCommandFieldNumber;
const int HeaderMessage::kParameterFeedbackFieldNumber;
const int HeaderMessage::kRemoteServiceFieldNumber;
#endif  // !_MSC_VER

HeaderMessage::HeaderMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void HeaderMessage::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  ping_ = const_cast< ::protos::Ping*>(
      ::protos::Ping::internal_default_instance());
#else
  ping_ = const_cast< ::protos::Ping*>(&::protos::Ping::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  firmware_info_ = const_cast< ::protos::FirmwareInfo*>(
      ::protos::FirmwareInfo::internal_default_instance());
#else
  firmware_info_ = const_cast< ::protos::FirmwareInfo*>(&::protos::FirmwareInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  ethernet_info_ = const_cast< ::protos::EthernetInfo*>(
      ::protos::EthernetInfo::internal_default_instance());
#else
  ethernet_info_ = const_cast< ::protos::EthernetInfo*>(&::protos::EthernetInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  bootloader_ = const_cast< ::protos::bootloader::BootloaderMessage*>(
      ::protos::bootloader::BootloaderMessage::internal_default_instance());
#else
  bootloader_ = const_cast< ::protos::bootloader::BootloaderMessage*>(&::protos::bootloader::BootloaderMessage::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  module_command_ = const_cast< ::protos::ModuleCommand*>(
      ::protos::ModuleCommand::internal_default_instance());
#else
  module_command_ = const_cast< ::protos::ModuleCommand*>(&::protos::ModuleCommand::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  module_feedback_ = const_cast< ::protos::ModuleFeedback*>(
      ::protos::ModuleFeedback::internal_default_instance());
#else
  module_feedback_ = const_cast< ::protos::ModuleFeedback*>(&::protos::ModuleFeedback::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  parameter_command_ = const_cast< ::protos::ParameterMessage*>(
      ::protos::ParameterMessage::internal_default_instance());
#else
  parameter_command_ = const_cast< ::protos::ParameterMessage*>(&::protos::ParameterMessage::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  parameter_feedback_ = const_cast< ::protos::ParameterMessage*>(
      ::protos::ParameterMessage::internal_default_instance());
#else
  parameter_feedback_ = const_cast< ::protos::ParameterMessage*>(&::protos::ParameterMessage::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  remoteservice_ = const_cast< ::protos::RemoteService*>(
      ::protos::RemoteService::internal_default_instance());
#else
  remoteservice_ = const_cast< ::protos::RemoteService*>(&::protos::RemoteService::default_instance());
#endif
}

HeaderMessage::HeaderMessage(const HeaderMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void HeaderMessage::SharedCtor() {
  _cached_size_ = 0;
  ping_ = NULL;
  firmware_info_ = NULL;
  request_firmware_info_ = false;
  ethernet_info_ = NULL;
  request_ethernet_info_ = false;
  bootloader_ = NULL;
  tv_sec_ = 0u;
  tv_usec_ = 0u;
  module_command_ = NULL;
  module_feedback_ = NULL;
  parameter_command_ = NULL;
  parameter_feedback_ = NULL;
  remoteservice_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HeaderMessage::~HeaderMessage() {
  SharedDtor();
}

void HeaderMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete ping_;
    delete firmware_info_;
    delete ethernet_info_;
    delete bootloader_;
    delete module_command_;
    delete module_feedback_;
    delete parameter_command_;
    delete parameter_feedback_;
    delete remoteservice_;
  }
}

void HeaderMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HeaderMessage& HeaderMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_MetaInfo_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_MetaInfo_2eproto();
#endif
  return *default_instance_;
}

HeaderMessage* HeaderMessage::default_instance_ = NULL;

HeaderMessage* HeaderMessage::New() const {
  return new HeaderMessage;
}

void HeaderMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_ping()) {
      if (ping_ != NULL) ping_->::protos::Ping::Clear();
    }
    if (has_firmware_info()) {
      if (firmware_info_ != NULL) firmware_info_->::protos::FirmwareInfo::Clear();
    }
    request_firmware_info_ = false;
    if (has_ethernet_info()) {
      if (ethernet_info_ != NULL) ethernet_info_->::protos::EthernetInfo::Clear();
    }
    request_ethernet_info_ = false;
    if (has_bootloader()) {
      if (bootloader_ != NULL) bootloader_->::protos::bootloader::BootloaderMessage::Clear();
    }
    tv_sec_ = 0u;
    tv_usec_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_module_command()) {
      if (module_command_ != NULL) module_command_->::protos::ModuleCommand::Clear();
    }
    if (has_module_feedback()) {
      if (module_feedback_ != NULL) module_feedback_->::protos::ModuleFeedback::Clear();
    }
    if (has_parameter_command()) {
      if (parameter_command_ != NULL) parameter_command_->::protos::ParameterMessage::Clear();
    }
    if (has_parameter_feedback()) {
      if (parameter_feedback_ != NULL) parameter_feedback_->::protos::ParameterMessage::Clear();
    }
    if (has_remoteservice()) {
      if (remoteservice_ != NULL) remoteservice_->::protos::RemoteService::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool HeaderMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional fixed32 tv_sec = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &tv_sec_)));
          set_has_tv_sec();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_tv_usec;
        break;
      }

      // optional uint32 tv_usec = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tv_usec:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tv_usec_)));
          set_has_tv_usec();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_module_command;
        break;
      }

      // optional .protos.ModuleCommand module_command = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_module_command:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_module_command()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_module_feedback;
        break;
      }

      // optional .protos.ModuleFeedback module_feedback = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_module_feedback:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_module_feedback()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_parameter_command;
        break;
      }

      // optional .protos.ParameterMessage parameter_command = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_parameter_command:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_parameter_command()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(170)) goto parse_parameter_feedback;
        break;
      }

      // optional .protos.ParameterMessage parameter_feedback = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_parameter_feedback:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_parameter_feedback()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(250)) goto parse_remoteService;
        break;
      }

      // optional .protos.RemoteService remoteService = 31;
      case 31: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_remoteService:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_remoteservice()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(402)) goto parse_bootloader;
        break;
      }

      // optional .protos.bootloader.BootloaderMessage bootloader = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bootloader:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bootloader()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8042)) goto parse_ping;
        break;
      }

      // optional .protos.Ping ping = 1005;
      case 1005: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ping:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ping()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8082)) goto parse_firmware_info;
        break;
      }

      // optional .protos.FirmwareInfo firmware_info = 1010;
      case 1010: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_firmware_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_firmware_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8088)) goto parse_request_firmware_info;
        break;
      }

      // optional bool request_firmware_info = 1011;
      case 1011: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_request_firmware_info:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &request_firmware_info_)));
          set_has_request_firmware_info();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8122)) goto parse_ethernet_info;
        break;
      }

      // optional .protos.EthernetInfo ethernet_info = 1015;
      case 1015: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ethernet_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ethernet_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8128)) goto parse_request_ethernet_info;
        break;
      }

      // optional bool request_ethernet_info = 1016;
      case 1016: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_request_ethernet_info:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &request_ethernet_info_)));
          set_has_request_ethernet_info();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HeaderMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional fixed32 tv_sec = 1;
  if (has_tv_sec()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(1, this->tv_sec(), output);
  }

  // optional uint32 tv_usec = 2;
  if (has_tv_usec()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->tv_usec(), output);
  }

  // optional .protos.ModuleCommand module_command = 10;
  if (has_module_command()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, this->module_command(), output);
  }

  // optional .protos.ModuleFeedback module_feedback = 11;
  if (has_module_feedback()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, this->module_feedback(), output);
  }

  // optional .protos.ParameterMessage parameter_command = 20;
  if (has_parameter_command()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      20, this->parameter_command(), output);
  }

  // optional .protos.ParameterMessage parameter_feedback = 21;
  if (has_parameter_feedback()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      21, this->parameter_feedback(), output);
  }

  // optional .protos.RemoteService remoteService = 31;
  if (has_remoteservice()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      31, this->remoteservice(), output);
  }

  // optional .protos.bootloader.BootloaderMessage bootloader = 50;
  if (has_bootloader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      50, this->bootloader(), output);
  }

  // optional .protos.Ping ping = 1005;
  if (has_ping()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1005, this->ping(), output);
  }

  // optional .protos.FirmwareInfo firmware_info = 1010;
  if (has_firmware_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1010, this->firmware_info(), output);
  }

  // optional bool request_firmware_info = 1011;
  if (has_request_firmware_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1011, this->request_firmware_info(), output);
  }

  // optional .protos.EthernetInfo ethernet_info = 1015;
  if (has_ethernet_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1015, this->ethernet_info(), output);
  }

  // optional bool request_ethernet_info = 1016;
  if (has_request_ethernet_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1016, this->request_ethernet_info(), output);
  }

}

int HeaderMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .protos.Ping ping = 1005;
    if (has_ping()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ping());
    }

    // optional .protos.FirmwareInfo firmware_info = 1010;
    if (has_firmware_info()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->firmware_info());
    }

    // optional bool request_firmware_info = 1011;
    if (has_request_firmware_info()) {
      total_size += 2 + 1;
    }

    // optional .protos.EthernetInfo ethernet_info = 1015;
    if (has_ethernet_info()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ethernet_info());
    }

    // optional bool request_ethernet_info = 1016;
    if (has_request_ethernet_info()) {
      total_size += 2 + 1;
    }

    // optional .protos.bootloader.BootloaderMessage bootloader = 50;
    if (has_bootloader()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->bootloader());
    }

    // optional fixed32 tv_sec = 1;
    if (has_tv_sec()) {
      total_size += 1 + 4;
    }

    // optional uint32 tv_usec = 2;
    if (has_tv_usec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tv_usec());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .protos.ModuleCommand module_command = 10;
    if (has_module_command()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->module_command());
    }

    // optional .protos.ModuleFeedback module_feedback = 11;
    if (has_module_feedback()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->module_feedback());
    }

    // optional .protos.ParameterMessage parameter_command = 20;
    if (has_parameter_command()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->parameter_command());
    }

    // optional .protos.ParameterMessage parameter_feedback = 21;
    if (has_parameter_feedback()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->parameter_feedback());
    }

    // optional .protos.RemoteService remoteService = 31;
    if (has_remoteservice()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->remoteservice());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HeaderMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HeaderMessage*>(&from));
}

void HeaderMessage::MergeFrom(const HeaderMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ping()) {
      mutable_ping()->::protos::Ping::MergeFrom(from.ping());
    }
    if (from.has_firmware_info()) {
      mutable_firmware_info()->::protos::FirmwareInfo::MergeFrom(from.firmware_info());
    }
    if (from.has_request_firmware_info()) {
      set_request_firmware_info(from.request_firmware_info());
    }
    if (from.has_ethernet_info()) {
      mutable_ethernet_info()->::protos::EthernetInfo::MergeFrom(from.ethernet_info());
    }
    if (from.has_request_ethernet_info()) {
      set_request_ethernet_info(from.request_ethernet_info());
    }
    if (from.has_bootloader()) {
      mutable_bootloader()->::protos::bootloader::BootloaderMessage::MergeFrom(from.bootloader());
    }
    if (from.has_tv_sec()) {
      set_tv_sec(from.tv_sec());
    }
    if (from.has_tv_usec()) {
      set_tv_usec(from.tv_usec());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_module_command()) {
      mutable_module_command()->::protos::ModuleCommand::MergeFrom(from.module_command());
    }
    if (from.has_module_feedback()) {
      mutable_module_feedback()->::protos::ModuleFeedback::MergeFrom(from.module_feedback());
    }
    if (from.has_parameter_command()) {
      mutable_parameter_command()->::protos::ParameterMessage::MergeFrom(from.parameter_command());
    }
    if (from.has_parameter_feedback()) {
      mutable_parameter_feedback()->::protos::ParameterMessage::MergeFrom(from.parameter_feedback());
    }
    if (from.has_remoteservice()) {
      mutable_remoteservice()->::protos::RemoteService::MergeFrom(from.remoteservice());
    }
  }
}

void HeaderMessage::CopyFrom(const HeaderMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeaderMessage::IsInitialized() const {

  return true;
}

void HeaderMessage::Swap(HeaderMessage* other) {
  if (other != this) {
    std::swap(ping_, other->ping_);
    std::swap(firmware_info_, other->firmware_info_);
    std::swap(request_firmware_info_, other->request_firmware_info_);
    std::swap(ethernet_info_, other->ethernet_info_);
    std::swap(request_ethernet_info_, other->request_ethernet_info_);
    std::swap(bootloader_, other->bootloader_);
    std::swap(tv_sec_, other->tv_sec_);
    std::swap(tv_usec_, other->tv_usec_);
    std::swap(module_command_, other->module_command_);
    std::swap(module_feedback_, other->module_feedback_);
    std::swap(parameter_command_, other->parameter_command_);
    std::swap(parameter_feedback_, other->parameter_feedback_);
    std::swap(remoteservice_, other->remoteservice_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string HeaderMessage::GetTypeName() const {
  return "protos.HeaderMessage";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos

// @@protoc_insertion_point(global_scope)
