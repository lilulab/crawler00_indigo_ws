// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ModuleParameters.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ModuleParameters.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace protos {

void protobuf_ShutdownFile_ModuleParameters_2eproto() {
  delete ParameterMessage::default_instance_;
  delete PidControllerParameters::default_instance_;
  delete ControlLoopParameters::default_instance_;
  delete EthernetParameters::default_instance_;
  delete ImuParameters::default_instance_;
  delete LedParameters::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_ModuleParameters_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_ModuleParameters_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ParameterMessage::default_instance_ = new ParameterMessage();
  PidControllerParameters::default_instance_ = new PidControllerParameters();
  ControlLoopParameters::default_instance_ = new ControlLoopParameters();
  EthernetParameters::default_instance_ = new EthernetParameters();
  ImuParameters::default_instance_ = new ImuParameters();
  LedParameters::default_instance_ = new LedParameters();
  ParameterMessage::default_instance_->InitAsDefaultInstance();
  PidControllerParameters::default_instance_->InitAsDefaultInstance();
  ControlLoopParameters::default_instance_->InitAsDefaultInstance();
  EthernetParameters::default_instance_->InitAsDefaultInstance();
  ImuParameters::default_instance_->InitAsDefaultInstance();
  LedParameters::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ModuleParameters_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_ModuleParameters_2eproto_once_);
void protobuf_AddDesc_ModuleParameters_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_ModuleParameters_2eproto_once_,
                 &protobuf_AddDesc_ModuleParameters_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ModuleParameters_2eproto {
  StaticDescriptorInitializer_ModuleParameters_2eproto() {
    protobuf_AddDesc_ModuleParameters_2eproto();
  }
} static_descriptor_initializer_ModuleParameters_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int ParameterMessage::kControlLoopParametersFieldNumber;
const int ParameterMessage::kEthernetParametersFieldNumber;
const int ParameterMessage::kImuParametersFieldNumber;
const int ParameterMessage::kLedParametersFieldNumber;
#endif  // !_MSC_VER

ParameterMessage::ParameterMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ParameterMessage::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  control_loop_parameters_ = const_cast< ::protos::ControlLoopParameters*>(
      ::protos::ControlLoopParameters::internal_default_instance());
#else
  control_loop_parameters_ = const_cast< ::protos::ControlLoopParameters*>(&::protos::ControlLoopParameters::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  ethernet_parameters_ = const_cast< ::protos::EthernetParameters*>(
      ::protos::EthernetParameters::internal_default_instance());
#else
  ethernet_parameters_ = const_cast< ::protos::EthernetParameters*>(&::protos::EthernetParameters::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  imu_parameters_ = const_cast< ::protos::ImuParameters*>(
      ::protos::ImuParameters::internal_default_instance());
#else
  imu_parameters_ = const_cast< ::protos::ImuParameters*>(&::protos::ImuParameters::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  led_parameters_ = const_cast< ::protos::LedParameters*>(
      ::protos::LedParameters::internal_default_instance());
#else
  led_parameters_ = const_cast< ::protos::LedParameters*>(&::protos::LedParameters::default_instance());
#endif
}

ParameterMessage::ParameterMessage(const ParameterMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ParameterMessage::SharedCtor() {
  _cached_size_ = 0;
  control_loop_parameters_ = NULL;
  ethernet_parameters_ = NULL;
  imu_parameters_ = NULL;
  led_parameters_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ParameterMessage::~ParameterMessage() {
  SharedDtor();
}

void ParameterMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete control_loop_parameters_;
    delete ethernet_parameters_;
    delete imu_parameters_;
    delete led_parameters_;
  }
}

void ParameterMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ParameterMessage& ParameterMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ModuleParameters_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ModuleParameters_2eproto();
#endif
  return *default_instance_;
}

ParameterMessage* ParameterMessage::default_instance_ = NULL;

ParameterMessage* ParameterMessage::New() const {
  return new ParameterMessage;
}

void ParameterMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_control_loop_parameters()) {
      if (control_loop_parameters_ != NULL) control_loop_parameters_->::protos::ControlLoopParameters::Clear();
    }
    if (has_ethernet_parameters()) {
      if (ethernet_parameters_ != NULL) ethernet_parameters_->::protos::EthernetParameters::Clear();
    }
    if (has_imu_parameters()) {
      if (imu_parameters_ != NULL) imu_parameters_->::protos::ImuParameters::Clear();
    }
    if (has_led_parameters()) {
      if (led_parameters_ != NULL) led_parameters_->::protos::LedParameters::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ParameterMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .protos.ControlLoopParameters control_loop_parameters = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_control_loop_parameters()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_ethernet_parameters;
        break;
      }

      // optional .protos.EthernetParameters ethernet_parameters = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ethernet_parameters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ethernet_parameters()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_imu_parameters;
        break;
      }

      // optional .protos.ImuParameters imu_parameters = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_imu_parameters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_imu_parameters()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_led_parameters;
        break;
      }

      // optional .protos.LedParameters led_parameters = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_led_parameters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_led_parameters()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ParameterMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .protos.ControlLoopParameters control_loop_parameters = 1;
  if (has_control_loop_parameters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->control_loop_parameters(), output);
  }

  // optional .protos.EthernetParameters ethernet_parameters = 2;
  if (has_ethernet_parameters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->ethernet_parameters(), output);
  }

  // optional .protos.ImuParameters imu_parameters = 3;
  if (has_imu_parameters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->imu_parameters(), output);
  }

  // optional .protos.LedParameters led_parameters = 4;
  if (has_led_parameters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->led_parameters(), output);
  }

}

int ParameterMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .protos.ControlLoopParameters control_loop_parameters = 1;
    if (has_control_loop_parameters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->control_loop_parameters());
    }

    // optional .protos.EthernetParameters ethernet_parameters = 2;
    if (has_ethernet_parameters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ethernet_parameters());
    }

    // optional .protos.ImuParameters imu_parameters = 3;
    if (has_imu_parameters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->imu_parameters());
    }

    // optional .protos.LedParameters led_parameters = 4;
    if (has_led_parameters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->led_parameters());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ParameterMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ParameterMessage*>(&from));
}

void ParameterMessage::MergeFrom(const ParameterMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_control_loop_parameters()) {
      mutable_control_loop_parameters()->::protos::ControlLoopParameters::MergeFrom(from.control_loop_parameters());
    }
    if (from.has_ethernet_parameters()) {
      mutable_ethernet_parameters()->::protos::EthernetParameters::MergeFrom(from.ethernet_parameters());
    }
    if (from.has_imu_parameters()) {
      mutable_imu_parameters()->::protos::ImuParameters::MergeFrom(from.imu_parameters());
    }
    if (from.has_led_parameters()) {
      mutable_led_parameters()->::protos::LedParameters::MergeFrom(from.led_parameters());
    }
  }
}

void ParameterMessage::CopyFrom(const ParameterMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParameterMessage::IsInitialized() const {

  return true;
}

void ParameterMessage::Swap(ParameterMessage* other) {
  if (other != this) {
    std::swap(control_loop_parameters_, other->control_loop_parameters_);
    std::swap(ethernet_parameters_, other->ethernet_parameters_);
    std::swap(imu_parameters_, other->imu_parameters_);
    std::swap(led_parameters_, other->led_parameters_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ParameterMessage::GetTypeName() const {
  return "protos.ParameterMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int PidControllerParameters::kKpFieldNumber;
const int PidControllerParameters::kKiFieldNumber;
const int PidControllerParameters::kKdFieldNumber;
const int PidControllerParameters::kFfFieldNumber;
const int PidControllerParameters::kDeadZoneFieldNumber;
const int PidControllerParameters::kIClampFieldNumber;
const int PidControllerParameters::kEnabledFieldNumber;
const int PidControllerParameters::kPunchFieldNumber;
const int PidControllerParameters::kDWindowSizeFieldNumber;
const int PidControllerParameters::kMaxTargetValueFieldNumber;
const int PidControllerParameters::kMaxOutputValueFieldNumber;
const int PidControllerParameters::kTargetLowpassGainFieldNumber;
const int PidControllerParameters::kOutputLowpassGainFieldNumber;
const int PidControllerParameters::kDOnErrorFieldNumber;
#endif  // !_MSC_VER

PidControllerParameters::PidControllerParameters()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PidControllerParameters::InitAsDefaultInstance() {
}

PidControllerParameters::PidControllerParameters(const PidControllerParameters& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PidControllerParameters::SharedCtor() {
  _cached_size_ = 0;
  kp_ = 0;
  ki_ = 0;
  kd_ = 0;
  ff_ = 0;
  dead_zone_ = 0;
  i_clamp_ = 0;
  enabled_ = false;
  punch_ = 0;
  d_window_size_ = 0;
  max_target_value_ = 0;
  max_output_value_ = 0;
  target_lowpass_gain_ = 0;
  output_lowpass_gain_ = 0;
  d_on_error_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PidControllerParameters::~PidControllerParameters() {
  SharedDtor();
}

void PidControllerParameters::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PidControllerParameters::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PidControllerParameters& PidControllerParameters::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ModuleParameters_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ModuleParameters_2eproto();
#endif
  return *default_instance_;
}

PidControllerParameters* PidControllerParameters::default_instance_ = NULL;

PidControllerParameters* PidControllerParameters::New() const {
  return new PidControllerParameters;
}

void PidControllerParameters::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    kp_ = 0;
    ki_ = 0;
    kd_ = 0;
    ff_ = 0;
    dead_zone_ = 0;
    i_clamp_ = 0;
    enabled_ = false;
    punch_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    d_window_size_ = 0;
    max_target_value_ = 0;
    max_output_value_ = 0;
    target_lowpass_gain_ = 0;
    output_lowpass_gain_ = 0;
    d_on_error_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PidControllerParameters::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float kp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &kp_)));
          set_has_kp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_ki;
        break;
      }

      // optional float ki = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_ki:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &ki_)));
          set_has_ki();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_kd;
        break;
      }

      // optional float kd = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_kd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &kd_)));
          set_has_kd();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_ff;
        break;
      }

      // optional float ff = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_ff:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &ff_)));
          set_has_ff();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_dead_zone;
        break;
      }

      // optional float dead_zone = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_dead_zone:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &dead_zone_)));
          set_has_dead_zone();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_i_clamp;
        break;
      }

      // optional float i_clamp = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_i_clamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &i_clamp_)));
          set_has_i_clamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_enabled;
        break;
      }

      // optional bool enabled = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enabled_)));
          set_has_enabled();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_punch;
        break;
      }

      // optional float punch = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_punch:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &punch_)));
          set_has_punch();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(77)) goto parse_d_window_Size;
        break;
      }

      // optional float d_window_Size = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_d_window_Size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &d_window_size_)));
          set_has_d_window_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(85)) goto parse_max_target_value;
        break;
      }

      // optional float max_target_value = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_max_target_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_target_value_)));
          set_has_max_target_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(93)) goto parse_max_output_value;
        break;
      }

      // optional float max_output_value = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_max_output_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_output_value_)));
          set_has_max_output_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(101)) goto parse_target_lowpass_gain;
        break;
      }

      // optional float target_lowpass_gain = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_target_lowpass_gain:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &target_lowpass_gain_)));
          set_has_target_lowpass_gain();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(109)) goto parse_output_lowpass_gain;
        break;
      }

      // optional float output_lowpass_gain = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_output_lowpass_gain:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &output_lowpass_gain_)));
          set_has_output_lowpass_gain();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_d_on_error;
        break;
      }

      // optional bool d_on_error = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_d_on_error:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &d_on_error_)));
          set_has_d_on_error();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PidControllerParameters::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float kp = 1;
  if (has_kp()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->kp(), output);
  }

  // optional float ki = 2;
  if (has_ki()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->ki(), output);
  }

  // optional float kd = 3;
  if (has_kd()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->kd(), output);
  }

  // optional float ff = 4;
  if (has_ff()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->ff(), output);
  }

  // optional float dead_zone = 5;
  if (has_dead_zone()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->dead_zone(), output);
  }

  // optional float i_clamp = 6;
  if (has_i_clamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->i_clamp(), output);
  }

  // optional bool enabled = 7;
  if (has_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->enabled(), output);
  }

  // optional float punch = 8;
  if (has_punch()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->punch(), output);
  }

  // optional float d_window_Size = 9;
  if (has_d_window_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->d_window_size(), output);
  }

  // optional float max_target_value = 10;
  if (has_max_target_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->max_target_value(), output);
  }

  // optional float max_output_value = 11;
  if (has_max_output_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->max_output_value(), output);
  }

  // optional float target_lowpass_gain = 12;
  if (has_target_lowpass_gain()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(12, this->target_lowpass_gain(), output);
  }

  // optional float output_lowpass_gain = 13;
  if (has_output_lowpass_gain()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(13, this->output_lowpass_gain(), output);
  }

  // optional bool d_on_error = 14;
  if (has_d_on_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(14, this->d_on_error(), output);
  }

}

int PidControllerParameters::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float kp = 1;
    if (has_kp()) {
      total_size += 1 + 4;
    }

    // optional float ki = 2;
    if (has_ki()) {
      total_size += 1 + 4;
    }

    // optional float kd = 3;
    if (has_kd()) {
      total_size += 1 + 4;
    }

    // optional float ff = 4;
    if (has_ff()) {
      total_size += 1 + 4;
    }

    // optional float dead_zone = 5;
    if (has_dead_zone()) {
      total_size += 1 + 4;
    }

    // optional float i_clamp = 6;
    if (has_i_clamp()) {
      total_size += 1 + 4;
    }

    // optional bool enabled = 7;
    if (has_enabled()) {
      total_size += 1 + 1;
    }

    // optional float punch = 8;
    if (has_punch()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float d_window_Size = 9;
    if (has_d_window_size()) {
      total_size += 1 + 4;
    }

    // optional float max_target_value = 10;
    if (has_max_target_value()) {
      total_size += 1 + 4;
    }

    // optional float max_output_value = 11;
    if (has_max_output_value()) {
      total_size += 1 + 4;
    }

    // optional float target_lowpass_gain = 12;
    if (has_target_lowpass_gain()) {
      total_size += 1 + 4;
    }

    // optional float output_lowpass_gain = 13;
    if (has_output_lowpass_gain()) {
      total_size += 1 + 4;
    }

    // optional bool d_on_error = 14;
    if (has_d_on_error()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PidControllerParameters::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PidControllerParameters*>(&from));
}

void PidControllerParameters::MergeFrom(const PidControllerParameters& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kp()) {
      set_kp(from.kp());
    }
    if (from.has_ki()) {
      set_ki(from.ki());
    }
    if (from.has_kd()) {
      set_kd(from.kd());
    }
    if (from.has_ff()) {
      set_ff(from.ff());
    }
    if (from.has_dead_zone()) {
      set_dead_zone(from.dead_zone());
    }
    if (from.has_i_clamp()) {
      set_i_clamp(from.i_clamp());
    }
    if (from.has_enabled()) {
      set_enabled(from.enabled());
    }
    if (from.has_punch()) {
      set_punch(from.punch());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_d_window_size()) {
      set_d_window_size(from.d_window_size());
    }
    if (from.has_max_target_value()) {
      set_max_target_value(from.max_target_value());
    }
    if (from.has_max_output_value()) {
      set_max_output_value(from.max_output_value());
    }
    if (from.has_target_lowpass_gain()) {
      set_target_lowpass_gain(from.target_lowpass_gain());
    }
    if (from.has_output_lowpass_gain()) {
      set_output_lowpass_gain(from.output_lowpass_gain());
    }
    if (from.has_d_on_error()) {
      set_d_on_error(from.d_on_error());
    }
  }
}

void PidControllerParameters::CopyFrom(const PidControllerParameters& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PidControllerParameters::IsInitialized() const {

  return true;
}

void PidControllerParameters::Swap(PidControllerParameters* other) {
  if (other != this) {
    std::swap(kp_, other->kp_);
    std::swap(ki_, other->ki_);
    std::swap(kd_, other->kd_);
    std::swap(ff_, other->ff_);
    std::swap(dead_zone_, other->dead_zone_);
    std::swap(i_clamp_, other->i_clamp_);
    std::swap(enabled_, other->enabled_);
    std::swap(punch_, other->punch_);
    std::swap(d_window_size_, other->d_window_size_);
    std::swap(max_target_value_, other->max_target_value_);
    std::swap(max_output_value_, other->max_output_value_);
    std::swap(target_lowpass_gain_, other->target_lowpass_gain_);
    std::swap(output_lowpass_gain_, other->output_lowpass_gain_);
    std::swap(d_on_error_, other->d_on_error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PidControllerParameters::GetTypeName() const {
  return "protos.PidControllerParameters";
}


// ===================================================================

#ifndef _MSC_VER
const int ControlLoopParameters::kSaveFieldNumber;
const int ControlLoopParameters::kCascadedPeriodFieldNumber;
const int ControlLoopParameters::kCascadedPositionPidParametersFieldNumber;
const int ControlLoopParameters::kCascadedVelocityPParametersFieldNumber;
const int ControlLoopParameters::kCascadedTorquePidParametersFieldNumber;
const int ControlLoopParameters::kCascadedEnabledFieldNumber;
const int ControlLoopParameters::kMotorCurrentLimitFieldNumber;
const int ControlLoopParameters::kSpringConstantFieldNumber;
const int ControlLoopParameters::kVelocityWindowSizeFieldNumber;
const int ControlLoopParameters::kMotorHousingThermalResistanceFieldNumber;
const int ControlLoopParameters::kInnerEncoderKalmanGainsFieldNumber;
const int ControlLoopParameters::kInnerEncoderAccelDampFieldNumber;
const int ControlLoopParameters::kOuterEncoderKalmanGainsFieldNumber;
const int ControlLoopParameters::kOuterEncoderAccelDampFieldNumber;
#endif  // !_MSC_VER

ControlLoopParameters::ControlLoopParameters()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ControlLoopParameters::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  cascaded_position_pid_parameters_ = const_cast< ::protos::PidControllerParameters*>(
      ::protos::PidControllerParameters::internal_default_instance());
#else
  cascaded_position_pid_parameters_ = const_cast< ::protos::PidControllerParameters*>(&::protos::PidControllerParameters::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  cascaded_velocity_p_parameters_ = const_cast< ::protos::PidControllerParameters*>(
      ::protos::PidControllerParameters::internal_default_instance());
#else
  cascaded_velocity_p_parameters_ = const_cast< ::protos::PidControllerParameters*>(&::protos::PidControllerParameters::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  cascaded_torque_pid_parameters_ = const_cast< ::protos::PidControllerParameters*>(
      ::protos::PidControllerParameters::internal_default_instance());
#else
  cascaded_torque_pid_parameters_ = const_cast< ::protos::PidControllerParameters*>(&::protos::PidControllerParameters::default_instance());
#endif
}

ControlLoopParameters::ControlLoopParameters(const ControlLoopParameters& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ControlLoopParameters::SharedCtor() {
  _cached_size_ = 0;
  save_ = false;
  cascaded_period_ = 0;
  cascaded_position_pid_parameters_ = NULL;
  cascaded_velocity_p_parameters_ = NULL;
  cascaded_torque_pid_parameters_ = NULL;
  cascaded_enabled_ = false;
  motor_current_limit_ = 0;
  spring_constant_ = 0;
  velocity_window_size_ = 0;
  motor_housing_thermal_resistance_ = 0;
  inner_encoder_accel_damp_ = 0;
  outer_encoder_accel_damp_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ControlLoopParameters::~ControlLoopParameters() {
  SharedDtor();
}

void ControlLoopParameters::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete cascaded_position_pid_parameters_;
    delete cascaded_velocity_p_parameters_;
    delete cascaded_torque_pid_parameters_;
  }
}

void ControlLoopParameters::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ControlLoopParameters& ControlLoopParameters::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ModuleParameters_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ModuleParameters_2eproto();
#endif
  return *default_instance_;
}

ControlLoopParameters* ControlLoopParameters::default_instance_ = NULL;

ControlLoopParameters* ControlLoopParameters::New() const {
  return new ControlLoopParameters;
}

void ControlLoopParameters::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    save_ = false;
    cascaded_period_ = 0;
    if (has_cascaded_position_pid_parameters()) {
      if (cascaded_position_pid_parameters_ != NULL) cascaded_position_pid_parameters_->::protos::PidControllerParameters::Clear();
    }
    if (has_cascaded_velocity_p_parameters()) {
      if (cascaded_velocity_p_parameters_ != NULL) cascaded_velocity_p_parameters_->::protos::PidControllerParameters::Clear();
    }
    if (has_cascaded_torque_pid_parameters()) {
      if (cascaded_torque_pid_parameters_ != NULL) cascaded_torque_pid_parameters_->::protos::PidControllerParameters::Clear();
    }
    cascaded_enabled_ = false;
    motor_current_limit_ = 0;
    spring_constant_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    velocity_window_size_ = 0;
    motor_housing_thermal_resistance_ = 0;
    inner_encoder_accel_damp_ = 0;
    outer_encoder_accel_damp_ = 0;
  }
  inner_encoder_kalman_gains_.Clear();
  outer_encoder_kalman_gains_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ControlLoopParameters::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool save = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &save_)));
          set_has_save();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_cascaded_period;
        break;
      }

      // optional float cascaded_period = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_cascaded_period:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &cascaded_period_)));
          set_has_cascaded_period();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_cascaded_position_pid_parameters;
        break;
      }

      // optional .protos.PidControllerParameters cascaded_position_pid_parameters = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cascaded_position_pid_parameters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cascaded_position_pid_parameters()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_cascaded_velocity_p_parameters;
        break;
      }

      // optional .protos.PidControllerParameters cascaded_velocity_p_parameters = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cascaded_velocity_p_parameters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cascaded_velocity_p_parameters()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_cascaded_torque_pid_parameters;
        break;
      }

      // optional .protos.PidControllerParameters cascaded_torque_pid_parameters = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cascaded_torque_pid_parameters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cascaded_torque_pid_parameters()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_cascaded_enabled;
        break;
      }

      // optional bool cascaded_enabled = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cascaded_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &cascaded_enabled_)));
          set_has_cascaded_enabled();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(805)) goto parse_motor_current_limit;
        break;
      }

      // optional float motor_current_limit = 100;
      case 100: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_motor_current_limit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &motor_current_limit_)));
          set_has_motor_current_limit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(813)) goto parse_spring_constant;
        break;
      }

      // optional float spring_constant = 101;
      case 101: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_spring_constant:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &spring_constant_)));
          set_has_spring_constant();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(821)) goto parse_velocity_window_size;
        break;
      }

      // optional float velocity_window_size = 102;
      case 102: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_velocity_window_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &velocity_window_size_)));
          set_has_velocity_window_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(829)) goto parse_motor_housing_thermal_resistance;
        break;
      }

      // optional float motor_housing_thermal_resistance = 103;
      case 103: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_motor_housing_thermal_resistance:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &motor_housing_thermal_resistance_)));
          set_has_motor_housing_thermal_resistance();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(882)) goto parse_inner_encoder_kalman_gains;
        break;
      }

      // repeated float inner_encoder_kalman_gains = 110 [packed = true];
      case 110: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_inner_encoder_kalman_gains:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_inner_encoder_kalman_gains())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 2, 882, input, this->mutable_inner_encoder_kalman_gains())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(893)) goto parse_inner_encoder_accel_damp;
        break;
      }

      // optional float inner_encoder_accel_damp = 111;
      case 111: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_inner_encoder_accel_damp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &inner_encoder_accel_damp_)));
          set_has_inner_encoder_accel_damp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(922)) goto parse_outer_encoder_kalman_gains;
        break;
      }

      // repeated float outer_encoder_kalman_gains = 115 [packed = true];
      case 115: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_outer_encoder_kalman_gains:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_outer_encoder_kalman_gains())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 2, 922, input, this->mutable_outer_encoder_kalman_gains())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(933)) goto parse_outer_encoder_accel_damp;
        break;
      }

      // optional float outer_encoder_accel_damp = 116;
      case 116: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_outer_encoder_accel_damp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &outer_encoder_accel_damp_)));
          set_has_outer_encoder_accel_damp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ControlLoopParameters::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool save = 1;
  if (has_save()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->save(), output);
  }

  // optional float cascaded_period = 5;
  if (has_cascaded_period()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->cascaded_period(), output);
  }

  // optional .protos.PidControllerParameters cascaded_position_pid_parameters = 6;
  if (has_cascaded_position_pid_parameters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->cascaded_position_pid_parameters(), output);
  }

  // optional .protos.PidControllerParameters cascaded_velocity_p_parameters = 7;
  if (has_cascaded_velocity_p_parameters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->cascaded_velocity_p_parameters(), output);
  }

  // optional .protos.PidControllerParameters cascaded_torque_pid_parameters = 8;
  if (has_cascaded_torque_pid_parameters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->cascaded_torque_pid_parameters(), output);
  }

  // optional bool cascaded_enabled = 9;
  if (has_cascaded_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->cascaded_enabled(), output);
  }

  // optional float motor_current_limit = 100;
  if (has_motor_current_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(100, this->motor_current_limit(), output);
  }

  // optional float spring_constant = 101;
  if (has_spring_constant()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(101, this->spring_constant(), output);
  }

  // optional float velocity_window_size = 102;
  if (has_velocity_window_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(102, this->velocity_window_size(), output);
  }

  // optional float motor_housing_thermal_resistance = 103;
  if (has_motor_housing_thermal_resistance()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(103, this->motor_housing_thermal_resistance(), output);
  }

  // repeated float inner_encoder_kalman_gains = 110 [packed = true];
  if (this->inner_encoder_kalman_gains_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(110, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_inner_encoder_kalman_gains_cached_byte_size_);
  }
  for (int i = 0; i < this->inner_encoder_kalman_gains_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloatNoTag(
      this->inner_encoder_kalman_gains(i), output);
  }

  // optional float inner_encoder_accel_damp = 111;
  if (has_inner_encoder_accel_damp()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(111, this->inner_encoder_accel_damp(), output);
  }

  // repeated float outer_encoder_kalman_gains = 115 [packed = true];
  if (this->outer_encoder_kalman_gains_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(115, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_outer_encoder_kalman_gains_cached_byte_size_);
  }
  for (int i = 0; i < this->outer_encoder_kalman_gains_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloatNoTag(
      this->outer_encoder_kalman_gains(i), output);
  }

  // optional float outer_encoder_accel_damp = 116;
  if (has_outer_encoder_accel_damp()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(116, this->outer_encoder_accel_damp(), output);
  }

}

int ControlLoopParameters::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool save = 1;
    if (has_save()) {
      total_size += 1 + 1;
    }

    // optional float cascaded_period = 5;
    if (has_cascaded_period()) {
      total_size += 1 + 4;
    }

    // optional .protos.PidControllerParameters cascaded_position_pid_parameters = 6;
    if (has_cascaded_position_pid_parameters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cascaded_position_pid_parameters());
    }

    // optional .protos.PidControllerParameters cascaded_velocity_p_parameters = 7;
    if (has_cascaded_velocity_p_parameters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cascaded_velocity_p_parameters());
    }

    // optional .protos.PidControllerParameters cascaded_torque_pid_parameters = 8;
    if (has_cascaded_torque_pid_parameters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cascaded_torque_pid_parameters());
    }

    // optional bool cascaded_enabled = 9;
    if (has_cascaded_enabled()) {
      total_size += 1 + 1;
    }

    // optional float motor_current_limit = 100;
    if (has_motor_current_limit()) {
      total_size += 2 + 4;
    }

    // optional float spring_constant = 101;
    if (has_spring_constant()) {
      total_size += 2 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float velocity_window_size = 102;
    if (has_velocity_window_size()) {
      total_size += 2 + 4;
    }

    // optional float motor_housing_thermal_resistance = 103;
    if (has_motor_housing_thermal_resistance()) {
      total_size += 2 + 4;
    }

    // optional float inner_encoder_accel_damp = 111;
    if (has_inner_encoder_accel_damp()) {
      total_size += 2 + 4;
    }

    // optional float outer_encoder_accel_damp = 116;
    if (has_outer_encoder_accel_damp()) {
      total_size += 2 + 4;
    }

  }
  // repeated float inner_encoder_kalman_gains = 110 [packed = true];
  {
    int data_size = 0;
    data_size = 4 * this->inner_encoder_kalman_gains_size();
    if (data_size > 0) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _inner_encoder_kalman_gains_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated float outer_encoder_kalman_gains = 115 [packed = true];
  {
    int data_size = 0;
    data_size = 4 * this->outer_encoder_kalman_gains_size();
    if (data_size > 0) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _outer_encoder_kalman_gains_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ControlLoopParameters::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ControlLoopParameters*>(&from));
}

void ControlLoopParameters::MergeFrom(const ControlLoopParameters& from) {
  GOOGLE_CHECK_NE(&from, this);
  inner_encoder_kalman_gains_.MergeFrom(from.inner_encoder_kalman_gains_);
  outer_encoder_kalman_gains_.MergeFrom(from.outer_encoder_kalman_gains_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_save()) {
      set_save(from.save());
    }
    if (from.has_cascaded_period()) {
      set_cascaded_period(from.cascaded_period());
    }
    if (from.has_cascaded_position_pid_parameters()) {
      mutable_cascaded_position_pid_parameters()->::protos::PidControllerParameters::MergeFrom(from.cascaded_position_pid_parameters());
    }
    if (from.has_cascaded_velocity_p_parameters()) {
      mutable_cascaded_velocity_p_parameters()->::protos::PidControllerParameters::MergeFrom(from.cascaded_velocity_p_parameters());
    }
    if (from.has_cascaded_torque_pid_parameters()) {
      mutable_cascaded_torque_pid_parameters()->::protos::PidControllerParameters::MergeFrom(from.cascaded_torque_pid_parameters());
    }
    if (from.has_cascaded_enabled()) {
      set_cascaded_enabled(from.cascaded_enabled());
    }
    if (from.has_motor_current_limit()) {
      set_motor_current_limit(from.motor_current_limit());
    }
    if (from.has_spring_constant()) {
      set_spring_constant(from.spring_constant());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_velocity_window_size()) {
      set_velocity_window_size(from.velocity_window_size());
    }
    if (from.has_motor_housing_thermal_resistance()) {
      set_motor_housing_thermal_resistance(from.motor_housing_thermal_resistance());
    }
    if (from.has_inner_encoder_accel_damp()) {
      set_inner_encoder_accel_damp(from.inner_encoder_accel_damp());
    }
    if (from.has_outer_encoder_accel_damp()) {
      set_outer_encoder_accel_damp(from.outer_encoder_accel_damp());
    }
  }
}

void ControlLoopParameters::CopyFrom(const ControlLoopParameters& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ControlLoopParameters::IsInitialized() const {

  return true;
}

void ControlLoopParameters::Swap(ControlLoopParameters* other) {
  if (other != this) {
    std::swap(save_, other->save_);
    std::swap(cascaded_period_, other->cascaded_period_);
    std::swap(cascaded_position_pid_parameters_, other->cascaded_position_pid_parameters_);
    std::swap(cascaded_velocity_p_parameters_, other->cascaded_velocity_p_parameters_);
    std::swap(cascaded_torque_pid_parameters_, other->cascaded_torque_pid_parameters_);
    std::swap(cascaded_enabled_, other->cascaded_enabled_);
    std::swap(motor_current_limit_, other->motor_current_limit_);
    std::swap(spring_constant_, other->spring_constant_);
    std::swap(velocity_window_size_, other->velocity_window_size_);
    std::swap(motor_housing_thermal_resistance_, other->motor_housing_thermal_resistance_);
    inner_encoder_kalman_gains_.Swap(&other->inner_encoder_kalman_gains_);
    std::swap(inner_encoder_accel_damp_, other->inner_encoder_accel_damp_);
    outer_encoder_kalman_gains_.Swap(&other->outer_encoder_kalman_gains_);
    std::swap(outer_encoder_accel_damp_, other->outer_encoder_accel_damp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ControlLoopParameters::GetTypeName() const {
  return "protos.ControlLoopParameters";
}


// ===================================================================

#ifndef _MSC_VER
const int EthernetParameters::kSaveFieldNumber;
const int EthernetParameters::kMacAddressFieldNumber;
const int EthernetParameters::kAddressFieldNumber;
const int EthernetParameters::kNetmaskFieldNumber;
const int EthernetParameters::kGatewayFieldNumber;
const int EthernetParameters::kProximalIpFieldNumber;
const int EthernetParameters::kDistalIpFieldNumber;
#endif  // !_MSC_VER

EthernetParameters::EthernetParameters()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EthernetParameters::InitAsDefaultInstance() {
}

EthernetParameters::EthernetParameters(const EthernetParameters& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EthernetParameters::SharedCtor() {
  _cached_size_ = 0;
  save_ = false;
  mac_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  netmask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  gateway_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  proximal_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  distal_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EthernetParameters::~EthernetParameters() {
  SharedDtor();
}

void EthernetParameters::SharedDtor() {
  if (mac_address_ != &::google::protobuf::internal::kEmptyString) {
    delete mac_address_;
  }
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (netmask_ != &::google::protobuf::internal::kEmptyString) {
    delete netmask_;
  }
  if (gateway_ != &::google::protobuf::internal::kEmptyString) {
    delete gateway_;
  }
  if (proximal_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete proximal_ip_;
  }
  if (distal_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete distal_ip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EthernetParameters::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EthernetParameters& EthernetParameters::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ModuleParameters_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ModuleParameters_2eproto();
#endif
  return *default_instance_;
}

EthernetParameters* EthernetParameters::default_instance_ = NULL;

EthernetParameters* EthernetParameters::New() const {
  return new EthernetParameters;
}

void EthernetParameters::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    save_ = false;
    if (has_mac_address()) {
      if (mac_address_ != &::google::protobuf::internal::kEmptyString) {
        mac_address_->clear();
      }
    }
    if (has_address()) {
      if (address_ != &::google::protobuf::internal::kEmptyString) {
        address_->clear();
      }
    }
    if (has_netmask()) {
      if (netmask_ != &::google::protobuf::internal::kEmptyString) {
        netmask_->clear();
      }
    }
    if (has_gateway()) {
      if (gateway_ != &::google::protobuf::internal::kEmptyString) {
        gateway_->clear();
      }
    }
    if (has_proximal_ip()) {
      if (proximal_ip_ != &::google::protobuf::internal::kEmptyString) {
        proximal_ip_->clear();
      }
    }
    if (has_distal_ip()) {
      if (distal_ip_ != &::google::protobuf::internal::kEmptyString) {
        distal_ip_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EthernetParameters::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool save = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &save_)));
          set_has_save();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_mac_address;
        break;
      }

      // optional bytes mac_address = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mac_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_mac_address()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_address;
        break;
      }

      // optional bytes address = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_address()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(170)) goto parse_netmask;
        break;
      }

      // optional bytes netmask = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_netmask:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_netmask()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(178)) goto parse_gateway;
        break;
      }

      // optional bytes gateway = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gateway:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_gateway()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(322)) goto parse_proximal_ip;
        break;
      }

      // optional bytes proximal_ip = 40;
      case 40: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_proximal_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_proximal_ip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(330)) goto parse_distal_ip;
        break;
      }

      // optional bytes distal_ip = 41;
      case 41: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_distal_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_distal_ip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EthernetParameters::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool save = 1;
  if (has_save()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->save(), output);
  }

  // optional bytes mac_address = 10;
  if (has_mac_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      10, this->mac_address(), output);
  }

  // optional bytes address = 20;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      20, this->address(), output);
  }

  // optional bytes netmask = 21;
  if (has_netmask()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      21, this->netmask(), output);
  }

  // optional bytes gateway = 22;
  if (has_gateway()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      22, this->gateway(), output);
  }

  // optional bytes proximal_ip = 40;
  if (has_proximal_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      40, this->proximal_ip(), output);
  }

  // optional bytes distal_ip = 41;
  if (has_distal_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      41, this->distal_ip(), output);
  }

}

int EthernetParameters::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool save = 1;
    if (has_save()) {
      total_size += 1 + 1;
    }

    // optional bytes mac_address = 10;
    if (has_mac_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->mac_address());
    }

    // optional bytes address = 20;
    if (has_address()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->address());
    }

    // optional bytes netmask = 21;
    if (has_netmask()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->netmask());
    }

    // optional bytes gateway = 22;
    if (has_gateway()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->gateway());
    }

    // optional bytes proximal_ip = 40;
    if (has_proximal_ip()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->proximal_ip());
    }

    // optional bytes distal_ip = 41;
    if (has_distal_ip()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->distal_ip());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EthernetParameters::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EthernetParameters*>(&from));
}

void EthernetParameters::MergeFrom(const EthernetParameters& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_save()) {
      set_save(from.save());
    }
    if (from.has_mac_address()) {
      set_mac_address(from.mac_address());
    }
    if (from.has_address()) {
      set_address(from.address());
    }
    if (from.has_netmask()) {
      set_netmask(from.netmask());
    }
    if (from.has_gateway()) {
      set_gateway(from.gateway());
    }
    if (from.has_proximal_ip()) {
      set_proximal_ip(from.proximal_ip());
    }
    if (from.has_distal_ip()) {
      set_distal_ip(from.distal_ip());
    }
  }
}

void EthernetParameters::CopyFrom(const EthernetParameters& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthernetParameters::IsInitialized() const {

  return true;
}

void EthernetParameters::Swap(EthernetParameters* other) {
  if (other != this) {
    std::swap(save_, other->save_);
    std::swap(mac_address_, other->mac_address_);
    std::swap(address_, other->address_);
    std::swap(netmask_, other->netmask_);
    std::swap(gateway_, other->gateway_);
    std::swap(proximal_ip_, other->proximal_ip_);
    std::swap(distal_ip_, other->distal_ip_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EthernetParameters::GetTypeName() const {
  return "protos.EthernetParameters";
}


// ===================================================================

bool ImuParameters_AccelScale_IsValid(int value) {
  switch(value) {
    case 2:
    case 4:
    case 8:
    case 16:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ImuParameters_AccelScale ImuParameters::G_2;
const ImuParameters_AccelScale ImuParameters::G_4;
const ImuParameters_AccelScale ImuParameters::G_8;
const ImuParameters_AccelScale ImuParameters::G_16;
const ImuParameters_AccelScale ImuParameters::AccelScale_MIN;
const ImuParameters_AccelScale ImuParameters::AccelScale_MAX;
const int ImuParameters::AccelScale_ARRAYSIZE;
#endif  // _MSC_VER
bool ImuParameters_AccelCutoff_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ImuParameters_AccelCutoff ImuParameters::Hz_260;
const ImuParameters_AccelCutoff ImuParameters::Hz_184;
const ImuParameters_AccelCutoff ImuParameters::Hz_94;
const ImuParameters_AccelCutoff ImuParameters::Hz_44;
const ImuParameters_AccelCutoff ImuParameters::Hz_21;
const ImuParameters_AccelCutoff ImuParameters::Hz_10;
const ImuParameters_AccelCutoff ImuParameters::Hz_5;
const ImuParameters_AccelCutoff ImuParameters::AccelCutoff_MIN;
const ImuParameters_AccelCutoff ImuParameters::AccelCutoff_MAX;
const int ImuParameters::AccelCutoff_ARRAYSIZE;
#endif  // _MSC_VER
bool ImuParameters_GyroScale_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ImuParameters_GyroScale ImuParameters::DEG_PER_S_250;
const ImuParameters_GyroScale ImuParameters::DEG_PER_S_500;
const ImuParameters_GyroScale ImuParameters::DEG_PER_S_1000;
const ImuParameters_GyroScale ImuParameters::DEG_PER_S_2000;
const ImuParameters_GyroScale ImuParameters::GyroScale_MIN;
const ImuParameters_GyroScale ImuParameters::GyroScale_MAX;
const int ImuParameters::GyroScale_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ImuParameters::kSaveFieldNumber;
const int ImuParameters::kAccelScaleFieldNumber;
const int ImuParameters::kAccelCutoffFieldNumber;
const int ImuParameters::kGyroScaleFieldNumber;
#endif  // !_MSC_VER

ImuParameters::ImuParameters()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ImuParameters::InitAsDefaultInstance() {
}

ImuParameters::ImuParameters(const ImuParameters& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ImuParameters::SharedCtor() {
  _cached_size_ = 0;
  save_ = false;
  accel_scale_ = 2;
  accel_cutoff_ = 1;
  gyro_scale_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ImuParameters::~ImuParameters() {
  SharedDtor();
}

void ImuParameters::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ImuParameters::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ImuParameters& ImuParameters::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ModuleParameters_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ModuleParameters_2eproto();
#endif
  return *default_instance_;
}

ImuParameters* ImuParameters::default_instance_ = NULL;

ImuParameters* ImuParameters::New() const {
  return new ImuParameters;
}

void ImuParameters::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    save_ = false;
    accel_scale_ = 2;
    accel_cutoff_ = 1;
    gyro_scale_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ImuParameters::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool save = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &save_)));
          set_has_save();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_accel_scale;
        break;
      }

      // optional .protos.ImuParameters.AccelScale accel_scale = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_accel_scale:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protos::ImuParameters_AccelScale_IsValid(value)) {
            set_accel_scale(static_cast< ::protos::ImuParameters_AccelScale >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_accel_cutoff;
        break;
      }

      // optional .protos.ImuParameters.AccelCutoff accel_cutoff = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_accel_cutoff:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protos::ImuParameters_AccelCutoff_IsValid(value)) {
            set_accel_cutoff(static_cast< ::protos::ImuParameters_AccelCutoff >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(160)) goto parse_gyro_scale;
        break;
      }

      // optional .protos.ImuParameters.GyroScale gyro_scale = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gyro_scale:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protos::ImuParameters_GyroScale_IsValid(value)) {
            set_gyro_scale(static_cast< ::protos::ImuParameters_GyroScale >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ImuParameters::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool save = 1;
  if (has_save()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->save(), output);
  }

  // optional .protos.ImuParameters.AccelScale accel_scale = 10;
  if (has_accel_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->accel_scale(), output);
  }

  // optional .protos.ImuParameters.AccelCutoff accel_cutoff = 11;
  if (has_accel_cutoff()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      11, this->accel_cutoff(), output);
  }

  // optional .protos.ImuParameters.GyroScale gyro_scale = 20;
  if (has_gyro_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      20, this->gyro_scale(), output);
  }

}

int ImuParameters::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool save = 1;
    if (has_save()) {
      total_size += 1 + 1;
    }

    // optional .protos.ImuParameters.AccelScale accel_scale = 10;
    if (has_accel_scale()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->accel_scale());
    }

    // optional .protos.ImuParameters.AccelCutoff accel_cutoff = 11;
    if (has_accel_cutoff()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->accel_cutoff());
    }

    // optional .protos.ImuParameters.GyroScale gyro_scale = 20;
    if (has_gyro_scale()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->gyro_scale());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImuParameters::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ImuParameters*>(&from));
}

void ImuParameters::MergeFrom(const ImuParameters& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_save()) {
      set_save(from.save());
    }
    if (from.has_accel_scale()) {
      set_accel_scale(from.accel_scale());
    }
    if (from.has_accel_cutoff()) {
      set_accel_cutoff(from.accel_cutoff());
    }
    if (from.has_gyro_scale()) {
      set_gyro_scale(from.gyro_scale());
    }
  }
}

void ImuParameters::CopyFrom(const ImuParameters& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImuParameters::IsInitialized() const {

  return true;
}

void ImuParameters::Swap(ImuParameters* other) {
  if (other != this) {
    std::swap(save_, other->save_);
    std::swap(accel_scale_, other->accel_scale_);
    std::swap(accel_cutoff_, other->accel_cutoff_);
    std::swap(gyro_scale_, other->gyro_scale_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ImuParameters::GetTypeName() const {
  return "protos.ImuParameters";
}


// ===================================================================

#ifndef _MSC_VER
const int LedParameters::kRGBAFieldNumber;
#endif  // !_MSC_VER

LedParameters::LedParameters()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LedParameters::InitAsDefaultInstance() {
}

LedParameters::LedParameters(const LedParameters& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LedParameters::SharedCtor() {
  _cached_size_ = 0;
  rgba_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LedParameters::~LedParameters() {
  SharedDtor();
}

void LedParameters::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LedParameters::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LedParameters& LedParameters::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ModuleParameters_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ModuleParameters_2eproto();
#endif
  return *default_instance_;
}

LedParameters* LedParameters::default_instance_ = NULL;

LedParameters* LedParameters::New() const {
  return new LedParameters;
}

void LedParameters::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    rgba_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LedParameters::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional fixed32 RGBA = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &rgba_)));
          set_has_rgba();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LedParameters::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional fixed32 RGBA = 10;
  if (has_rgba()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(10, this->rgba(), output);
  }

}

int LedParameters::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional fixed32 RGBA = 10;
    if (has_rgba()) {
      total_size += 1 + 4;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LedParameters::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LedParameters*>(&from));
}

void LedParameters::MergeFrom(const LedParameters& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rgba()) {
      set_rgba(from.rgba());
    }
  }
}

void LedParameters::CopyFrom(const LedParameters& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LedParameters::IsInitialized() const {

  return true;
}

void LedParameters::Swap(LedParameters* other) {
  if (other != this) {
    std::swap(rgba_, other->rgba_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LedParameters::GetTypeName() const {
  return "protos.LedParameters";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos

// @@protoc_insertion_point(global_scope)
